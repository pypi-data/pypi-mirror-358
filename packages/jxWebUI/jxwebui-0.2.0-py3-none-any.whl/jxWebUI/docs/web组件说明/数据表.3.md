
## 定义格式

容器表的定义格式为：

	dataTable 表名 属性列表 (行计算)?: 列+ ;

属性列表见整体说明中的额外说明部分。

列：

	col 列名 head 列头 属性列表 
	或者
	col 列名 head 列头 type a 属性列表 

如：

	dataTable table2 title='查询结果',bind=tableTotalCount,width=900,pagination=true:
		col devID head devID hide=true, width=200
		col devType head 设备类型 width=200
		col devName head 设备名称 width=200
		col op head 操作 type a width=200,capaname='test.query_device',motion=cmd,
			demand=active1,text='查看数据',ignoreCapaid=true,primary=true,
			require=[{'paramName':'devType'},{'paramName':'devName'}]

显示效果就是下图中的【查询结果】。

![test_web](http://115.29.52.95:10018/images/dt_1.png)

数据表table2定义了四列，对的，你没瞎我也没说错，确实是四列，只不过devID这一列定义了一个hide=true的属性，所以它就隐藏不见了。

为什么不让用户看还要定义呢？因为它是ID啊，这一行的最后有一个type a的工具条【查看数据】，点不同行的查看数据，肯定想查看的是这一行的设备数据啊。所以这时就需要同时给出这一行的设备ID，但这个数据用户看了没啥用，所以要隐藏起来。

最后的操作这一列，定义了一个工具条，具体的说明请查
## 属性

### bind
类型：string
缺省值：

查询数据时，数据表必须设置bind属性为：tableTotalCount。这是分页查询所必须的，否则无法正常初始化分页的页码。

### title
类型：string
缺省值：

表的标题。

### header
类型：bool
缺省值：true

是否显示表头。表头包括：标题【左侧】、添加新行的按钮【右侧】。

你现在正在看的页面就是没有表头的显示效果。

### width
类型：int
缺省值：

表的宽度。笔者当时是按1280来设计的，所以表宽一般设为900。

### pagination
类型：bool
缺省值：false

pagination=true是给数据表添加分页控件。

添加了分页控件的表就是**条件查询分页显示**的查询表。jxWebUI知道接管了search、reSearch两个事件完成了自动化的查询工作流。详见数据表与数控库的访问一章。

### newRow
类型：bool
缺省值：false

是否在表头最右侧添加一个白色的十字，点击该十字就会添加一行供用户输入表数据。请注意下图数据表表头最右侧的白色十字：

![hello_world](http://115.29.52.95:10018/images/ac_1.png)

点击这个白色的十字，就会出现一行空白的输入框，供用户输入表数据。
## 联立运算

数据表只能定义行计算，其定义格式如下：

	compute pre row 列名 = 列名 (+|-|*|/ [列名|数值])+

详细说明请参考前端联立计算一章。

## 额外说明

1、你应该已经看出来了，容器表和数据表实质上就是同一个表控件。jxWebUI中进行区分的目的很简单：专用。

- 容器表，用来放置其它控件进行行列对齐
- 设置了pagination=true的数据表是查询表，用来执行条件查询分页显示
- 设置了newRow=true的数据表是录入表，用来完成表格型数据的录入与显示

2、行计算只能用在录入表中

3、每行的工具条只能用在查询表中

4、录入表的数据是整表读取【capaInstance.getInput(表名)】、整表输出【capaInstance.set_output_datatable(表名,行数据数组)】


