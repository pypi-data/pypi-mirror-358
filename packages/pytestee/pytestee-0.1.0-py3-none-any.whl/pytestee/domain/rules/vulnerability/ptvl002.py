"""PTVL002: Time Dependency Detection."""

import ast
from typing import Optional

from pytestee.domain.models import CheckerConfig, CheckResult, TestFile, TestFunction
from pytestee.domain.rules.base_rule import BaseRule


class PTVL002(BaseRule):
    """Rule for detecting time-dependent code in tests."""

    def __init__(self) -> None:
        super().__init__(
            rule_id="PTVL002",
            name="time_dependency_detection",
            description="Test function contains time-dependent code that may cause flaky tests",
        )
        # Time-related functions that should be avoided in tests
        self._time_functions = {
            "datetime.now",
            "datetime.today",
            "datetime.utcnow",
            "time.time",
            "time.sleep",
            "time.localtime",
            "time.gmtime",
            "now",
            "today",
            "utcnow",
        }

    def check(
        self,
        test_function: TestFunction,
        test_file: TestFile,
        config: Optional[CheckerConfig] = None,
    ) -> CheckResult:
        """Check if test function contains time-dependent code."""
        time_dependencies = self._find_time_dependencies(test_function)

        if time_dependencies:
            dependency_details = ", ".join(f"line {line}: {func}" for line, func in time_dependencies)
            return self._create_failure_result(
                f"Time dependency detected: {dependency_details}. "
                "Consider using mocks or fixed time values to avoid flaky tests.",
                test_file,
                test_function,
            )

        return self._create_success_result(
            "No time dependencies found",
            test_file,
            test_function,
        )

    def _find_time_dependencies(self, test_function: TestFunction) -> list[tuple[int, str]]:
        """Find time-dependent function calls in the test function."""
        time_dependencies = []

        # Create a module node to walk through the AST
        module = ast.Module(body=test_function.body, type_ignores=[])

        for node in ast.walk(module):
            if isinstance(node, ast.Call):
                func_name = self._get_function_name(node.func)
                if func_name and func_name in self._time_functions:
                    line_no = getattr(node, "lineno", test_function.lineno)
                    time_dependencies.append((line_no, func_name))

        return time_dependencies

    def _get_function_name(self, func_node: ast.expr) -> Optional[str]:
        """Extract function name from AST node."""
        if isinstance(func_node, ast.Name):
            return func_node.id
        if isinstance(func_node, ast.Attribute):
            # Handle chained attributes like datetime.datetime.now
            parts = []
            current: ast.expr = func_node
            while isinstance(current, ast.Attribute):
                parts.append(current.attr)
                current = current.value
            if isinstance(current, ast.Name):
                parts.append(current.id)
            return ".".join(reversed(parts))
        return None
