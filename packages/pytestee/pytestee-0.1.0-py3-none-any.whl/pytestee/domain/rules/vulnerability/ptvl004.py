"""PTVL004: Global State Modification Detection."""

import ast
from typing import Optional

from pytestee.domain.models import CheckerConfig, CheckResult, TestFile, TestFunction
from pytestee.domain.rules.base_rule import BaseRule


class PTVL004(BaseRule):
    """Rule for detecting global state modifications in tests."""

    def __init__(self) -> None:
        super().__init__(
            rule_id="PTVL004",
            name="global_state_modification_detection",
            description="Test function modifies global state that may affect other tests",
        )

    def check(
        self,
        test_function: TestFunction,
        test_file: TestFile,
        config: Optional[CheckerConfig] = None,
    ) -> CheckResult:
        """Check if test function modifies global state."""
        global_modifications = self._find_global_modifications(test_function)

        if global_modifications:
            modification_details = ", ".join(f"line {line}: {var}" for line, var in global_modifications)
            return self._create_failure_result(
                f"Global state modification detected: {modification_details}. "
                "Consider using dependency injection, mocks, or test fixtures to avoid test isolation issues.",
                test_file,
                test_function,
            )

        return self._create_success_result(
            "No global state modifications found",
            test_file,
            test_function,
        )

    def _find_global_modifications(self, test_function: TestFunction) -> list[tuple[int, str]]:
        """Find global state modifications in the test function."""
        global_modifications = []

        # Create a module node to walk through the AST
        module = ast.Module(body=test_function.body, type_ignores=[])

        for node in ast.walk(module):
            # Check for global variable assignments
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        # Check if it's likely a global variable (ALL_CAPS or module-level)
                        if target.id.isupper() or self._looks_like_global_var(target.id):
                            line_no = getattr(node, "lineno", test_function.lineno)
                            global_modifications.append((line_no, target.id))
                    elif (isinstance(target, ast.Attribute) and
                          isinstance(target.value, ast.Name) and
                          (self._looks_like_global_var(target.attr) or target.attr.isupper())):
                        # Module-level attribute assignment like module.GLOBAL_VAR = value
                        # Only consider it global if the attribute looks like a global variable
                        var_name = f"{target.value.id}.{target.attr}"
                        line_no = getattr(node, "lineno", test_function.lineno)
                        global_modifications.append((line_no, var_name))

            # Check for global statement usage
            elif isinstance(node, ast.Global):
                for name in node.names:
                    line_no = getattr(node, "lineno", test_function.lineno)
                    global_modifications.append((line_no, f"global {name}"))

        return global_modifications

    def _looks_like_global_var(self, var_name: str) -> bool:
        """Check if variable name looks like a global variable."""
        # Common patterns for global variables
        global_patterns = [
            var_name.isupper(),  # ALL_CAPS
            var_name.startswith("_") and var_name.isupper(),  # _PRIVATE_GLOBAL
            len(var_name) > 10 and "_" in var_name,  # Long names with underscores
        ]
        return any(global_patterns)
