# generated by datamodel-codegen:
#   filename:  well_known_types.yaml

from __future__ import annotations

from enum import Enum
from typing import Any, Union

from pydantic import Field, RootModel, constr


class Model(RootModel[Any]):
    root: Any


class String(RootModel[str]):
    root: str = Field(..., description='Arbitrary text')


class BinaryData(
    RootModel[
        constr(
            pattern=r'^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$'
        )
    ]
):
    root: constr(
        pattern=r'^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$'
    ) = Field(
        ...,
        description='Arbitrary binary data. Represented as base64-encoded strings in the JSON transport. In the future, if we support other transports, may be encoded differently.\n',
    )


class Date(RootModel[constr(pattern=r'^\d{4}-\d{2}-\d{2}( BC)?$')]):
    root: constr(pattern=r'^\d{4}-\d{2}-\d{2}( BC)?$') = Field(
        ..., description="RFC 3339§5.6's full-date format, extended with BC era support"
    )


class TimestampWithTimezone(
    RootModel[
        constr(
            pattern=r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+\-]\d{1,2}:\d{2})( BC)?$'
        )
    ]
):
    root: constr(
        pattern=r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+\-]\d{1,2}:\d{2})( BC)?$'
    ) = Field(
        ...,
        description='An instant in time. Frequently simply referred to as just a timestamp, or timestamptz. Uses RFC 3339§5.6\'s date-time format, requiring a "T" separator, and extended with BC era support. Note that we do _not_ accept Unix epochs here.\n',
    )


class TimestampWithoutTimezone(
    RootModel[constr(pattern=r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?( BC)?$')]
):
    root: constr(
        pattern=r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?( BC)?$'
    ) = Field(
        ...,
        description='Also known as a localdatetime, or just datetime. Under RFC 3339§5.6, this would be represented as `full-date "T" partial-time`, extended with BC era support.\n',
    )


class TimeWithTimezone(
    RootModel[constr(pattern=r'^\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+\-]\d{1,2}:\d{2})$')]
):
    root: constr(pattern=r'^\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+\-]\d{1,2}:\d{2})$') = Field(
        ..., description='An RFC 3339§5.6 full-time'
    )


class TimeWithoutTimezone(RootModel[constr(pattern=r'^\d{2}:\d{2}:\d{2}(\.\d+)?$')]):
    root: constr(pattern=r'^\d{2}:\d{2}:\d{2}(\.\d+)?$') = Field(
        ..., description='An RFC 3339§5.6 partial-time'
    )


class Number1(Enum):
    Infinity = 'Infinity'
    field_Infinity = '-Infinity'
    NaN = 'NaN'


class Number(RootModel[Union[constr(pattern=r'-?(0|[0-9]\d*)(\.\d+)?'), Number1]]):
    root: Union[constr(pattern=r'-?(0|[0-9]\d*)(\.\d+)?'), Number1] = Field(
        ...,
        description='Note the mix of regex validation for normal numbers, and enum validation for special values.',
    )


class Integer1(Enum):
    Infinity = 'Infinity'
    field_Infinity = '-Infinity'
    NaN = 'NaN'


class Integer(RootModel[Union[constr(pattern=r'-?(0|[0-9]\d*)'), Integer1]]):
    root: Union[constr(pattern=r'-?(0|[0-9]\d*)'), Integer1]


class Boolean(RootModel[bool]):
    root: bool = Field(
        ...,
        description="Note the direct usage of a primitive boolean rather than string. Unlike Numbers and Integers, we don't expect unusual values  here.",
    )
