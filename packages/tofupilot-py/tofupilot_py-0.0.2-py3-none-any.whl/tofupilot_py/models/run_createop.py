"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from enum import Enum
import pydantic
from pydantic import model_serializer
from tofupilot_py.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class UnitUnderTestTypedDict(TypedDict):
    serial_number: str
    part_name: NotRequired[Nullable[str]]
    r"""The `part_name` field is now ignored by `create_run`. You can safely remove it from your scripts."""
    part_number: NotRequired[str]
    batch_number: NotRequired[str]
    revision: NotRequired[str]


class UnitUnderTest(BaseModel):
    serial_number: str

    part_name: Annotated[
        OptionalNullable[str],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = UNSET
    r"""The `part_name` field is now ignored by `create_run`. You can safely remove it from your scripts."""

    part_number: Optional[str] = None

    batch_number: Optional[str] = None

    revision: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["part_name", "part_number", "batch_number", "revision"]
        nullable_fields = ["part_name"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RunCreateSubUnitTypedDict(TypedDict):
    serial_number: str


class RunCreateSubUnit(BaseModel):
    serial_number: str


class Outcome(str, Enum):
    RUNNING = "RUNNING"
    PASS = "PASS"
    FAIL = "FAIL"
    ERROR = "ERROR"
    TIMEOUT = "TIMEOUT"
    ABORTED = "ABORTED"


class Level(str, Enum):
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARNING = "WARNING"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"


class LogTypedDict(TypedDict):
    level: Level
    timestamp: datetime
    message: str
    source_file: str
    line_number: float


class Log(BaseModel):
    level: Level

    timestamp: datetime

    message: str

    source_file: str

    line_number: float


class PhaseOutcome(str, Enum):
    PASS = "PASS"
    FAIL = "FAIL"
    SKIP = "SKIP"
    ERROR = "ERROR"


class MeasurementOutcome(str, Enum):
    PASS = "PASS"
    FAIL = "FAIL"
    UNSET = "UNSET"


MeasuredValue2TypedDict = TypeAliasType(
    "MeasuredValue2TypedDict", Union[Dict[str, Any], List[Any]]
)


MeasuredValue2 = TypeAliasType("MeasuredValue2", Union[Dict[str, Any], List[Any]])


MeasuredValue1TypedDict = TypeAliasType(
    "MeasuredValue1TypedDict",
    Union[float, str, bool, List[List[float]], MeasuredValue2TypedDict],
)


MeasuredValue1 = TypeAliasType(
    "MeasuredValue1", Union[float, str, bool, List[List[float]], MeasuredValue2]
)


RunCreateUnitsTypedDict = TypeAliasType(
    "RunCreateUnitsTypedDict", Union[str, List[str]]
)


RunCreateUnits = TypeAliasType("RunCreateUnits", Union[str, List[str]])


class MeasurementTypedDict(TypedDict):
    name: str
    outcome: MeasurementOutcome
    measured_value: NotRequired[Nullable[MeasuredValue1TypedDict]]
    units: NotRequired[Nullable[RunCreateUnitsTypedDict]]
    lower_limit: NotRequired[float]
    upper_limit: NotRequired[float]
    validators: NotRequired[Nullable[List[str]]]
    docstring: NotRequired[Nullable[str]]


class Measurement(BaseModel):
    name: str

    outcome: MeasurementOutcome

    measured_value: OptionalNullable[MeasuredValue1] = UNSET

    units: OptionalNullable[RunCreateUnits] = UNSET

    lower_limit: Optional[float] = None

    upper_limit: Optional[float] = None

    validators: OptionalNullable[List[str]] = UNSET

    docstring: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "measured_value",
            "units",
            "lower_limit",
            "upper_limit",
            "validators",
            "docstring",
        ]
        nullable_fields = ["measured_value", "units", "validators", "docstring"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PhaseTypedDict(TypedDict):
    name: str
    outcome: PhaseOutcome
    start_time_millis: float
    end_time_millis: float
    measurements: NotRequired[Nullable[List[MeasurementTypedDict]]]
    docstring: NotRequired[Nullable[str]]


class Phase(BaseModel):
    name: str

    outcome: PhaseOutcome

    start_time_millis: float

    end_time_millis: float

    measurements: OptionalNullable[List[Measurement]] = UNSET

    docstring: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["measurements", "docstring"]
        nullable_fields = ["measurements", "docstring"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


MeasurementValueTypedDict = TypeAliasType(
    "MeasurementValueTypedDict", Union[float, str]
)


MeasurementValue = TypeAliasType("MeasurementValue", Union[float, str])


class StepTypedDict(TypedDict):
    name: str
    step_passed: bool
    duration: str
    started_at: datetime
    measurement_unit: NotRequired[Nullable[str]]
    measurement_value: NotRequired[Nullable[MeasurementValueTypedDict]]
    str_value: NotRequired[Nullable[str]]
    limit_low: NotRequired[float]
    limit_high: NotRequired[float]


class Step(BaseModel):
    name: str

    step_passed: bool

    duration: str

    started_at: datetime

    measurement_unit: OptionalNullable[str] = UNSET

    measurement_value: OptionalNullable[MeasurementValue] = UNSET

    str_value: OptionalNullable[str] = UNSET

    limit_low: Optional[float] = None

    limit_high: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "measurement_unit",
            "measurement_value",
            "str_value",
            "limit_low",
            "limit_high",
        ]
        nullable_fields = ["measurement_unit", "measurement_value", "str_value"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RunCreateRequestTypedDict(TypedDict):
    unit_under_test: UnitUnderTestTypedDict
    run_passed: bool
    procedure_id: str
    serial_number: NotRequired[str]
    part_number: NotRequired[str]
    batch_number: NotRequired[str]
    revision: NotRequired[str]
    sub_units: NotRequired[List[RunCreateSubUnitTypedDict]]
    outcome: NotRequired[Outcome]
    procedure_version: NotRequired[Nullable[str]]
    started_at: NotRequired[Nullable[datetime]]
    duration: NotRequired[str]
    ended_at: NotRequired[datetime]
    docstring: NotRequired[str]
    logs: NotRequired[List[LogTypedDict]]
    phases: NotRequired[List[PhaseTypedDict]]
    steps: NotRequired[List[StepTypedDict]]
    r"""The `steps` field is deprecated in favor of `phases` and `measurements`, which provide more detailed test logging. Existing `steps` will be auto-converted into a `phase`, with a `measurement` if they include a numeric value."""
    procedure_name: NotRequired[Nullable[str]]


class RunCreateRequest(BaseModel):
    unit_under_test: UnitUnderTest

    run_passed: bool

    procedure_id: str

    serial_number: Optional[str] = None

    part_number: Optional[str] = None

    batch_number: Optional[str] = None

    revision: Optional[str] = None

    sub_units: Optional[List[RunCreateSubUnit]] = None

    outcome: Optional[Outcome] = None

    procedure_version: OptionalNullable[str] = UNSET

    started_at: OptionalNullable[datetime] = UNSET

    duration: Optional[str] = "PT0S"

    ended_at: Optional[datetime] = None

    docstring: Optional[str] = None

    logs: Optional[List[Log]] = None

    phases: Optional[List[Phase]] = None

    steps: Annotated[
        Optional[List[Step]],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""The `steps` field is deprecated in favor of `phases` and `measurements`, which provide more detailed test logging. Existing `steps` will be auto-converted into a `phase`, with a `measurement` if they include a numeric value."""

    procedure_name: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "serial_number",
            "part_number",
            "batch_number",
            "revision",
            "sub_units",
            "outcome",
            "procedure_version",
            "started_at",
            "duration",
            "ended_at",
            "docstring",
            "logs",
            "phases",
            "steps",
            "procedure_name",
        ]
        nullable_fields = ["procedure_version", "started_at", "procedure_name"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RunCreateResponseTypedDict(TypedDict):
    r"""Run created successfully"""

    id: str
    r"""The ID of the created run"""


class RunCreateResponse(BaseModel):
    r"""Run created successfully"""

    id: str
    r"""The ID of the created run"""
