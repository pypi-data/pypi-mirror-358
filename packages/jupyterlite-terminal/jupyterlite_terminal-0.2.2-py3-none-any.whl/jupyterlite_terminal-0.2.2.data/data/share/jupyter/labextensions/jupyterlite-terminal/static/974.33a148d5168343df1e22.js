"use strict";(self.webpackChunk_jupyterlite_terminal=self.webpackChunk_jupyterlite_terminal||[]).push([[974],{1974:(e,t,n)=>{n.r(t),n.d(t,{ILiteTerminalAPIClient:()=>d,default:()=>m});var s=n(186),i=n(6234),r=n(155),a=n(1689),l=n(6196);class o extends l.BaseShell{constructor(e){super(e)}initWorker(e){return console.log("Terminal create webworker"),new Worker(new URL(n.p+n.u(671),n.b),{type:void 0})}}class c{constructor(e={}){var t;this._externalCommands=[],this._shells=new Map,this.serverSettings=null!==(t=e.serverSettings)&&void 0!==t?t:s.ServerConnection.makeSettings(),this._shellManager=new l.ShellManager}set browsingContextId(e){console.log("LiteTerminalAPIClient browsingContextId",e),this._browsingContextId=e}async handleStdin(e){return await this._shellManager.handleStdin(e)}get isAvailable(){return"true"===String(a.PageConfig.getOption("terminalsAvailable")).toLowerCase()}async startNew(e){var t;const n=null!==(t=null==e?void 0:e.name)&&void 0!==t?t:this._nextAvailableName(),{baseUrl:s,wsUrl:i}=this.serverSettings,l=new o({mountpoint:"/drive",baseUrl:s,wasmBaseUrl:a.URLExt.join(s,"extensions/@jupyterlite/terminal/static/wasm/"),browsingContextId:this._browsingContextId,aliases:this._aliases,environment:this._environment,externalCommands:this._externalCommands,shellId:n,shellManager:this._shellManager,outputCallback:e=>{var t;const n=JSON.stringify(["stdout",e]);null===(t=l.socket)||void 0===t||t.send(n)}});this._shells.set(n,l);const c=a.URLExt.join(i,"terminals","websocket",n),d=new r.Server(c);return d.on("connection",(e=>{(async(e,t)=>{e.socket=t,t.on("message",(async t=>{const n=JSON.parse(t),s=n[0],i=n.slice(1);if(await e.ready,"stdin"===s)await e.input(i[0]);else if("set_size"===s){const t=i[0],n=i[1];await e.setSize(t,n)}}));const n=JSON.stringify(["setup"]);console.log("Terminal returning handshake via socket"),t.send(n),e.start()})(l,e)})),l.disposed.connect((()=>{this.shutdown(n),d.close()})),{name:n}}async listRunning(){return this._models}registerAlias(e,t){void 0===this._aliases&&(this._aliases={}),this._aliases[e]=t}registerEnvironmentVariable(e,t){void 0===this._environment&&(this._environment={}),this._environment[e]=t}registerExternalCommand(e){this._externalCommands.push(e)}async shutdown(e){var t,n;const s=this._shells.get(e);void 0!==s&&(null===(t=s.socket)||void 0===t||t.send(JSON.stringify(["disconnect"])),null===(n=s.socket)||void 0===n||n.close(),this._shells.delete(e),s.dispose())}get _models(){return Array.from(this._shells.keys(),(e=>({name:e})))}_nextAvailableName(){for(let e=1;;++e){const t=`${e}`;if(!this._shells.has(t))return t}}}const d=new(n(7262).Token)("@jupyterlite/terminal:client"),m=[{id:"@jupyterlite/terminal:client",description:"The client for Lite terminals",autoStart:!0,provides:d,optional:[s.IServerSettings],activate:(e,t)=>new c({serverSettings:{...s.ServerConnection.makeSettings(),...t,WebSocket:r.WebSocket}})},{id:"@jupyterlite/terminal:manager",description:"A JupyterLite extension providing a custom terminal manager",autoStart:!0,provides:s.ITerminalManager,requires:[d],activate:(e,t)=>(console.log("JupyterLite extension @jupyterlite/terminal:manager activated"),new s.TerminalManager({terminalAPIClient:t,serverSettings:t.serverSettings}))},{id:"@jupyterlite/terminal:service-worker",autoStart:!0,requires:[d],optional:[i.IServiceWorkerManager],activate:(e,t,n)=>{void 0!==n?(t.browsingContextId=n.browsingContextId,n.registerStdinHandler("terminal",t.handleStdin.bind(t))):console.warn("Service worker is not available for terminals")}}]}}]);