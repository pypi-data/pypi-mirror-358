"""{{ spec.display_name }} platform implementation.

Auto-generated by AetherPost PDK on {{ generation_timestamp }}
Platform: {{ spec.name }}
Features: {{ spec.features.enabled_features | join(', ') if spec.features else 'basic' }}
"""

import asyncio
import aiohttp
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime

from ...core.base_platform import BasePlatform, PlatformResult, Content, Profile, ContentType, PlatformCapability
from ...core.authentication import {% if spec.authentication %}{{ spec.authentication.type | pascal_case }}Authenticator{% else %}ApiKeyAuthenticator{% endif %}
from ...core.error_handling.exceptions import (
    AuthenticationError,
    PostingError,
    RateLimitError,
    ContentValidationError,
    MediaUploadError,
    ProfileUpdateError,
    NetworkError
)

logger = logging.getLogger(__name__)


class {{ class_name }}(BasePlatform):
    {{ format_docstring(spec.description) }}
    
    def __init__(
        self,
        credentials: Dict[str, str],
        config: Optional[Dict[str, Any]] = None,
        **kwargs
    ):
        super().__init__(credentials, config, **kwargs)
        
        # Platform configuration
        self.base_url = "{{ spec.api_base_url }}"
        self.api_version = "{{ spec.api_version }}"
        
        # Session management
        self._session: Optional[aiohttp.ClientSession] = None
    
    # Required property implementations
    @property
    def platform_name(self) -> str:
        """Platform identifier."""
        return "{{ spec.name }}"
    
    @property
    def platform_display_name(self) -> str:
        """Human-readable platform name."""
        return "{{ spec.display_name }}"
    
    @property
    def supported_content_types(self) -> List[ContentType]:
        """Supported content types for this platform."""
        return [
            {% for content_type in spec.supported_content_types -%}
            ContentType.{{ content_type.upper() }},
            {% endfor %}
        ]
    
    @property
    def supported_media_types(self) -> List[str]:
        """Supported media MIME types."""
        return [
            {% for media_type in spec.supported_media_types -%}
            "{{ media_type }}",
            {% endfor %}
        ]
    
    @property
    def platform_capabilities(self) -> List[PlatformCapability]:
        """Platform capabilities."""
        return [
            {% if spec.features -%}
            {% if spec.features.content_posting -%}
            PlatformCapability.POSTING,
            {% endif -%}
            {% if spec.features.media_upload -%}
            PlatformCapability.MEDIA_UPLOAD,
            {% endif -%}
            {% if spec.features.profile_management -%}
            PlatformCapability.PROFILE_MANAGEMENT,
            {% endif -%}
            {% if spec.features.analytics -%}
            PlatformCapability.ANALYTICS,
            {% endif -%}
            {% if spec.features.direct_messaging -%}
            PlatformCapability.DIRECT_MESSAGING,
            {% endif -%}
            {% if spec.features.stories -%}
            PlatformCapability.STORIES,
            {% endif -%}
            {% if spec.features.threads -%}
            PlatformCapability.THREADS,
            {% endif -%}
            {% if spec.features.scheduling -%}
            PlatformCapability.SCHEDULING,
            {% endif -%}
            {% else -%}
            PlatformCapability.POSTING,
            {% endif %}
        ]
    
    @property
    def character_limit(self) -> int:
        """Character limit for text posts."""
        return {{ spec.character_limit }}
    
    # Required method implementations
    def _setup_authenticator(self):
        """Setup platform-specific authenticator."""
        {% if spec.authentication %}
        auth_config = {
            {% if spec.authentication.type == 'oauth2' -%}
            'authorization_endpoint': "{{ spec.authentication.endpoints.get('authorization', '/oauth/authorize') }}",
            'token_endpoint': "{{ spec.authentication.endpoints.get('token', '/oauth/token') }}",
            'refresh_endpoint': "{{ spec.authentication.endpoints.get('refresh', '/oauth/refresh') }}",
            'scopes': {{ spec.authentication.scopes | json_safe }},
            {% elif spec.authentication.type == 'jwt' -%}
            'login_endpoint': "{{ spec.authentication.endpoints.get('login', '/auth/login') }}",
            'refresh_endpoint': "{{ spec.authentication.endpoints.get('refresh', '/auth/refresh') }}",
            'verify_endpoint': "{{ spec.authentication.endpoints.get('verify', '/auth/verify') }}",
            {% elif spec.authentication.type == 'api_key' -%}
            'verify_endpoint': "{{ spec.authentication.endpoints.get('verify', '/auth/verify') if spec.authentication.endpoints.get('verify') else None }}",
            'key_header': 'Authorization',
            'key_prefix': 'Bearer',
            {% endif -%}
        }
        
        self.authenticator = {{ spec.authentication.type | pascal_case }}Authenticator(
            credentials=self.credentials,
            platform=self.platform_name,
            base_url=self.base_url,
            auth_config=auth_config
        )
        {% else %}
        # Default to API key authentication
        self.authenticator = ApiKeyAuthenticator(
            credentials=self.credentials,
            platform=self.platform_name,
            base_url=self.base_url
        )
        {% endif %}
    
    async def _post_content_impl(self, content: Content) -> PlatformResult:
        """Platform-specific content posting implementation."""
        try:
            # Prepare request data
            post_data = await self._prepare_post_data(content)
            
            # Determine endpoint based on content type
            endpoint = self._get_post_endpoint(content.content_type)
            
            # Make API request
            async with self._get_session() as session:
                headers = self._get_authenticated_headers()
                
                async with session.{{ filter_endpoints(spec.api_endpoints, 'posts').values() | first | http_method | lower if filter_endpoints(spec.api_endpoints, 'posts') else 'post' }}(
                    f"{self.base_url}{endpoint}",
                    json=post_data,
                    headers=headers
                ) as response:
                    
                    response_data = await response.json()
                    
                    if response.status in [200, 201]:
                        return self._parse_post_response(response_data, content)
                    else:
                        return self._handle_api_error(response, response_data, 'post_content')
            
        except Exception as e:
            logger.error(f"Failed to post content to {{ spec.display_name }}: {e}")
            return PlatformResult(
                success=False,
                platform=self.platform_name,
                action="post_content",
                error_message=str(e)
            )
    
    async def _update_profile_impl(self, profile: Profile) -> PlatformResult:
        """Platform-specific profile update implementation."""
        {% if spec.features and spec.features.profile_management %}
        try:
            # Prepare profile data
            profile_data = await self._prepare_profile_data(profile)
            
            # Update profile
            async with self._get_session() as session:
                headers = self._get_authenticated_headers()
                
                endpoint = "{{ filter_endpoints(spec.api_endpoints, 'profile').get('profile_update', '/profile') | endpoint_path if filter_endpoints(spec.api_endpoints, 'profile') else '/profile' }}"
                
                async with session.{{ filter_endpoints(spec.api_endpoints, 'profile').get('profile_update', 'PUT /profile') | http_method | lower if filter_endpoints(spec.api_endpoints, 'profile') else 'put' }}(
                    f"{self.base_url}{endpoint}",
                    json=profile_data,
                    headers=headers
                ) as response:
                    
                    response_data = await response.json()
                    
                    if response.status == 200:
                        return PlatformResult(
                            success=True,
                            platform=self.platform_name,
                            action="update_profile",
                            profile_updated=True,
                            raw_data=response_data
                        )
                    else:
                        return self._handle_api_error(response, response_data, 'update_profile')
            
        except Exception as e:
            logger.error(f"Failed to update profile on {{ spec.display_name }}: {e}")
            return PlatformResult(
                success=False,
                platform=self.platform_name,
                action="update_profile",
                error_message=str(e)
            )
        {% else %}
        # Profile management not supported
        return PlatformResult(
            success=False,
            platform=self.platform_name,
            action="update_profile",
            error_message="Profile management not supported by this platform"
        )
        {% endif %}
    
    async def _delete_post_impl(self, post_id: str) -> PlatformResult:
        """Platform-specific post deletion implementation."""
        try:
            endpoint = "{{ filter_endpoints(spec.api_endpoints, 'posts').get('posts_delete', '/posts/{id}') | endpoint_path if filter_endpoints(spec.api_endpoints, 'posts') else '/posts/{id}' }}".format(id=post_id)
            
            async with self._get_session() as session:
                headers = self._get_authenticated_headers()
                
                async with session.{{ filter_endpoints(spec.api_endpoints, 'posts').get('posts_delete', 'DELETE /posts/{id}') | http_method | lower if filter_endpoints(spec.api_endpoints, 'posts') else 'delete' }}(
                    f"{self.base_url}{endpoint}",
                    headers=headers
                ) as response:
                    
                    if response.status in [200, 204]:
                        return PlatformResult(
                            success=True,
                            platform=self.platform_name,
                            action="delete_post",
                            post_id=post_id
                        )
                    else:
                        response_data = await response.json()
                        return self._handle_api_error(response, response_data, 'delete_post')
            
        except Exception as e:
            logger.error(f"Failed to delete post {post_id} from {{ spec.display_name }}: {e}")
            return PlatformResult(
                success=False,
                platform=self.platform_name,
                action="delete_post",
                post_id=post_id,
                error_message=str(e)
            )
    
    # Helper methods
    async def _prepare_post_data(self, content: Content) -> Dict[str, Any]:
        """Prepare post data for API request."""
        data = {
            'text': content.text
        }
        
        # Add content type specific data
        if content.content_type == ContentType.THREAD and content.thread_posts:
            data['thread'] = content.thread_posts
        
        # Add media if present
        if content.media:
            {% if spec.features and spec.features.media_upload %}
            media_ids = await self._upload_media(content.media)
            data['media_ids'] = media_ids
            {% else %}
            logger.warning("Media upload not supported, skipping media attachments")
            {% endif %}
        
        # Add hashtags
        if content.hashtags:
            # Combine hashtags with text or add as separate field based on platform
            hashtag_text = ' ' + ' '.join(f'#{tag.lstrip("#")}' for tag in content.hashtags)
            data['text'] += hashtag_text
        
        return data
    
    {% if spec.features and spec.features.profile_management %}
    async def _prepare_profile_data(self, profile: Profile) -> Dict[str, Any]:
        """Prepare profile data for API request."""
        data = {}
        
        if profile.display_name:
            data['display_name'] = profile.display_name
        
        if profile.bio:
            data['bio'] = profile.bio
        
        if profile.website_url:
            data['website_url'] = profile.website_url
        
        if profile.location:
            data['location'] = profile.location
        
        # Handle avatar upload if provided
        if profile.avatar_path:
            {% if spec.features.media_upload %}
            avatar_data = await self._upload_avatar(profile.avatar_path)
            if avatar_data:
                data['avatar'] = avatar_data
            {% else %}
            logger.warning("Media upload not supported, skipping avatar")
            {% endif %}
        
        return data
    {% endif %}
    
    {% if spec.features and spec.features.media_upload %}
    async def _upload_media(self, media_files: List[Any]) -> List[str]:
        """Upload media files and return media IDs."""
        media_ids = []
        
        for media_file in media_files:
            try:
                media_id = await self._upload_single_media(media_file)
                if media_id:
                    media_ids.append(media_id)
            except Exception as e:
                logger.error(f"Failed to upload media file: {e}")
        
        return media_ids
    
    async def _upload_single_media(self, media_file) -> Optional[str]:
        """Upload a single media file."""
        endpoint = "{{ filter_endpoints(spec.api_endpoints, 'media').get('media_upload', '/media/upload') | endpoint_path if filter_endpoints(spec.api_endpoints, 'media') else '/media/upload' }}"
        
        async with self._get_session() as session:
            headers = self._get_authenticated_headers()
            
            # Prepare form data
            data = aiohttp.FormData()
            data.add_field('file', open(media_file.file_path, 'rb'))
            
            async with session.post(
                f"{self.base_url}{endpoint}",
                data=data,
                headers=headers
            ) as response:
                
                if response.status == 200:
                    response_data = await response.json()
                    return response_data.get('media_id') or response_data.get('id')
                else:
                    logger.error(f"Media upload failed: {response.status}")
                    return None
    
    async def _upload_avatar(self, avatar_path: str) -> Optional[Dict[str, Any]]:
        """Upload avatar image."""
        endpoint = "{{ filter_endpoints(spec.api_endpoints, 'profile').get('profile_avatar', '/profile/avatar') | endpoint_path if filter_endpoints(spec.api_endpoints, 'profile') else '/profile/avatar' }}"
        
        async with self._get_session() as session:
            headers = self._get_authenticated_headers()
            
            data = aiohttp.FormData()
            data.add_field('avatar', open(avatar_path, 'rb'))
            
            async with session.post(
                f"{self.base_url}{endpoint}",
                data=data,
                headers=headers
            ) as response:
                
                if response.status == 200:
                    return await response.json()
                else:
                    logger.error(f"Avatar upload failed: {response.status}")
                    return None
    {% endif %}
    
    def _get_post_endpoint(self, content_type: ContentType) -> str:
        """Get appropriate endpoint for content type."""
        {% if filter_endpoints(spec.api_endpoints, 'posts') %}
        endpoints = {
            ContentType.TEXT: "{{ filter_endpoints(spec.api_endpoints, 'posts').get('posts_create', '/posts') | endpoint_path }}",
            ContentType.IMAGE: "{{ filter_endpoints(spec.api_endpoints, 'posts').get('posts_create', '/posts') | endpoint_path }}",
            ContentType.VIDEO: "{{ filter_endpoints(spec.api_endpoints, 'posts').get('posts_create', '/posts') | endpoint_path }}",
            ContentType.THREAD: "{{ filter_endpoints(spec.api_endpoints, 'posts').get('posts_thread', filter_endpoints(spec.api_endpoints, 'posts').get('posts_create', '/posts')) | endpoint_path }}",
        }
        return endpoints.get(content_type, "{{ filter_endpoints(spec.api_endpoints, 'posts').get('posts_create', '/posts') | endpoint_path }}")
        {% else %}
        return "/posts"
        {% endif %}
    
    def _get_authenticated_headers(self) -> Dict[str, str]:
        """Get headers with authentication."""
        headers = {
            'Content-Type': 'application/json',
            'User-Agent': f'AetherPost/1.0 ({{ spec.name }})'
        }
        
        if self.authenticator and self._current_session:
            auth_headers = self.authenticator.get_auth_headers(self._current_session)
            headers.update(auth_headers)
        
        return headers
    
    def _parse_post_response(self, response_data: Dict[str, Any], content: Content) -> PlatformResult:
        """Parse successful post response."""
        post_id = response_data.get('id') or response_data.get('post_id')
        post_url = response_data.get('url') or self._construct_post_url(post_id)
        
        return PlatformResult(
            success=True,
            platform=self.platform_name,
            action="post_content",
            post_id=str(post_id) if post_id else None,
            post_url=post_url,
            raw_data=response_data,
            created_at=datetime.utcnow()
        )
    
    def _construct_post_url(self, post_id: str) -> Optional[str]:
        """Construct public URL for a post."""
        if not post_id:
            return None
        
        # Default URL construction - override in subclasses if needed
        base_domain = self.base_url.replace('api.', '').replace('/api', '')
        return f"{base_domain}/posts/{post_id}"
    
    def _handle_api_error(
        self, 
        response, 
        response_data: Dict[str, Any], 
        operation: str
    ) -> PlatformResult:
        """Handle API error responses."""
        error_message = response_data.get('error', {}).get('message') or response_data.get('message', f'HTTP {response.status}')
        error_code = response_data.get('error', {}).get('code') or str(response.status)
        
        return PlatformResult(
            success=False,
            platform=self.platform_name,
            action=operation,
            error_message=error_message,
            error_code=error_code,
            raw_data=response_data
        )
    
    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create HTTP session."""
        if self._session is None or self._session.closed:
            self._session = aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=30)
            )
        return self._session
    
    async def cleanup(self):
        """Cleanup platform resources."""
        await super().cleanup()
        
        if self._session and not self._session.closed:
            await self._session.close()
    
    # Platform-specific validation
    async def _validate_content_platform_specific(self, content: Content) -> Dict[str, Any]:
        """Platform-specific content validation."""
        errors = []
        warnings = []
        
        {% for content_type, content_spec in spec.content_types.items() %}
        # {{ content_type }} validation
        {% if content_spec.max_length %}
        if content.content_type == ContentType.{{ content_type.upper() }} and len(content.text) > {{ content_spec.max_length }}:
            errors.append("{{ content_type }} text exceeds maximum length of {{ content_spec.max_length }} characters")
        {% endif %}
        
        {% if content_spec.max_media %}
        if content.content_type == ContentType.{{ content_type.upper() }} and len(content.media) > {{ content_spec.max_media }}:
            errors.append("{{ content_type }} exceeds maximum media count of {{ content_spec.max_media }}")
        {% endif %}
        {% endfor %}
        
        return {
            'errors': errors,
            'warnings': warnings
        }
    
    {% if spec.features and spec.features.analytics %}
    async def _get_analytics_impl(self, post_id: Optional[str], timeframe: Optional[str]) -> Dict[str, Any]:
        """Get analytics data for posts."""
        try:
            if post_id:
                # Get analytics for specific post
                endpoint = "{{ filter_endpoints(spec.api_endpoints, 'analytics').get('analytics_post', '/analytics/posts/{id}') | endpoint_path if filter_endpoints(spec.api_endpoints, 'analytics') else '/analytics/posts/{id}' }}".format(id=post_id)
            else:
                # Get general analytics
                endpoint = "{{ filter_endpoints(spec.api_endpoints, 'analytics').get('analytics_profile', '/analytics/profile') | endpoint_path if filter_endpoints(spec.api_endpoints, 'analytics') else '/analytics/profile' }}"
            
            async with self._get_session() as session:
                headers = self._get_authenticated_headers()
                
                async with session.get(
                    f"{self.base_url}{endpoint}",
                    headers=headers
                ) as response:
                    
                    if response.status == 200:
                        return await response.json()
                    else:
                        return {
                            'error': f'Analytics request failed: {response.status}',
                            'platform': self.platform_name
                        }
        
        except Exception as e:
            return {
                'error': str(e),
                'platform': self.platform_name
            }
    {% endif %}