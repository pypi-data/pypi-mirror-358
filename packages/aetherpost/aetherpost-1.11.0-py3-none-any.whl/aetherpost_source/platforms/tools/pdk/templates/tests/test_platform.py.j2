"""Tests for {{ spec.display_name }} platform implementation.

Auto-generated by AetherPost PDK on {{ generation_timestamp }}
"""

import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch
from pathlib import Path

from ..{{ module_name }} import {{ class_name }}
from ...core.base_platform import Content, Profile, ContentType, MediaFile


class Test{{ class_name }}:
    """Test suite for {{ class_name }}."""
    
    @pytest.fixture
    def platform(self):
        """Create platform instance for testing."""
        credentials = {
            {% if spec.authentication.type == 'oauth2' -%}
            'client_id': 'test_client_id',
            'client_secret': 'test_client_secret',
            'access_token': 'test_access_token'
            {% elif spec.authentication.type == 'api_key' -%}
            'api_key': 'test_api_key'
            {% elif spec.authentication.type == 'jwt' -%}
            'username': 'test_user',
            'password': 'test_password'
            {% elif spec.authentication.type == 'basic_auth' -%}
            'username': 'test_user',
            'password': 'test_password'
            {% else -%}
            'api_key': 'test_api_key'
            {% endif %}
        }
        return {{ class_name }}(credentials)
    
    def test_platform_properties(self, platform):
        """Test platform property implementations."""
        assert platform.platform_name == "{{ spec.name }}"
        assert platform.platform_display_name == "{{ spec.display_name }}"
        assert platform.character_limit == {{ spec.character_limit }}
        assert isinstance(platform.supported_content_types, list)
        assert isinstance(platform.supported_media_types, list)
        assert isinstance(platform.platform_capabilities, list)
    
    def test_content_type_support(self, platform):
        """Test supported content types."""
        supported_types = platform.supported_content_types
        {% for content_type in spec.supported_content_types -%}
        assert ContentType.{{ content_type.upper() }} in supported_types
        {% endfor %}
    
    def test_media_type_support(self, platform):
        """Test supported media types."""
        supported_media = platform.supported_media_types
        {% for media_type in spec.supported_media_types -%}
        assert "{{ media_type }}" in supported_media
        {% endfor %}
    
    @pytest.mark.asyncio
    async def test_authentication_setup(self, platform):
        """Test authentication setup."""
        # Should not raise exception
        platform._setup_authenticator()
        assert platform.authenticator is not None
        assert platform.authenticator.platform == "{{ spec.name }}"
    
    @pytest.mark.asyncio
    async def test_content_validation(self, platform):
        """Test content validation."""
        # Valid content
        valid_content = Content(
            text="Test post content",
            content_type=ContentType.TEXT
        )
        
        result = await platform.validate_content(valid_content)
        assert result['is_valid'] is True
        assert result['platform'] == "{{ spec.name }}"
        
        # Invalid content (too long)
        invalid_content = Content(
            text="x" * ({{ spec.character_limit }} + 1),
            content_type=ContentType.TEXT
        )
        
        result = await platform.validate_content(invalid_content)
        assert result['is_valid'] is False
        assert len(result['errors']) > 0
    
    @pytest.mark.asyncio
    async def test_post_content_structure(self, platform):
        """Test post content method structure."""
        content = Content(
            text="Test post",
            content_type=ContentType.TEXT
        )
        
        # Mock the implementation method
        platform._post_content_impl = AsyncMock(return_value=Mock(success=True))
        platform._ensure_authenticated = AsyncMock(return_value=True)
        
        # Should call the implementation
        result = await platform.post_content(content)
        platform._post_content_impl.assert_called_once_with(content)
    
    {% if spec.features and spec.features.profile_management %}
    @pytest.mark.asyncio
    async def test_profile_update_structure(self, platform):
        """Test profile update method structure."""
        profile = Profile(
            display_name="Test User",
            bio="Test bio"
        )
        
        # Mock the implementation method
        platform._update_profile_impl = AsyncMock(return_value=Mock(success=True))
        platform._ensure_authenticated = AsyncMock(return_value=True)
        
        # Should call the implementation
        result = await platform.update_profile(profile)
        platform._update_profile_impl.assert_called_once_with(profile)
    {% endif %}
    
    @pytest.mark.asyncio
    async def test_delete_post_structure(self, platform):
        """Test delete post method structure."""
        post_id = "test_post_123"
        
        # Mock the implementation method
        platform._delete_post_impl = AsyncMock(return_value=Mock(success=True))
        platform._ensure_authenticated = AsyncMock(return_value=True)
        
        # Should call the implementation
        result = await platform.delete_post(post_id)
        platform._delete_post_impl.assert_called_once_with(post_id)
    
    def test_endpoint_methods(self, platform):
        """Test endpoint helper methods."""
        # Test get_post_endpoint method
        text_endpoint = platform._get_post_endpoint(ContentType.TEXT)
        assert isinstance(text_endpoint, str)
        assert text_endpoint.startswith('/')
        
        # Test authenticated headers
        headers = platform._get_authenticated_headers()
        assert isinstance(headers, dict)
        assert 'User-Agent' in headers
        assert 'Content-Type' in headers
    
    def test_url_construction(self, platform):
        """Test URL construction methods."""
        post_id = "test_123"
        url = platform._construct_post_url(post_id)
        
        if url:  # Some platforms may not support direct URLs
            assert isinstance(url, str)
            assert post_id in url
    
    @pytest.mark.asyncio
    async def test_session_management(self, platform):
        """Test HTTP session management."""
        session = await platform._get_session()
        assert session is not None
        
        # Test cleanup
        await platform.cleanup()
        # Should not raise exception
    
    {% if spec.features and spec.features.media_upload %}
    @pytest.mark.asyncio
    async def test_media_upload_structure(self, platform):
        """Test media upload method structure."""
        # Create a temporary test file
        test_file = Path("/tmp/test_image.jpg")
        test_file.write_bytes(b"fake image data")
        
        try:
            media_file = MediaFile(
                file_path=str(test_file),
                media_type="image/jpeg",
                file_size=len(b"fake image data")
            )
            
            # Mock the upload method
            platform._upload_single_media = AsyncMock(return_value="media_123")
            
            result = await platform._upload_media([media_file])
            assert isinstance(result, list)
            
        finally:
            # Cleanup
            if test_file.exists():
                test_file.unlink()
    {% endif %}
    
    {% if spec.features and spec.features.analytics %}
    @pytest.mark.asyncio
    async def test_analytics_structure(self, platform):
        """Test analytics method structure."""
        # Mock authentication
        platform._ensure_authenticated = AsyncMock(return_value=True)
        
        # Test get_analytics method
        result = await platform.get_analytics()
        assert isinstance(result, dict)
        assert 'platform' in result or 'error' in result
    {% endif %}
    
    def test_platform_info(self, platform):
        """Test platform info method."""
        info = platform.get_platform_info()
        
        assert isinstance(info, dict)
        assert info['name'] == "{{ spec.name }}"
        assert info['display_name'] == "{{ spec.display_name }}"
        assert 'supported_content_types' in info
        assert 'capabilities' in info
        assert 'character_limit' in info
    
    @pytest.mark.asyncio
    async def test_error_handling(self, platform):
        """Test error handling in platform methods."""
        # Test with invalid content type
        unsupported_content = Content(
            text="Test",
            content_type=ContentType.LIVE  # Assuming this is not supported
        )
        
        result = await platform.validate_content(unsupported_content)
        # Should handle gracefully, not crash
        assert isinstance(result, dict)


# Integration tests with real API calls (optional, requires real credentials)
@pytest.mark.integration
class TestIntegration{{ class_name }}:
    """Integration tests for {{ class_name }} (requires real credentials)."""
    
    @pytest.fixture
    def real_platform(self):
        """Create platform with real credentials (from environment)."""
        import os
        credentials = {
            {% if spec.authentication.type == 'oauth2' -%}
            'client_id': os.getenv('{{ spec.name.upper() }}_CLIENT_ID'),
            'client_secret': os.getenv('{{ spec.name.upper() }}_CLIENT_SECRET'),
            'access_token': os.getenv('{{ spec.name.upper() }}_ACCESS_TOKEN')
            {% elif spec.authentication.type == 'api_key' -%}
            'api_key': os.getenv('{{ spec.name.upper() }}_API_KEY')
            {% elif spec.authentication.type == 'jwt' -%}
            'username': os.getenv('{{ spec.name.upper() }}_USERNAME'),
            'password': os.getenv('{{ spec.name.upper() }}_PASSWORD')
            {% elif spec.authentication.type == 'basic_auth' -%}
            'username': os.getenv('{{ spec.name.upper() }}_USERNAME'),
            'password': os.getenv('{{ spec.name.upper() }}_PASSWORD')
            {% else -%}
            'api_key': os.getenv('{{ spec.name.upper() }}_API_KEY')
            {% endif %}
        }
        
        # Skip if credentials not available
        if not all(credentials.values()):
            pytest.skip("Real {{ spec.display_name }} credentials not available")
        
        return {{ class_name }}(credentials)
    
    @pytest.mark.asyncio
    async def test_real_authentication(self, real_platform):
        """Test authentication with real credentials."""
        result = await real_platform.authenticate()
        assert result is True
    
    @pytest.mark.asyncio
    async def test_real_post_and_delete(self, real_platform):
        """Test posting and deleting with real API."""
        # Authenticate first
        await real_platform.authenticate()
        
        # Create test content
        content = Content(
            text="Test post from AetherPost PDK integration test",
            content_type=ContentType.TEXT
        )
        
        # Post content
        post_result = await real_platform.post_content(content)
        assert post_result.success is True
        assert post_result.post_id is not None
        
        # Delete the test post
        delete_result = await real_platform.delete_post(post_result.post_id)
        assert delete_result.success is True