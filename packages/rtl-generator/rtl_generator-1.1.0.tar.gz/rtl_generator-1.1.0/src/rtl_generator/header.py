"""
Instantiate/detect the header(s) used by the generator
"""

import re
from abc import ABC, ABCMeta
from dataclasses import dataclass, field
from typing import Self, Optional

import rapidfuzz.fuzz as fuzz

from .languages import Language
from .format import get_pretty_name


@dataclass
class Header(ABC):
    """
    Base class to add/find/remove a specific header
    """
    name_str: str
    header_str: str
    header_match: re.Pattern | int = field(default=80)

    def __post_init__(self) -> Self:
        assert self.find_header(self.header_str), f"{get_pretty_name(self.name_str)} Header string isn't matched"
        return self

    def find_header(self, rtl: str, lang: Optional[Language]=None, **kwargs) -> Optional[re.Match]:
        """
        Find the header within the RTL, if it exists.
        
        Returns `re.Match` if found, otherwise `None`
        """
        if isinstance(self.header_match, int):
            header_str = self.fill_str(self.header_str, lang=lang, **kwargs)
            if fuzz.partial_ratio(rtl, header_str) >= self.header_match:
                alignment = fuzz.partial_ratio_alignment(rtl, header_str)
                match_str = rtl[alignment.src_start:alignment.src_end]
                return re.search(re.escape(match_str), rtl, re.DOTALL | re.MULTILINE)
            else:
                return None
        else:
            return re.search(self.header_match, rtl)

    def add_header(self, rtl: str, lang: Language, **kwargs) -> str:
        """
        Add the header to the rtl if it doesn't exist.
        """
        if self.find_header(rtl, lang, **kwargs):
            return rtl
        
        return self.fill_str(self.header_str, lang=lang, **kwargs) + f"\n\n{rtl}"

    def remove_header(self, rtl: str, lang: Language, **kwargs) -> str:
        """
        Remove the header from the rtl if it does exist.
    
        """
        header_match = self.find_header(rtl, lang, **kwargs)
        if not header_match:
            return rtl
        
        start = header_match.start()
        start = max(0, rtl.rfind("\n", 0, start))
        start = rtl[:start].strip()
        end = header_match.end()
        end = rtl.find("\n", end)
        end = rtl[end:].strip()

        return f"{start}\n{end}".strip()

    @staticmethod
    def fill_str(in_str: str, lang: Optional[Language] = None, **kwargs) -> str:
        comment_start = lambda **kwargs: lang.single_line_comment(**kwargs) if lang else "//"
        callable_funcs = ["comment_start"] + (list(filter(lambda f: callable(getattr(lang, f, None)), dir(lang))) if lang else [])
        callable_regex = re.compile("|".join(map(lambda f: f"({re.escape(f)})", callable_funcs)), re.MULTILINE | re.DOTALL)
        
        out_str = in_str[:]
        while m := callable_regex.search(out_str):
            func_name = m.group()
            if lang and hasattr(lang, func_name):
                f = getattr(lang, func_name)
            else:
                f = vars()[func_name]
            
            out_str = out_str.replace(func_name, f())

        return out_str


@dataclass
class Generator_Header(Header):
    name_str: str = "generator"
    header_str: str = "comment_start! This file generated by [rtl-generator](https://github.com/burnettlab/rtl-generator.git), written by Brandon Hippe"


@dataclass
class Param_Table_Header(Header):
    name_str: str = "parameter_table"
    header_str: str = "comment_start #{(param_table)}\ncomment_start PARAMETER TABLE GOES HERE\ncomment_start #{/(param_table)}"
    header_match: re.Pattern = re.compile(r"#{\(param_table\)}.*#{/\(param_table\)}", re.DOTALL | re.MULTILINE)


@dataclass
class Included_Modules_Header(Header):
    name_str: str = "included_modules"
    header_str: str = "comment_start #{(included_modules)}\ncomment_start INCLUDED MODULES GO HERE\ncomment_start #{/(included_modules)}"
    header_match: re.Pattern = re.compile(r"#{\(included_modules\)}.*#{/\(included_modules\)}", re.DOTALL | re.MULTILINE)


HEADER_ORDER = [
    Generator_Header,
    Param_Table_Header,
    Included_Modules_Header,
]


def add_headers(rtl: str, lang: Language, **kwargs) -> str:
    """
    Adds headers to the generated RTL.

    To prevent a header from being added, pass the header's name as a keyword argument with a value of False.
    """
    for header_class in sorted(filter(lambda c: isinstance(c, ABCMeta) and issubclass(c, Header) and c != Header and kwargs.get(c.name_str, True), globals().values()), key=lambda c: (HEADER_ORDER.index(c) if c in HEADER_ORDER else float('inf'), c.name_str), reverse=True):
        rtl = header_class().add_header(rtl, lang, **kwargs)

    return rtl

    # comment_start = lang.single_line_comment()
    # init_msg = f"{comment_start}! This file generated by [rtl-generator](https://github.com/burnettlab/rtl-generator.git), written by Brandon Hippe"

    # if fuzz.partial_ratio(init_msg, rtl) < 80:
    #     if not re.search(r"#{\(param_table\)}.*#{/\(param_table\)}", rtl, re.DOTALL | re.MULTILINE):
    #         init_msg += "\n\n" + comment_start + " #{(param_table)}"
    #         init_msg += f"\n{comment_start} PARAMETER TABLE GOES HERE"
    #         init_msg += "\n" + comment_start + " #{/(param_table)}"

    #     if not re.search(r"#{\(included_modules\)}.*#{/\(included_modules\)}", rtl, re.DOTALL | re.MULTILINE):
    #         init_msg += "\n\n" + comment_start + " #{(included_modules)}"
    #         init_msg += f"\n{comment_start} INCLUDED MODULES GO HERE"
    #         init_msg += "\n" + comment_start + " #{/(included_modules)}"

    #     rtl = f"{init_msg}\n\n{rtl.strip()}"

    # return rtl

def remove_headers(rtl: str, lang: Language, **kwargs) -> str:
    """
    Removes headers from the RTL. By default, removes all headers.
    
    In order to preserve a header, pass the header's name as a keyword argument with a value of False.
    """
    for header_class in filter(lambda c: isinstance(c, ABCMeta) and issubclass(c, Header) and c != Header and kwargs.get(c.name_str, True), globals().values()):
        rtl = header_class().remove_header(rtl, lang, **kwargs)

    return rtl
