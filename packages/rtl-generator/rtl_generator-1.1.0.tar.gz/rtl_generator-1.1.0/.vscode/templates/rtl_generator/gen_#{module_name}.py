#!/usr/bin/env python3
f''' 
Generate {" ".join("#{module_name}".split("_")).title()} RTL code
'''

# Necessary imports, path setup, and global variables
from pathlib import Path
import argparse
import builtins
import re
import sys
import os
import prettytable
import yaml
from typing import List
from importlib import import_module

top_path = Path(__file__).resolve().parent

# User-defined imports, functions, and globals


#####################################################################################################
# Base methods needed for all RTL generators                                                        #
#####################################################################################################
def indent_line(line: str, spaces: dict[str: int]={'indent_amt': 0}) -> str:
    '''
    Automatically indent lines in the generated RTL code

    Uses the spaces dictionary to keep track of the current indentation level [key: 'indent_amt']
    '''
    if line.strip().startswith('end'):
        assert spaces['indent_amt'] >= 4, "Indentation error: indent_amt should be >= 4"
        spaces['indent_amt'] -= 4

    return_line = " " * spaces['indent_amt'] + line + ('\n' if line[-1] != '\n' else '')

    if line.strip().endswith('begin'):
        spaces['indent_amt'] += 4

    return return_line


def replace_includes(pretty_rtl_name: str, generated_rtl: str, submod_rtls: dict[str: str]) -> str:
    '''
    Recursively replaces include statements in the generated RTL code with the contents of the included file

    If an included file exists in generated RTL, includes generated RTL for that file
    Otherwise, includes the contents of the existing file
    '''
    while True:
        match = re.search(r"`include \"(.+?)\"", generated_rtl)
        if match is None:
            break

        generated_rtl = generated_rtl.replace(match.group(0), "")
        include_file = match.group(1)
        submod_name = include_file.split('/')[-1].replace('.#{rtl_ext}', '')

        if f"{submod_name}.gen_{submod_name}" in submod_rtls:
            include_rtl = submod_rtls[f"{submod_name}.gen_{submod_name}"]
        else:
            with open(include_file, "r") as f:
                include_rtl = f.read()
        
            pdir = os.getcwd()
            os.chdir(Path(include_file).parent)
            include_rtl = replace_includes(pretty_rtl_name, include_rtl, submod_rtls)
            os.chdir(pdir)
        
        generated_rtl += f"\n{include_rtl}"
        print(f"Included {submod_name} in {pretty_rtl_name}")

    return generated_rtl


def get_arguments(existing_vars: dict, arglist: List[str]) -> None:
    '''
    Get the value of an argument if it exists
    '''
    args = existing_vars['args']
    used_args = existing_vars['used_args']
    for arg in arglist:
        if hasattr(args, arg):
            existing_vars[arg] = getattr(args, arg)
            used_args.add(arg)


def fill_in_template(template: str, args: argparse.Namespace | None, scope: dict) -> str:
    '''
    Fill in the template with the arguments and variables
    Matches using the regex pattern "#{\((\\w+?)\)}"
    Looks for the key in the arguments, variables, and global functions, in that order
    '''
    if 'args' not in scope:
        scope['args'] = args

    if 'used_args' not in scope:
        scope['used_args'] = set()

    while True:
        match = re.search(r"#{\((\w+?)\)}", template)
        if match is None:
            break
            
        start, end = match.span()
        indent_amt = start - template.rfind('\n', 0, start) - 1

        get_arguments(scope, [match.group(1)])
        if match.group(1) in scope:
            # Key is a variable or function in this file
            if callable(scope[match.group(1)]):
                replace_with = scope[match.group(1)](scope)
            else:
                replace_with = str(scope[match.group(1)])
        else:
            # This will raise an error if the key is not a defined variable or a function in the global scope
            try:
                if callable(globals()[match.group(1)]):
                    replace_with = globals()[match.group(1)](scope)
                else:
                    replace_with = str(globals()[match.group(1)])
            except KeyError:
                raise KeyError(f"{match.group(1)} is not a variable in args or a function in this file")

        if replace_with.count('\n') > 0:
            replace_with = replace_with.replace('\n', '\n' + " " * indent_amt)
        template = template[:start] + replace_with + template[end:]

    return template


def rtl_generator(rtl_name: str, pretty_rtl_name: str, args: argparse.Namespace, scope: dict, include_output_filename: bool=True) -> str:
    f''' 
    Generate RTL code
    '''
    init_msg = f"/*\n\tThis file is generated by {rtl_name}_gen.py script written by Brandon Hippe\n\tArguments:\n"
    print(f"RTL generator for {pretty_rtl_name}")

    with open(f"template_{rtl_name}.#{rtl_ext}", "r", encoding='UTF-8') as f:
        template = f.read()

    used_args = set()
    if include_output_filename:
        used_args.add(f"{rtl_name}_output")
    scope['used_args'] = used_args
    generated = fill_in_template(template, args, scope)

    print("Arguments:")
    arg_table = prettytable.PrettyTable()
    arg_table.field_names = ["Argument", "Value"]
    for arg, value in [(a, vars(args)[a]) for a in used_args if a != f"{rtl_name}_output" or include_output_filename]:
        arg_table.add_row([arg, value])

    print(arg_table)
    arg_table = arg_table.get_string().split('\n')
    init_msg += '\n'.join([("\t" + line) for line in arg_table]) + "\n*/\n\n"

    return init_msg + generated


def generator_generator(folder: str, folder_path: Path, rtl_ext: str) -> None:
    '''
    Discover and generate new submodule generators
    '''
    generator_file_name = f"gen_{folder}.py"

    # Check if generator already exists
    if os.path.exists(os.path.join(folder_path, generator_file_name)):
        return
        
    parent_module = f"gen_{'#{module_name}' if Path(folder_path).resolve().parent == top_path else str(Path(folder_path).parent).split(os.sep)[-1]}"
    generator_template = [
        "#!/usr/bin/env python3",
        "f'''",
        "Generate {\" \".join(\"#{(folder)}\".split(\"_\")).title()} RTL code",
        "'''",
        "",
        "# Necessary imports, path setup, and global variables",
        "from pathlib import Path",
        "import sys",
        "import os",
        "",
        "sys.path.append(str(Path(__file__).resolve().parent))",
        "sys.path.append(str(Path(__file__).resolve().parent.parent))",
        f"from {parent_module} import *",
        "",
        "",
        "# User-defined imports, functions, and globals",
        "",
        "",
        "if __name__ == '__main__':",
        "    main(__file__.split(os.sep)[-1].replace(\".py\", \"\").replace(\"gen_\", \"\"), \" \".join(__file__.split(os.sep)[-1].replace(\".py\", \"\").replace(\"gen_\", \"\").split(\"_\")).title(), Path(__file__).resolve().parent)",
        ""
    ]
    
    print(f"Creating new submodule generator for {folder}...")
    if not os.path.exists(os.path.join(folder_path, f"template_{folder}.{rtl_ext}")): 
        if os.path.exists(os.path.join(folder_path, f"{folder}.{rtl_ext}")):
            print(f"Detected {folder}.{rtl_ext}. Copying to template_{folder}.{rtl_ext}...")
            with open(os.path.join(folder_path, f"{folder}.{rtl_ext}"), "r") as f:
                template = f.read()

            with open(os.path.join(folder_path, f"template_{folder}.{rtl_ext}"), "w+") as f:
                f.write(template)
        else:
            print(f"Creating template_{folder}.{rtl_ext}...")
            with open(os.path.join(folder_path, f"template_{folder}.{rtl_ext}"), "w+") as f:
                f.write("")
    
    print(f"Creating {generator_file_name}...")
    with open(os.path.join(folder_path, generator_file_name), "w+") as f:
        f.write(fill_in_template("\n".join(generator_template), None, locals()))

    print(f"Finished creating submodule generator for {folder}")


def add_args(rtl_name: str, pretty_rtl_name: str, proj_path: Path, parser: argparse.ArgumentParser | None = None) -> argparse.ArgumentParser:
    '''
    Add arguments to the parser
    '''
    with open(os.path.join(top_path, "#{module_name}_options.yml"), "r") as f:
        args = yaml.safe_load(f)

    if parser is None:
        parser = argparse.ArgumentParser(description=f"Generate {pretty_rtl_name} RTL code")

        for arg, arg_info in args.items():
            if 'type' in arg_info:
                arg_info['type'] = getattr(builtins, arg_info['type'])
            try:
                parser.add_argument(f"--{arg}", **arg_info)
            except argparse.ArgumentError:
                pass

    parser.add_argument(f"--{rtl_name}_output", type=str, help=f"{pretty_rtl_name} Output file path", default=f"{rtl_name}.#{rtl_ext}")

    for folder in [d for d in os.listdir() if os.path.isdir(d) and not (d == 'sim_build' or re.search(r"__$", d))]:
        folder_path = os.path.join(proj_path, folder)
        generator_generator(folder, folder_path, "#{rtl_ext}") 

        os.chdir(folder_path)
        submod_name = f"{folder}.gen_{folder}"
        import_module(submod_name, submod_name.split('.')[-1])
        sub_mod = sys.modules[submod_name]
        sub_mod.add_args(folder, " ".join(folder.split("_")).title(), folder_path, parser)
        os.chdir(proj_path)
    
    return parser


def main(rtl_name: str, pretty_rtl_name: str, proj_path: str) -> None:
    '''
    Main function to generate RTL code

    Constructs command line arguments, parses them, and generates the RTL code
    '''
    # Construct and parse command line arguments
    args = add_args(rtl_name, pretty_rtl_name, proj_path).parse_args()

    # Generate the RTL code using given arguments
    import_module(f"gen_{rtl_name}")
    calling_module = sys.modules[f"gen_{rtl_name}"]
    generated_rtl = rtl_generator(rtl_name, pretty_rtl_name, args, vars(calling_module)) + "\n"
    
    submod_rtls = {}
    available_submods = [os.path.join(proj_path, d) for d in os.listdir() if os.path.isdir(d) and not (d == 'sim_build' or re.search(r"__$", d))]
    while available_submods:
        submod_path = available_submods.pop()
        name = submod_path.split(os.sep)[-1]
        pretty_name = " ".join(name.split("_")).title()
        submod = sys.modules[f"{name}.gen_{name}"]

        os.chdir(submod_path)
        submod_rtls[name] = submod.rtl_generator(name, pretty_name, args, vars(submod), include_output_filename=not args.replace_includes)
        if not args.replace_includes:
            with open(getattr(args, f"{name}_output"), "w") as f:
                f.write(submod_rtls[name])
                print(f"Generated RTL for {pretty_name} saved to {f.name}")
        os.chdir(proj_path)

        available_submods.extend([os.path.join(submod_path, d) for d in os.listdir(submod_path) if not (d == 'sim_build' or re.search(r"__$", d)) and os.path.isdir(os.path.join(submod_path, d))])

    if args.replace_includes:
        generated_rtl = replace_includes(pretty_rtl_name, generated_rtl, submod_rtls)

    with open(os.path.join(proj_path, getattr(args, f"{rtl_name}_output")), "w") as f:
        f.write(generated_rtl)
        print(f"Generated RTL saved to {f.name}")

    print(f"Finished generating RTL for {pretty_rtl_name}")


if __name__ == '__main__':
    main(__file__.split(os.sep)[-1].replace(".py", "").replace("gen_", ""), " ".join(__file__.split(os.sep)[-1].replace(".py", "").replace("gen_", "").split("_")).title(), Path(__file__).resolve().parent)
