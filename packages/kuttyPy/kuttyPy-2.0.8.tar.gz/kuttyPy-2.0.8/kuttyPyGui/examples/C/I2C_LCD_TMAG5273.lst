
/home/jithin/Documents/CSpark/kuttypy-gui/examples/C/I2C_LCD_TMAG5273:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e4 ea       	ldi	r30, 0xA4	; 164
  68:	fc e0       	ldi	r31, 0x0C	; 12
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a2 37       	cpi	r26, 0x72	; 114
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a2 e7       	ldi	r26, 0x72	; 114
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a7 37       	cpi	r26, 0x77	; 119
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 58 05 	call	0xab0	; 0xab0 <main>
  8a:	0c 94 50 06 	jmp	0xca0	; 0xca0 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <delay_us>:
    while(x)
        --x;
}

void delay_us(uint16_t k) // not correct
{
  92:	cf 93       	push	r28
  94:	df 93       	push	r29
  96:	00 d0       	rcall	.+0      	; 0x98 <delay_us+0x6>
  98:	cd b7       	in	r28, 0x3d	; 61
  9a:	de b7       	in	r29, 0x3e	; 62
    volatile uint16_t x = k;
  9c:	9a 83       	std	Y+2, r25	; 0x02
  9e:	89 83       	std	Y+1, r24	; 0x01
    while(x)
  a0:	89 81       	ldd	r24, Y+1	; 0x01
  a2:	9a 81       	ldd	r25, Y+2	; 0x02
  a4:	89 2b       	or	r24, r25
  a6:	49 f0       	breq	.+18     	; 0xba <delay_us+0x28>
        --x;
  a8:	89 81       	ldd	r24, Y+1	; 0x01
  aa:	9a 81       	ldd	r25, Y+2	; 0x02
  ac:	01 97       	sbiw	r24, 0x01	; 1
  ae:	9a 83       	std	Y+2, r25	; 0x02
  b0:	89 83       	std	Y+1, r24	; 0x01
}

void delay_us(uint16_t k) // not correct
{
    volatile uint16_t x = k;
    while(x)
  b2:	89 81       	ldd	r24, Y+1	; 0x01
  b4:	9a 81       	ldd	r25, Y+2	; 0x02
  b6:	89 2b       	or	r24, r25
  b8:	b9 f7       	brne	.-18     	; 0xa8 <delay_us+0x16>
        --x;
}
  ba:	0f 90       	pop	r0
  bc:	0f 90       	pop	r0
  be:	df 91       	pop	r29
  c0:	cf 91       	pop	r28
  c2:	08 95       	ret

000000c4 <delay>:
  c4:	0c 94 49 00 	jmp	0x92	; 0x92 <delay_us>

000000c8 <delay_100us>:


void delay_100us (uint16_t k)  	 // k* 100 usecs delay, valid only for 8MHz clock
{
  c8:	cf 93       	push	r28
  ca:	df 93       	push	r29
  cc:	00 d0       	rcall	.+0      	; 0xce <delay_100us+0x6>
  ce:	cd b7       	in	r28, 0x3d	; 61
  d0:	de b7       	in	r29, 0x3e	; 62
  volatile uint16_t x;
  while (k--) {x=52; while (x--);}
  d2:	64 e3       	ldi	r22, 0x34	; 52
  d4:	70 e0       	ldi	r23, 0x00	; 0
  d6:	01 97       	sbiw	r24, 0x01	; 1
  d8:	68 f0       	brcs	.+26     	; 0xf4 <delay_100us+0x2c>
  da:	7a 83       	std	Y+2, r23	; 0x02
  dc:	69 83       	std	Y+1, r22	; 0x01
  de:	29 81       	ldd	r18, Y+1	; 0x01
  e0:	3a 81       	ldd	r19, Y+2	; 0x02
  e2:	a9 01       	movw	r20, r18
  e4:	41 50       	subi	r20, 0x01	; 1
  e6:	51 09       	sbc	r21, r1
  e8:	5a 83       	std	Y+2, r21	; 0x02
  ea:	49 83       	std	Y+1, r20	; 0x01
  ec:	23 2b       	or	r18, r19
  ee:	b9 f7       	brne	.-18     	; 0xde <delay_100us+0x16>
  f0:	01 97       	sbiw	r24, 0x01	; 1
  f2:	98 f7       	brcc	.-26     	; 0xda <delay_100us+0x12>
}
  f4:	0f 90       	pop	r0
  f6:	0f 90       	pop	r0
  f8:	df 91       	pop	r29
  fa:	cf 91       	pop	r28
  fc:	08 95       	ret

000000fe <delay_ms>:

void delay_ms (uint16_t k)  // idle for k milliseconds, only for 8MHz clock
    {
  fe:	cf 93       	push	r28
 100:	df 93       	push	r29
 102:	00 d0       	rcall	.+0      	; 0x104 <delay_ms+0x6>
 104:	cd b7       	in	r28, 0x3d	; 61
 106:	de b7       	in	r29, 0x3e	; 62
    volatile uint16_t x;
    while(k--) {x=532; while (x--);}
 108:	64 e1       	ldi	r22, 0x14	; 20
 10a:	72 e0       	ldi	r23, 0x02	; 2
 10c:	01 97       	sbiw	r24, 0x01	; 1
 10e:	68 f0       	brcs	.+26     	; 0x12a <delay_ms+0x2c>
 110:	7a 83       	std	Y+2, r23	; 0x02
 112:	69 83       	std	Y+1, r22	; 0x01
 114:	29 81       	ldd	r18, Y+1	; 0x01
 116:	3a 81       	ldd	r19, Y+2	; 0x02
 118:	a9 01       	movw	r20, r18
 11a:	41 50       	subi	r20, 0x01	; 1
 11c:	51 09       	sbc	r21, r1
 11e:	5a 83       	std	Y+2, r21	; 0x02
 120:	49 83       	std	Y+1, r20	; 0x01
 122:	23 2b       	or	r18, r19
 124:	b9 f7       	brne	.-18     	; 0x114 <delay_ms+0x16>
 126:	01 97       	sbiw	r24, 0x01	; 1
 128:	98 f7       	brcc	.-26     	; 0x110 <delay_ms+0x12>
    }
 12a:	0f 90       	pop	r0
 12c:	0f 90       	pop	r0
 12e:	df 91       	pop	r29
 130:	cf 91       	pop	r28
 132:	08 95       	ret

00000134 <b2a>:
    

// Converts an 8bit integer to 3 digit decimal form.
void b2a(int b, char* a)
{
 134:	fb 01       	movw	r30, r22
uint8_t d1,d2,d3;
char *p = a;

d3 = 0;
while (b >= 100)
 136:	84 36       	cpi	r24, 0x64	; 100
 138:	91 05       	cpc	r25, r1
 13a:	3c f1       	brlt	.+78     	; 0x18a <b2a+0x56>
 13c:	20 e0       	ldi	r18, 0x00	; 0
 13e:	01 c0       	rjmp	.+2      	; 0x142 <b2a+0xe>
       {
	++d3;
 140:	23 2f       	mov	r18, r19
 142:	31 e0       	ldi	r19, 0x01	; 1
 144:	32 0f       	add	r19, r18
	b -= 100;
 146:	84 56       	subi	r24, 0x64	; 100
 148:	91 09       	sbc	r25, r1
{
uint8_t d1,d2,d3;
char *p = a;

d3 = 0;
while (b >= 100)
 14a:	84 36       	cpi	r24, 0x64	; 100
 14c:	91 05       	cpc	r25, r1
 14e:	c4 f7       	brge	.-16     	; 0x140 <b2a+0xc>
       {
	++d3;
	b -= 100;
	}
if (d3) *p++ = d3 + '0';
 150:	33 23       	and	r19, r19
 152:	d9 f0       	breq	.+54     	; 0x18a <b2a+0x56>
 154:	df 01       	movw	r26, r30
 156:	11 96       	adiw	r26, 0x01	; 1
 158:	2f 5c       	subi	r18, 0xCF	; 207
 15a:	20 83       	st	Z, r18

d2 = 0;
while (b >= 10)
 15c:	8a 30       	cpi	r24, 0x0A	; 10
 15e:	91 05       	cpc	r25, r1
 160:	dc f0       	brlt	.+54     	; 0x198 <b2a+0x64>

// Converts an 8bit integer to 3 digit decimal form.
void b2a(int b, char* a)
{
uint8_t d1,d2,d3;
char *p = a;
 162:	20 e0       	ldi	r18, 0x00	; 0
 164:	01 c0       	rjmp	.+2      	; 0x168 <b2a+0x34>
if (d3) *p++ = d3 + '0';

d2 = 0;
while (b >= 10)
       {
	++d2;
 166:	23 2f       	mov	r18, r19
 168:	31 e0       	ldi	r19, 0x01	; 1
 16a:	32 0f       	add	r19, r18
	b -= 10;
 16c:	0a 97       	sbiw	r24, 0x0a	; 10
	b -= 100;
	}
if (d3) *p++ = d3 + '0';

d2 = 0;
while (b >= 10)
 16e:	8a 30       	cpi	r24, 0x0A	; 10
 170:	91 05       	cpc	r25, r1
 172:	cc f7       	brge	.-14     	; 0x166 <b2a+0x32>
 174:	2f 5c       	subi	r18, 0xCF	; 207
       {
	++d2;
	b -= 10;
	}
if (d3 | d2) *p++ = d2 + '0';
 176:	fd 01       	movw	r30, r26
 178:	31 96       	adiw	r30, 0x01	; 1
 17a:	2c 93       	st	X, r18

d1 = 0;
while (b > 0)
 17c:	18 16       	cp	r1, r24
 17e:	19 06       	cpc	r1, r25
 180:	4c f4       	brge	.+18     	; 0x194 <b2a+0x60>
 182:	80 5d       	subi	r24, 0xD0	; 208
       {
	++d1;
	b -= 1;
	}
*p++ =  d1 + '0';
 184:	80 83       	st	Z, r24
*p = '\0';
 186:	11 82       	std	Z+1, r1	; 0x01
}
 188:	08 95       	ret
	b -= 100;
	}
if (d3) *p++ = d3 + '0';

d2 = 0;
while (b >= 10)
 18a:	8a 30       	cpi	r24, 0x0A	; 10
 18c:	91 05       	cpc	r25, r1
 18e:	b4 f3       	brlt	.-20     	; 0x17c <b2a+0x48>

// Converts an 8bit integer to 3 digit decimal form.
void b2a(int b, char* a)
{
uint8_t d1,d2,d3;
char *p = a;
 190:	df 01       	movw	r26, r30
 192:	e7 cf       	rjmp	.-50     	; 0x162 <b2a+0x2e>
	b -= 10;
	}
if (d3 | d2) *p++ = d2 + '0';

d1 = 0;
while (b > 0)
 194:	80 e3       	ldi	r24, 0x30	; 48
 196:	f6 cf       	rjmp	.-20     	; 0x184 <b2a+0x50>
	b -= 100;
	}
if (d3) *p++ = d3 + '0';

d2 = 0;
while (b >= 10)
 198:	20 e3       	ldi	r18, 0x30	; 48
 19a:	ed cf       	rjmp	.-38     	; 0x176 <b2a+0x42>

0000019c <b2aa>:
{
uint8_t d1,d2,d3,d4,d5;
char *p = a;

d5 = 0;
while (b >= 10000)
 19c:	80 31       	cpi	r24, 0x10	; 16
 19e:	27 e2       	ldi	r18, 0x27	; 39
 1a0:	92 07       	cpc	r25, r18
 1a2:	0c f4       	brge	.+2      	; 0x1a6 <b2aa+0xa>
 1a4:	58 c0       	rjmp	.+176    	; 0x256 <b2aa+0xba>
       {
	++d5;
	b -= 10000;
 1a6:	9c 01       	movw	r18, r24
 1a8:	20 51       	subi	r18, 0x10	; 16
 1aa:	37 42       	sbci	r19, 0x27	; 39
{
uint8_t d1,d2,d3,d4,d5;
char *p = a;

d5 = 0;
while (b >= 10000)
 1ac:	20 31       	cpi	r18, 0x10	; 16
 1ae:	47 e2       	ldi	r20, 0x27	; 39
 1b0:	34 07       	cpc	r19, r20
 1b2:	0c f4       	brge	.+2      	; 0x1b6 <b2aa+0x1a>
 1b4:	5e c0       	rjmp	.+188    	; 0x272 <b2aa+0xd6>
       {
	++d5;
	b -= 10000;
 1b6:	20 51       	subi	r18, 0x10	; 16
 1b8:	37 42       	sbci	r19, 0x27	; 39
{
uint8_t d1,d2,d3,d4,d5;
char *p = a;

d5 = 0;
while (b >= 10000)
 1ba:	20 31       	cpi	r18, 0x10	; 16
 1bc:	a7 e2       	ldi	r26, 0x27	; 39
 1be:	3a 07       	cpc	r19, r26
 1c0:	0c f4       	brge	.+2      	; 0x1c4 <b2aa+0x28>
 1c2:	5a c0       	rjmp	.+180    	; 0x278 <b2aa+0xdc>
       {
	++d5;
	b -= 10000;
 1c4:	80 53       	subi	r24, 0x30	; 48
 1c6:	95 47       	sbci	r25, 0x75	; 117
char *p = a;

d5 = 0;
while (b >= 10000)
       {
	++d5;
 1c8:	22 e0       	ldi	r18, 0x02	; 2
	b -= 10000;
	}
if(d5) *p++ = d5 + '0';
 1ca:	fb 01       	movw	r30, r22
 1cc:	31 96       	adiw	r30, 0x01	; 1
 1ce:	2f 5c       	subi	r18, 0xCF	; 207
 1d0:	db 01       	movw	r26, r22
 1d2:	2c 93       	st	X, r18

d4 = 0;
while (b >= 1000)
 1d4:	88 3e       	cpi	r24, 0xE8	; 232
 1d6:	b3 e0       	ldi	r27, 0x03	; 3
 1d8:	9b 07       	cpc	r25, r27
 1da:	0c f4       	brge	.+2      	; 0x1de <b2aa+0x42>
 1dc:	53 c0       	rjmp	.+166    	; 0x284 <b2aa+0xe8>

// Converts an 16bit integer to 5 digit decimal form.
void b2aa(int b, char* a)
{
uint8_t d1,d2,d3,d4,d5;
char *p = a;
 1de:	20 e0       	ldi	r18, 0x00	; 0
 1e0:	01 c0       	rjmp	.+2      	; 0x1e4 <b2aa+0x48>
if(d5) *p++ = d5 + '0';

d4 = 0;
while (b >= 1000)
       {
	++d4;
 1e2:	23 2f       	mov	r18, r19
 1e4:	31 e0       	ldi	r19, 0x01	; 1
 1e6:	32 0f       	add	r19, r18
	b -= 1000;
 1e8:	88 5e       	subi	r24, 0xE8	; 232
 1ea:	93 40       	sbci	r25, 0x03	; 3
	b -= 10000;
	}
if(d5) *p++ = d5 + '0';

d4 = 0;
while (b >= 1000)
 1ec:	88 3e       	cpi	r24, 0xE8	; 232
 1ee:	43 e0       	ldi	r20, 0x03	; 3
 1f0:	94 07       	cpc	r25, r20
 1f2:	bc f7       	brge	.-18     	; 0x1e2 <b2aa+0x46>
 1f4:	2f 5c       	subi	r18, 0xCF	; 207
       {
	++d4;
	b -= 1000;
	}
if (d5 | d4) *p++ = d4 + '0';
 1f6:	bf 01       	movw	r22, r30
 1f8:	6f 5f       	subi	r22, 0xFF	; 255
 1fa:	7f 4f       	sbci	r23, 0xFF	; 255
 1fc:	20 83       	st	Z, r18

	
d3 = 0;
while (b >= 100)
 1fe:	84 36       	cpi	r24, 0x64	; 100
 200:	91 05       	cpc	r25, r1
 202:	ec f1       	brlt	.+122    	; 0x27e <b2aa+0xe2>
	b -= 10000;
	}
if(d5) *p++ = d5 + '0';

d4 = 0;
while (b >= 1000)
 204:	20 e0       	ldi	r18, 0x00	; 0
 206:	01 c0       	rjmp	.+2      	; 0x20a <b2aa+0x6e>

	
d3 = 0;
while (b >= 100)
       {
	++d3;
 208:	23 2f       	mov	r18, r19
 20a:	31 e0       	ldi	r19, 0x01	; 1
 20c:	32 0f       	add	r19, r18
	b -= 100;
 20e:	84 56       	subi	r24, 0x64	; 100
 210:	91 09       	sbc	r25, r1
	}
if (d5 | d4) *p++ = d4 + '0';

	
d3 = 0;
while (b >= 100)
 212:	84 36       	cpi	r24, 0x64	; 100
 214:	91 05       	cpc	r25, r1
 216:	c4 f7       	brge	.-16     	; 0x208 <b2aa+0x6c>
 218:	2f 5c       	subi	r18, 0xCF	; 207
 21a:	fb 01       	movw	r30, r22
       {
	++d3;
	b -= 100;
	}
if (d5 | d4 | d3) *p++ = d3 + '0';
 21c:	6f 5f       	subi	r22, 0xFF	; 255
 21e:	7f 4f       	sbci	r23, 0xFF	; 255
 220:	20 83       	st	Z, r18

d2 = 0;
while (b >= 10)
 222:	8a 30       	cpi	r24, 0x0A	; 10
 224:	91 05       	cpc	r25, r1
 226:	84 f1       	brlt	.+96     	; 0x288 <b2aa+0xec>
	}
if (d5 | d4) *p++ = d4 + '0';

	
d3 = 0;
while (b >= 100)
 228:	20 e0       	ldi	r18, 0x00	; 0
 22a:	01 c0       	rjmp	.+2      	; 0x22e <b2aa+0x92>
if (d5 | d4 | d3) *p++ = d3 + '0';

d2 = 0;
while (b >= 10)
       {
	++d2;
 22c:	23 2f       	mov	r18, r19
 22e:	31 e0       	ldi	r19, 0x01	; 1
 230:	32 0f       	add	r19, r18
	b -= 10;
 232:	0a 97       	sbiw	r24, 0x0a	; 10
	b -= 100;
	}
if (d5 | d4 | d3) *p++ = d3 + '0';

d2 = 0;
while (b >= 10)
 234:	8a 30       	cpi	r24, 0x0A	; 10
 236:	91 05       	cpc	r25, r1
 238:	cc f7       	brge	.-14     	; 0x22c <b2aa+0x90>
 23a:	2f 5c       	subi	r18, 0xCF	; 207
       {
	++d2;
	b -= 10;
	}
if (d5 | d4 | d3 | d2) *p++ = d2 + '0';
 23c:	fb 01       	movw	r30, r22
 23e:	31 96       	adiw	r30, 0x01	; 1
 240:	db 01       	movw	r26, r22
 242:	2c 93       	st	X, r18

d1 = 0;
while (b > 0)
 244:	18 16       	cp	r1, r24
 246:	19 06       	cpc	r1, r25
 248:	24 f4       	brge	.+8      	; 0x252 <b2aa+0xb6>
 24a:	80 5d       	subi	r24, 0xD0	; 208
       {
	++d1;
	b -= 1;
	}
*p++ =  d1 + '0';
 24c:	80 83       	st	Z, r24
*p = '\0';
 24e:	11 82       	std	Z+1, r1	; 0x01
}
 250:	08 95       	ret
	b -= 10;
	}
if (d5 | d4 | d3 | d2) *p++ = d2 + '0';

d1 = 0;
while (b > 0)
 252:	80 e3       	ldi	r24, 0x30	; 48
 254:	fb cf       	rjmp	.-10     	; 0x24c <b2aa+0xb0>
	b -= 10000;
	}
if(d5) *p++ = d5 + '0';

d4 = 0;
while (b >= 1000)
 256:	88 3e       	cpi	r24, 0xE8	; 232
 258:	b3 e0       	ldi	r27, 0x03	; 3
 25a:	9b 07       	cpc	r25, r27
 25c:	14 f0       	brlt	.+4      	; 0x262 <b2aa+0xc6>

// Converts an 16bit integer to 5 digit decimal form.
void b2aa(int b, char* a)
{
uint8_t d1,d2,d3,d4,d5;
char *p = a;
 25e:	fb 01       	movw	r30, r22
 260:	be cf       	rjmp	.-132    	; 0x1de <b2aa+0x42>
	}
if (d5 | d4) *p++ = d4 + '0';

	
d3 = 0;
while (b >= 100)
 262:	84 36       	cpi	r24, 0x64	; 100
 264:	91 05       	cpc	r25, r1
 266:	74 f6       	brge	.-100    	; 0x204 <b2aa+0x68>
	b -= 100;
	}
if (d5 | d4 | d3) *p++ = d3 + '0';

d2 = 0;
while (b >= 10)
 268:	8a 30       	cpi	r24, 0x0A	; 10
 26a:	91 05       	cpc	r25, r1
 26c:	ec f6       	brge	.-70     	; 0x228 <b2aa+0x8c>
 26e:	fb 01       	movw	r30, r22
 270:	e9 cf       	rjmp	.-46     	; 0x244 <b2aa+0xa8>
{
uint8_t d1,d2,d3,d4,d5;
char *p = a;

d5 = 0;
while (b >= 10000)
 272:	c9 01       	movw	r24, r18
 274:	20 e0       	ldi	r18, 0x00	; 0
 276:	a9 cf       	rjmp	.-174    	; 0x1ca <b2aa+0x2e>
 278:	c9 01       	movw	r24, r18
       {
	++d5;
 27a:	21 e0       	ldi	r18, 0x01	; 1
 27c:	a6 cf       	rjmp	.-180    	; 0x1ca <b2aa+0x2e>
while (b >= 1000)
       {
	++d4;
	b -= 1000;
	}
if (d5 | d4) *p++ = d4 + '0';
 27e:	fb 01       	movw	r30, r22

	
d3 = 0;
while (b >= 100)
 280:	20 e3       	ldi	r18, 0x30	; 48
 282:	cc cf       	rjmp	.-104    	; 0x21c <b2aa+0x80>
	b -= 10000;
	}
if(d5) *p++ = d5 + '0';

d4 = 0;
while (b >= 1000)
 284:	20 e3       	ldi	r18, 0x30	; 48
 286:	b7 cf       	rjmp	.-146    	; 0x1f6 <b2aa+0x5a>
	b -= 100;
	}
if (d5 | d4 | d3) *p++ = d3 + '0';

d2 = 0;
while (b >= 10)
 288:	20 e3       	ldi	r18, 0x30	; 48
 28a:	d8 cf       	rjmp	.-80     	; 0x23c <b2aa+0xa0>

0000028c <i2c_init>:
/*************************************************************************
 Initialization of the I2C bus interface. Need to be called only once
*************************************************************************/
void i2c_init(void)
{
TWSR=0x00; TWBR=0x46 ; TWCR=0x04; //Init I2C
 28c:	11 b8       	out	0x01, r1	; 1
 28e:	86 e4       	ldi	r24, 0x46	; 70
 290:	80 b9       	out	0x00, r24	; 0
 292:	84 e0       	ldi	r24, 0x04	; 4
 294:	86 bf       	out	0x36, r24	; 54
PORTC |= 3; //Enable SCL/SDA Pull up	
 296:	85 b3       	in	r24, 0x15	; 21
 298:	83 60       	ori	r24, 0x03	; 3
 29a:	85 bb       	out	0x15, r24	; 21
 29c:	08 95       	ret

0000029e <i2c_scan>:

returns: total addresses found.
*************************************************************************/

uint8_t i2c_scan(uint8_t *data)
{
 29e:	fc 01       	movw	r30, r24
	uint8_t found=0;
	uint16_t timeout=11000;

	DDRC |= 1  ;// SCL as output .
 2a0:	a0 9a       	sbi	0x14, 0	; 20
	PORTC &= ~3; while(timeout--); PORTC |=3; //Pull SCL low. some sensors need this.
 2a2:	85 b3       	in	r24, 0x15	; 21
 2a4:	8c 7f       	andi	r24, 0xFC	; 252
 2a6:	85 bb       	out	0x15, r24	; 21
 2a8:	85 b3       	in	r24, 0x15	; 21
 2aa:	83 60       	ori	r24, 0x03	; 3
 2ac:	85 bb       	out	0x15, r24	; 21
	DDRC &= ~3 ;// SCL as input
 2ae:	84 b3       	in	r24, 0x14	; 20
 2b0:	8c 7f       	andi	r24, 0xFC	; 252
 2b2:	84 bb       	out	0x14, r24	; 20
	PORTC |= 3; //Enable SCL/SDA Pull up	
 2b4:	85 b3       	in	r24, 0x15	; 21
 2b6:	83 60       	ori	r24, 0x03	; 3
 2b8:	85 bb       	out	0x15, r24	; 21
 2ba:	91 e0       	ldi	r25, 0x01	; 1
 2bc:	20 e5       	ldi	r18, 0x50	; 80
 2be:	33 ec       	ldi	r19, 0xC3	; 195
 2c0:	80 e0       	ldi	r24, 0x00	; 0
	timeout=50000;

	for(uint8_t i = 1;i <= 127;i++){
		TWCR = 0xA4;             // send a start bit on i2c bus
 2c2:	74 ea       	ldi	r23, 0xA4	; 164
		while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
		TWDR = i<<1;          // load address of i2c device
		TWCR = 0x84;             // transmit
 2c4:	64 e8       	ldi	r22, 0x84	; 132
		asm("WDR");
		if((TWSR&0xFC) == 0x18){   // SLA+W has been transmitted; ACK has been received
			*(data++) = i;
			found++;
		}		
		TWCR = 0x94;             // stop bit
 2c6:	54 e9       	ldi	r21, 0x94	; 148
	DDRC &= ~3 ;// SCL as input
	PORTC |= 3; //Enable SCL/SDA Pull up	
	timeout=50000;

	for(uint8_t i = 1;i <= 127;i++){
		TWCR = 0xA4;             // send a start bit on i2c bus
 2c8:	76 bf       	out	0x36, r23	; 54
		while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 2ca:	06 b6       	in	r0, 0x36	; 54
 2cc:	07 fe       	sbrs	r0, 7
 2ce:	06 c0       	rjmp	.+12     	; 0x2dc <i2c_scan+0x3e>
 2d0:	1b c0       	rjmp	.+54     	; 0x308 <i2c_scan+0x6a>
 2d2:	21 50       	subi	r18, 0x01	; 1
 2d4:	31 09       	sbc	r19, r1
 2d6:	06 b6       	in	r0, 0x36	; 54
 2d8:	07 fc       	sbrc	r0, 7
 2da:	16 c0       	rjmp	.+44     	; 0x308 <i2c_scan+0x6a>
 2dc:	21 15       	cp	r18, r1
 2de:	31 05       	cpc	r19, r1
 2e0:	c1 f7       	brne	.-16     	; 0x2d2 <i2c_scan+0x34>
		TWDR = i<<1;          // load address of i2c device
 2e2:	29 2f       	mov	r18, r25
 2e4:	22 0f       	add	r18, r18
 2e6:	23 b9       	out	0x03, r18	; 3
		TWCR = 0x84;             // transmit
 2e8:	66 bf       	out	0x36, r22	; 54
		while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 2ea:	06 b6       	in	r0, 0x36	; 54
 2ec:	07 fe       	sbrs	r0, 7
 2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <i2c_scan+0x52>
	uint16_t timeout=11000;

	DDRC |= 1  ;// SCL as output .
	PORTC &= ~3; while(timeout--); PORTC |=3; //Pull SCL low. some sensors need this.
	DDRC &= ~3 ;// SCL as input
	PORTC |= 3; //Enable SCL/SDA Pull up	
 2f0:	20 e0       	ldi	r18, 0x00	; 0
 2f2:	30 e0       	ldi	r19, 0x00	; 0
		TWCR = 0xA4;             // send a start bit on i2c bus
		while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
		TWDR = i<<1;          // load address of i2c device
		TWCR = 0x84;             // transmit
		while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
		asm("WDR");
 2f4:	a8 95       	wdr
		if((TWSR&0xFC) == 0x18){   // SLA+W has been transmitted; ACK has been received
 2f6:	41 b1       	in	r20, 0x01	; 1
 2f8:	4c 7f       	andi	r20, 0xFC	; 252
 2fa:	48 31       	cpi	r20, 0x18	; 24
 2fc:	e9 f0       	breq	.+58     	; 0x338 <i2c_scan+0x9a>
			*(data++) = i;
			found++;
		}		
		TWCR = 0x94;             // stop bit
 2fe:	56 bf       	out	0x36, r21	; 54
	PORTC &= ~3; while(timeout--); PORTC |=3; //Pull SCL low. some sensors need this.
	DDRC &= ~3 ;// SCL as input
	PORTC |= 3; //Enable SCL/SDA Pull up	
	timeout=50000;

	for(uint8_t i = 1;i <= 127;i++){
 300:	9f 5f       	subi	r25, 0xFF	; 255
 302:	90 38       	cpi	r25, 0x80	; 128
 304:	09 f7       	brne	.-62     	; 0x2c8 <i2c_scan+0x2a>
 306:	08 95       	ret
		TWCR = 0xA4;             // send a start bit on i2c bus
		while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
		TWDR = i<<1;          // load address of i2c device
 308:	49 2f       	mov	r20, r25
 30a:	44 0f       	add	r20, r20
 30c:	43 b9       	out	0x03, r20	; 3
		TWCR = 0x84;             // transmit
 30e:	66 bf       	out	0x36, r22	; 54
		while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 310:	06 b6       	in	r0, 0x36	; 54
 312:	07 fc       	sbrc	r0, 7
 314:	ef cf       	rjmp	.-34     	; 0x2f4 <i2c_scan+0x56>
 316:	21 15       	cp	r18, r1
 318:	31 05       	cpc	r19, r1
 31a:	21 f4       	brne	.+8      	; 0x324 <i2c_scan+0x86>
 31c:	e9 cf       	rjmp	.-46     	; 0x2f0 <i2c_scan+0x52>
 31e:	21 15       	cp	r18, r1
 320:	31 05       	cpc	r19, r1
 322:	41 f3       	breq	.-48     	; 0x2f4 <i2c_scan+0x56>
 324:	21 50       	subi	r18, 0x01	; 1
 326:	31 09       	sbc	r19, r1
 328:	06 b6       	in	r0, 0x36	; 54
 32a:	07 fe       	sbrs	r0, 7
 32c:	f8 cf       	rjmp	.-16     	; 0x31e <i2c_scan+0x80>
		asm("WDR");
 32e:	a8 95       	wdr
		if((TWSR&0xFC) == 0x18){   // SLA+W has been transmitted; ACK has been received
 330:	41 b1       	in	r20, 0x01	; 1
 332:	4c 7f       	andi	r20, 0xFC	; 252
 334:	48 31       	cpi	r20, 0x18	; 24
 336:	19 f7       	brne	.-58     	; 0x2fe <i2c_scan+0x60>
			*(data++) = i;
 338:	90 83       	st	Z, r25
			found++;
 33a:	8f 5f       	subi	r24, 0xFF	; 255
		TWDR = i<<1;          // load address of i2c device
		TWCR = 0x84;             // transmit
		while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
		asm("WDR");
		if((TWSR&0xFC) == 0x18){   // SLA+W has been transmitted; ACK has been received
			*(data++) = i;
 33c:	31 96       	adiw	r30, 0x01	; 1
 33e:	df cf       	rjmp	.-66     	; 0x2fe <i2c_scan+0x60>

00000340 <i2c_write>:

uint8_t i2c_write(uint8_t address, uint8_t *data, uint8_t numbytes)
{

	uint16_t timeout = 10000;
	TWCR = 0xA4;                                                // send a start bit on i2c bus
 340:	94 ea       	ldi	r25, 0xA4	; 164
 342:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 344:	06 b6       	in	r0, 0x36	; 54
 346:	07 fc       	sbrc	r0, 7
 348:	44 c0       	rjmp	.+136    	; 0x3d2 <i2c_write+0x92>
 34a:	20 e1       	ldi	r18, 0x10	; 16
 34c:	37 e2       	ldi	r19, 0x27	; 39
 34e:	03 c0       	rjmp	.+6      	; 0x356 <i2c_write+0x16>
 350:	21 15       	cp	r18, r1
 352:	31 05       	cpc	r19, r1
 354:	a1 f1       	breq	.+104    	; 0x3be <i2c_write+0x7e>
 356:	21 50       	subi	r18, 0x01	; 1
 358:	31 09       	sbc	r19, r1
 35a:	06 b6       	in	r0, 0x36	; 54
 35c:	07 fe       	sbrs	r0, 7
 35e:	f8 cf       	rjmp	.-16     	; 0x350 <i2c_write+0x10>
	TWDR = address<<1;                                             // load address of i2c device
 360:	88 0f       	add	r24, r24
 362:	83 b9       	out	0x03, r24	; 3
	TWCR = 0x84;                                                // transmit
 364:	84 e8       	ldi	r24, 0x84	; 132
 366:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 368:	06 b6       	in	r0, 0x36	; 54
 36a:	07 fc       	sbrc	r0, 7
 36c:	08 c0       	rjmp	.+16     	; 0x37e <i2c_write+0x3e>
 36e:	21 15       	cp	r18, r1
 370:	31 05       	cpc	r19, r1
 372:	61 f1       	breq	.+88     	; 0x3cc <i2c_write+0x8c>
 374:	21 50       	subi	r18, 0x01	; 1
 376:	31 09       	sbc	r19, r1
 378:	06 b6       	in	r0, 0x36	; 54
 37a:	07 fe       	sbrs	r0, 7
 37c:	f8 cf       	rjmp	.-16     	; 0x36e <i2c_write+0x2e>

	while(numbytes--){			//
 37e:	8f ef       	ldi	r24, 0xFF	; 255
 380:	84 0f       	add	r24, r20
 382:	44 23       	and	r20, r20
 384:	a1 f0       	breq	.+40     	; 0x3ae <i2c_write+0x6e>
 386:	fb 01       	movw	r30, r22
		TWDR = *(data++);
		TWCR = 0x84;                                                // transmit
 388:	44 e8       	ldi	r20, 0x84	; 132
	TWDR = address<<1;                                             // load address of i2c device
	TWCR = 0x84;                                                // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit

	while(numbytes--){			//
		TWDR = *(data++);
 38a:	91 91       	ld	r25, Z+
 38c:	93 b9       	out	0x03, r25	; 3
		TWCR = 0x84;                                                // transmit
 38e:	46 bf       	out	0x36, r20	; 54
		while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 390:	06 b6       	in	r0, 0x36	; 54
 392:	07 fe       	sbrs	r0, 7
 394:	06 c0       	rjmp	.+12     	; 0x3a2 <i2c_write+0x62>
 396:	08 c0       	rjmp	.+16     	; 0x3a8 <i2c_write+0x68>
 398:	21 50       	subi	r18, 0x01	; 1
 39a:	31 09       	sbc	r19, r1
 39c:	06 b6       	in	r0, 0x36	; 54
 39e:	07 fc       	sbrc	r0, 7
 3a0:	03 c0       	rjmp	.+6      	; 0x3a8 <i2c_write+0x68>
 3a2:	21 15       	cp	r18, r1
 3a4:	31 05       	cpc	r19, r1
 3a6:	c1 f7       	brne	.-16     	; 0x398 <i2c_write+0x58>
		asm("WDR");
 3a8:	a8 95       	wdr
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
	TWDR = address<<1;                                             // load address of i2c device
	TWCR = 0x84;                                                // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit

	while(numbytes--){			//
 3aa:	81 50       	subi	r24, 0x01	; 1
 3ac:	70 f7       	brcc	.-36     	; 0x38a <i2c_write+0x4a>
		TWDR = *(data++);
		TWCR = 0x84;                                                // transmit
		while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
		asm("WDR");
	}
	TWCR = 0x94;                                                // stop bit
 3ae:	84 e9       	ldi	r24, 0x94	; 148
 3b0:	86 bf       	out	0x36, r24	; 54
 3b2:	81 e0       	ldi	r24, 0x01	; 1
 3b4:	23 2b       	or	r18, r19
 3b6:	11 f0       	breq	.+4      	; 0x3bc <i2c_write+0x7c>
 3b8:	80 e0       	ldi	r24, 0x00	; 0
 3ba:	08 95       	ret
	if(timeout)return 0;		                                    // send timeout status
	else return 1;
}
 3bc:	08 95       	ret
{

	uint16_t timeout = 10000;
	TWCR = 0xA4;                                                // send a start bit on i2c bus
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
	TWDR = address<<1;                                             // load address of i2c device
 3be:	88 0f       	add	r24, r24
 3c0:	83 b9       	out	0x03, r24	; 3
	TWCR = 0x84;                                                // transmit
 3c2:	84 e8       	ldi	r24, 0x84	; 132
 3c4:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 3c6:	06 b6       	in	r0, 0x36	; 54
 3c8:	07 fc       	sbrc	r0, 7
 3ca:	d9 cf       	rjmp	.-78     	; 0x37e <i2c_write+0x3e>
*************************************************************************/

uint8_t i2c_write(uint8_t address, uint8_t *data, uint8_t numbytes)
{

	uint16_t timeout = 10000;
 3cc:	20 e0       	ldi	r18, 0x00	; 0
 3ce:	30 e0       	ldi	r19, 0x00	; 0
 3d0:	d6 cf       	rjmp	.-84     	; 0x37e <i2c_write+0x3e>
	TWCR = 0xA4;                                                // send a start bit on i2c bus
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
	TWDR = address<<1;                                             // load address of i2c device
 3d2:	88 0f       	add	r24, r24
 3d4:	83 b9       	out	0x03, r24	; 3
	TWCR = 0x84;                                                // transmit
 3d6:	84 e8       	ldi	r24, 0x84	; 132
 3d8:	86 bf       	out	0x36, r24	; 54
*************************************************************************/

uint8_t i2c_write(uint8_t address, uint8_t *data, uint8_t numbytes)
{

	uint16_t timeout = 10000;
 3da:	20 e1       	ldi	r18, 0x10	; 16
 3dc:	37 e2       	ldi	r19, 0x27	; 39
	TWCR = 0xA4;                                                // send a start bit on i2c bus
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
	TWDR = address<<1;                                             // load address of i2c device
	TWCR = 0x84;                                                // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 3de:	06 b6       	in	r0, 0x36	; 54
 3e0:	07 fe       	sbrs	r0, 7
 3e2:	c8 cf       	rjmp	.-112    	; 0x374 <i2c_write+0x34>
 3e4:	cc cf       	rjmp	.-104    	; 0x37e <i2c_write+0x3e>

000003e6 <i2c_read>:
*************************************************************************/

uint8_t i2c_read(uint8_t address, uint8_t reg, uint8_t *data, uint8_t numbytes)
{
	uint16_t timeout = 10000;
	TWCR = 0xA4;                                   // send a start bit on i2c bus
 3e6:	94 ea       	ldi	r25, 0xA4	; 164
 3e8:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;    // wait for confirmation of transmit
 3ea:	06 b6       	in	r0, 0x36	; 54
 3ec:	07 fc       	sbrc	r0, 7
 3ee:	98 c0       	rjmp	.+304    	; 0x520 <__EEPROM_REGION_LENGTH__+0x120>
 3f0:	e0 e1       	ldi	r30, 0x10	; 16
 3f2:	f7 e2       	ldi	r31, 0x27	; 39
 3f4:	02 c0       	rjmp	.+4      	; 0x3fa <i2c_read+0x14>
 3f6:	30 97       	sbiw	r30, 0x00	; 0
 3f8:	11 f1       	breq	.+68     	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
 3fa:	31 97       	sbiw	r30, 0x01	; 1
 3fc:	06 b6       	in	r0, 0x36	; 54
 3fe:	07 fe       	sbrs	r0, 7
 400:	fa cf       	rjmp	.-12     	; 0x3f6 <i2c_read+0x10>
	TWDR = address<<1;                                // load address of i2c device
 402:	98 2f       	mov	r25, r24
 404:	99 0f       	add	r25, r25
 406:	93 b9       	out	0x03, r25	; 3
	TWCR = 0x84;                                                // transmit
 408:	94 e8       	ldi	r25, 0x84	; 132
 40a:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;      // wait for confirmation of transmit
 40c:	06 b6       	in	r0, 0x36	; 54
 40e:	07 fc       	sbrc	r0, 7
 410:	06 c0       	rjmp	.+12     	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 412:	30 97       	sbiw	r30, 0x00	; 0
 414:	d1 f0       	breq	.+52     	; 0x44a <__EEPROM_REGION_LENGTH__+0x4a>
 416:	31 97       	sbiw	r30, 0x01	; 1
 418:	06 b6       	in	r0, 0x36	; 54
 41a:	07 fe       	sbrs	r0, 7
 41c:	fa cf       	rjmp	.-12     	; 0x412 <__EEPROM_REGION_LENGTH__+0x12>

	TWDR = reg;		              // write the register to read from.
 41e:	63 b9       	out	0x03, r22	; 3
	TWCR = 0x84;                       // transmit
 420:	94 e8       	ldi	r25, 0x84	; 132
 422:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 424:	06 b6       	in	r0, 0x36	; 54
 426:	07 fc       	sbrc	r0, 7
 428:	18 c0       	rjmp	.+48     	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
 42a:	30 97       	sbiw	r30, 0x00	; 0
 42c:	19 f4       	brne	.+6      	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
 42e:	13 c0       	rjmp	.+38     	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>
 430:	30 97       	sbiw	r30, 0x00	; 0
 432:	99 f0       	breq	.+38     	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
 434:	31 97       	sbiw	r30, 0x01	; 1
 436:	06 b6       	in	r0, 0x36	; 54
 438:	07 fe       	sbrs	r0, 7
 43a:	fa cf       	rjmp	.-12     	; 0x430 <__EEPROM_REGION_LENGTH__+0x30>
 43c:	0e c0       	rjmp	.+28     	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
uint8_t i2c_read(uint8_t address, uint8_t reg, uint8_t *data, uint8_t numbytes)
{
	uint16_t timeout = 10000;
	TWCR = 0xA4;                                   // send a start bit on i2c bus
	while(!(TWCR & 0x80) && timeout)timeout--;    // wait for confirmation of transmit
	TWDR = address<<1;                                // load address of i2c device
 43e:	98 2f       	mov	r25, r24
 440:	99 0f       	add	r25, r25
 442:	93 b9       	out	0x03, r25	; 3
	TWCR = 0x84;                                                // transmit
 444:	94 e8       	ldi	r25, 0x84	; 132
 446:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;      // wait for confirmation of transmit
 448:	96 b7       	in	r25, 0x36	; 54

	TWDR = reg;		              // write the register to read from.
 44a:	63 b9       	out	0x03, r22	; 3
	TWCR = 0x84;                       // transmit
 44c:	94 e8       	ldi	r25, 0x84	; 132
 44e:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 450:	06 b6       	in	r0, 0x36	; 54
 452:	07 fe       	sbrs	r0, 7
 454:	00 c0       	rjmp	.+0      	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>
returns: 0 if timeout, 1 if successful.
*************************************************************************/

uint8_t i2c_read(uint8_t address, uint8_t reg, uint8_t *data, uint8_t numbytes)
{
	uint16_t timeout = 10000;
 456:	e0 e0       	ldi	r30, 0x00	; 0
 458:	f0 e0       	ldi	r31, 0x00	; 0
	while(!(TWCR & 0x80) && timeout)timeout--;      // wait for confirmation of transmit

	TWDR = reg;		              // write the register to read from.
	TWCR = 0x84;                       // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
	asm("WDR");
 45a:	a8 95       	wdr

	TWCR = 0xA4;                                                // send a repeated start bit on i2c bus
 45c:	94 ea       	ldi	r25, 0xA4	; 164
 45e:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 460:	06 b6       	in	r0, 0x36	; 54
 462:	07 fe       	sbrs	r0, 7
 464:	05 c0       	rjmp	.+10     	; 0x470 <__EEPROM_REGION_LENGTH__+0x70>
 466:	47 c0       	rjmp	.+142    	; 0x4f6 <__EEPROM_REGION_LENGTH__+0xf6>
 468:	31 97       	sbiw	r30, 0x01	; 1
 46a:	06 b6       	in	r0, 0x36	; 54
 46c:	07 fc       	sbrc	r0, 7
 46e:	43 c0       	rjmp	.+134    	; 0x4f6 <__EEPROM_REGION_LENGTH__+0xf6>
 470:	30 97       	sbiw	r30, 0x00	; 0
 472:	d1 f7       	brne	.-12     	; 0x468 <__EEPROM_REGION_LENGTH__+0x68>
	TWDR = address<<1|1;                                           // load address of i2c device [ READ MODE ]
 474:	88 0f       	add	r24, r24
 476:	81 60       	ori	r24, 0x01	; 1
 478:	83 b9       	out	0x03, r24	; 3
	TWCR = 0xC4;                                                // transmit
 47a:	84 ec       	ldi	r24, 0xC4	; 196
 47c:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 47e:	06 b6       	in	r0, 0x36	; 54
 480:	07 fe       	sbrs	r0, 7
 482:	00 c0       	rjmp	.+0      	; 0x484 <__EEPROM_REGION_LENGTH__+0x84>
	TWCR = 0x84;                                                // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;      // wait for confirmation of transmit

	TWDR = reg;		              // write the register to read from.
	TWCR = 0x84;                       // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 484:	e0 e0       	ldi	r30, 0x00	; 0
 486:	f0 e0       	ldi	r31, 0x00	; 0
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
	TWDR = address<<1|1;                                           // load address of i2c device [ READ MODE ]
	TWCR = 0xC4;                                                // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit

	while(numbytes > 1){
 488:	22 30       	cpi	r18, 0x02	; 2
 48a:	c8 f0       	brcs	.+50     	; 0x4be <__EEPROM_REGION_LENGTH__+0xbe>
 48c:	da 01       	movw	r26, r20
 48e:	22 50       	subi	r18, 0x02	; 2
 490:	82 2f       	mov	r24, r18
 492:	90 e0       	ldi	r25, 0x00	; 0
 494:	01 96       	adiw	r24, 0x01	; 1
 496:	48 0f       	add	r20, r24
 498:	59 1f       	adc	r21, r25
		TWCR = 0xC4;                                 // transmit, ACK (byte request)
 49a:	94 ec       	ldi	r25, 0xC4	; 196
 49c:	96 bf       	out	0x36, r25	; 54
		while(!(TWCR & 0x80) && timeout)timeout--;    // wait for confirmation of transmit
 49e:	06 b6       	in	r0, 0x36	; 54
 4a0:	07 fe       	sbrs	r0, 7
 4a2:	05 c0       	rjmp	.+10     	; 0x4ae <__EEPROM_REGION_LENGTH__+0xae>
 4a4:	06 c0       	rjmp	.+12     	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
 4a6:	31 97       	sbiw	r30, 0x01	; 1
 4a8:	06 b6       	in	r0, 0x36	; 54
 4aa:	07 fc       	sbrc	r0, 7
 4ac:	02 c0       	rjmp	.+4      	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
 4ae:	30 97       	sbiw	r30, 0x00	; 0
 4b0:	d1 f7       	brne	.-12     	; 0x4a6 <__EEPROM_REGION_LENGTH__+0xa6>
		
		*(data++) = TWDR;		            // and grab the target data
 4b2:	83 b1       	in	r24, 0x03	; 3
 4b4:	8d 93       	st	X+, r24
		asm("WDR");
 4b6:	a8 95       	wdr
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
	TWDR = address<<1|1;                                           // load address of i2c device [ READ MODE ]
	TWCR = 0xC4;                                                // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit

	while(numbytes > 1){
 4b8:	a4 17       	cp	r26, r20
 4ba:	b5 07       	cpc	r27, r21
 4bc:	79 f7       	brne	.-34     	; 0x49c <__EEPROM_REGION_LENGTH__+0x9c>
		
		*(data++) = TWDR;		            // and grab the target data
		asm("WDR");
		numbytes --;
	}
	TWCR = 0x84;                    	         // transmit, NACK (last byte request)
 4be:	84 e8       	ldi	r24, 0x84	; 132
 4c0:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;       // wait for confirmation of transmit
 4c2:	06 b6       	in	r0, 0x36	; 54
 4c4:	07 fe       	sbrs	r0, 7
 4c6:	05 c0       	rjmp	.+10     	; 0x4d2 <__EEPROM_REGION_LENGTH__+0xd2>
 4c8:	0d c0       	rjmp	.+26     	; 0x4e4 <__EEPROM_REGION_LENGTH__+0xe4>
 4ca:	31 97       	sbiw	r30, 0x01	; 1
 4cc:	06 b6       	in	r0, 0x36	; 54
 4ce:	07 fc       	sbrc	r0, 7
 4d0:	09 c0       	rjmp	.+18     	; 0x4e4 <__EEPROM_REGION_LENGTH__+0xe4>
 4d2:	30 97       	sbiw	r30, 0x00	; 0
 4d4:	d1 f7       	brne	.-12     	; 0x4ca <__EEPROM_REGION_LENGTH__+0xca>
	*(data++) = TWDR;         		          // and grab the target data
 4d6:	83 b1       	in	r24, 0x03	; 3
 4d8:	fa 01       	movw	r30, r20
 4da:	80 83       	st	Z, r24
	TWCR = 0x94;                          	         // stop bit
 4dc:	84 e9       	ldi	r24, 0x94	; 148
 4de:	86 bf       	out	0x36, r24	; 54

	if(timeout)return 0;		        // send timeout status
	else return 1;
 4e0:	81 e0       	ldi	r24, 0x01	; 1
 4e2:	08 95       	ret
		asm("WDR");
		numbytes --;
	}
	TWCR = 0x84;                    	         // transmit, NACK (last byte request)
	while(!(TWCR & 0x80) && timeout)timeout--;       // wait for confirmation of transmit
	*(data++) = TWDR;         		          // and grab the target data
 4e4:	83 b1       	in	r24, 0x03	; 3
 4e6:	da 01       	movw	r26, r20
 4e8:	8c 93       	st	X, r24
	TWCR = 0x94;                          	         // stop bit
 4ea:	84 e9       	ldi	r24, 0x94	; 148
 4ec:	86 bf       	out	0x36, r24	; 54

	if(timeout)return 0;		        // send timeout status
 4ee:	81 e0       	ldi	r24, 0x01	; 1
 4f0:	ef 2b       	or	r30, r31
 4f2:	a1 f4       	brne	.+40     	; 0x51c <__EEPROM_REGION_LENGTH__+0x11c>
	else return 1;
}
 4f4:	08 95       	ret
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
	asm("WDR");

	TWCR = 0xA4;                                                // send a repeated start bit on i2c bus
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
	TWDR = address<<1|1;                                           // load address of i2c device [ READ MODE ]
 4f6:	88 0f       	add	r24, r24
 4f8:	81 60       	ori	r24, 0x01	; 1
 4fa:	83 b9       	out	0x03, r24	; 3
	TWCR = 0xC4;                                                // transmit
 4fc:	84 ec       	ldi	r24, 0xC4	; 196
 4fe:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 500:	06 b6       	in	r0, 0x36	; 54
 502:	07 fc       	sbrc	r0, 7
 504:	c1 cf       	rjmp	.-126    	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
 506:	30 97       	sbiw	r30, 0x00	; 0
 508:	21 f4       	brne	.+8      	; 0x512 <__EEPROM_REGION_LENGTH__+0x112>
 50a:	bc cf       	rjmp	.-136    	; 0x484 <__EEPROM_REGION_LENGTH__+0x84>
 50c:	30 97       	sbiw	r30, 0x00	; 0
 50e:	09 f4       	brne	.+2      	; 0x512 <__EEPROM_REGION_LENGTH__+0x112>
 510:	bb cf       	rjmp	.-138    	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
 512:	31 97       	sbiw	r30, 0x01	; 1
 514:	06 b6       	in	r0, 0x36	; 54
 516:	07 fe       	sbrs	r0, 7
 518:	f9 cf       	rjmp	.-14     	; 0x50c <__EEPROM_REGION_LENGTH__+0x10c>
 51a:	b6 cf       	rjmp	.-148    	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
	TWCR = 0x84;                    	         // transmit, NACK (last byte request)
	while(!(TWCR & 0x80) && timeout)timeout--;       // wait for confirmation of transmit
	*(data++) = TWDR;         		          // and grab the target data
	TWCR = 0x94;                          	         // stop bit

	if(timeout)return 0;		        // send timeout status
 51c:	80 e0       	ldi	r24, 0x00	; 0
 51e:	08 95       	ret
uint8_t i2c_read(uint8_t address, uint8_t reg, uint8_t *data, uint8_t numbytes)
{
	uint16_t timeout = 10000;
	TWCR = 0xA4;                                   // send a start bit on i2c bus
	while(!(TWCR & 0x80) && timeout)timeout--;    // wait for confirmation of transmit
	TWDR = address<<1;                                // load address of i2c device
 520:	98 2f       	mov	r25, r24
 522:	99 0f       	add	r25, r25
 524:	93 b9       	out	0x03, r25	; 3
	TWCR = 0x84;                                                // transmit
 526:	94 e8       	ldi	r25, 0x84	; 132
 528:	96 bf       	out	0x36, r25	; 54
	while(!(TWCR & 0x80) && timeout)timeout--;      // wait for confirmation of transmit
 52a:	06 b6       	in	r0, 0x36	; 54
 52c:	07 fc       	sbrc	r0, 7
 52e:	03 c0       	rjmp	.+6      	; 0x536 <__EEPROM_REGION_LENGTH__+0x136>
returns: 0 if timeout, 1 if successful.
*************************************************************************/

uint8_t i2c_read(uint8_t address, uint8_t reg, uint8_t *data, uint8_t numbytes)
{
	uint16_t timeout = 10000;
 530:	e0 e1       	ldi	r30, 0x10	; 16
 532:	f7 e2       	ldi	r31, 0x27	; 39
 534:	70 cf       	rjmp	.-288    	; 0x416 <__EEPROM_REGION_LENGTH__+0x16>
	while(!(TWCR & 0x80) && timeout)timeout--;    // wait for confirmation of transmit
	TWDR = address<<1;                                // load address of i2c device
	TWCR = 0x84;                                                // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;      // wait for confirmation of transmit

	TWDR = reg;		              // write the register to read from.
 536:	63 b9       	out	0x03, r22	; 3
	TWCR = 0x84;                       // transmit
 538:	96 bf       	out	0x36, r25	; 54
returns: 0 if timeout, 1 if successful.
*************************************************************************/

uint8_t i2c_read(uint8_t address, uint8_t reg, uint8_t *data, uint8_t numbytes)
{
	uint16_t timeout = 10000;
 53a:	e0 e1       	ldi	r30, 0x10	; 16
 53c:	f7 e2       	ldi	r31, 0x27	; 39
	TWCR = 0x84;                                                // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;      // wait for confirmation of transmit

	TWDR = reg;		              // write the register to read from.
	TWCR = 0x84;                       // transmit
	while(!(TWCR & 0x80) && timeout)timeout--;                  // wait for confirmation of transmit
 53e:	06 b6       	in	r0, 0x36	; 54
 540:	07 fe       	sbrs	r0, 7
 542:	78 cf       	rjmp	.-272    	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
 544:	8a cf       	rjmp	.-236    	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>

00000546 <I2CStart>:



unsigned char I2CStart() {
	/* Send START condition */
	TWCR =  (1 << TWINT) | (1 << TWEN) | (1 << TWSTA);
 546:	84 ea       	ldi	r24, 0xA4	; 164
 548:	86 bf       	out	0x36, r24	; 54
	
	/* Wait for TWINT flag to set */
	while (!(TWCR & (1 << TWINT)));
 54a:	06 b6       	in	r0, 0x36	; 54
 54c:	07 fe       	sbrs	r0, 7
 54e:	fd cf       	rjmp	.-6      	; 0x54a <I2CStart+0x4>
	
	/* Check error */
	if (TW_STATUS != TW_START && TW_STATUS != TW_REP_START)
 550:	81 b1       	in	r24, 0x01	; 1
 552:	88 7f       	andi	r24, 0xF8	; 248
 554:	88 30       	cpi	r24, 0x08	; 8
 556:	39 f0       	breq	.+14     	; 0x566 <I2CStart+0x20>
 558:	81 b1       	in	r24, 0x01	; 1
 55a:	88 7f       	andi	r24, 0xF8	; 248
 55c:	80 31       	cpi	r24, 0x10	; 16
 55e:	19 f0       	breq	.+6      	; 0x566 <I2CStart+0x20>
	{
		return TW_STATUS;
 560:	81 b1       	in	r24, 0x01	; 1
 562:	88 7f       	andi	r24, 0xF8	; 248
 564:	08 95       	ret
	}
	

	return SUCCESS;
 566:	80 e0       	ldi	r24, 0x00	; 0
}
 568:	08 95       	ret

0000056a <I2CStop>:

void I2CStop() {
	TWCR = 0x94;             // stop bit
 56a:	84 e9       	ldi	r24, 0x94	; 148
 56c:	86 bf       	out	0x36, r24	; 54
 56e:	08 95       	ret

00000570 <I2CWait>:
}



void I2CWait() {
    delay_countdown=1000;
 570:	88 ee       	ldi	r24, 0xE8	; 232
 572:	93 e0       	ldi	r25, 0x03	; 3
 574:	a0 e0       	ldi	r26, 0x00	; 0
 576:	b0 e0       	ldi	r27, 0x00	; 0
 578:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__data_end>
 57c:	90 93 73 00 	sts	0x0073, r25	; 0x800073 <__data_end+0x1>
 580:	a0 93 74 00 	sts	0x0074, r26	; 0x800074 <__data_end+0x2>
 584:	b0 93 75 00 	sts	0x0075, r27	; 0x800075 <__data_end+0x3>
    /* Wait for TWINT flag to set */
	while (!(TWCR & (1 << TWINT)) && delay_countdown--)delay_us(1);	
 588:	06 b6       	in	r0, 0x36	; 54
 58a:	07 fc       	sbrc	r0, 7
 58c:	2e c0       	rjmp	.+92     	; 0x5ea <I2CWait+0x7a>
 58e:	87 ee       	ldi	r24, 0xE7	; 231
 590:	93 e0       	ldi	r25, 0x03	; 3
 592:	a0 e0       	ldi	r26, 0x00	; 0
 594:	b0 e0       	ldi	r27, 0x00	; 0
 596:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__data_end>
 59a:	90 93 73 00 	sts	0x0073, r25	; 0x800073 <__data_end+0x1>
 59e:	a0 93 74 00 	sts	0x0074, r26	; 0x800074 <__data_end+0x2>
 5a2:	b0 93 75 00 	sts	0x0075, r27	; 0x800075 <__data_end+0x3>
 5a6:	1a c0       	rjmp	.+52     	; 0x5dc <I2CWait+0x6c>
 5a8:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <__data_end>
 5ac:	90 91 73 00 	lds	r25, 0x0073	; 0x800073 <__data_end+0x1>
 5b0:	a0 91 74 00 	lds	r26, 0x0074	; 0x800074 <__data_end+0x2>
 5b4:	b0 91 75 00 	lds	r27, 0x0075	; 0x800075 <__data_end+0x3>
 5b8:	ac 01       	movw	r20, r24
 5ba:	bd 01       	movw	r22, r26
 5bc:	41 50       	subi	r20, 0x01	; 1
 5be:	51 09       	sbc	r21, r1
 5c0:	61 09       	sbc	r22, r1
 5c2:	71 09       	sbc	r23, r1
 5c4:	40 93 72 00 	sts	0x0072, r20	; 0x800072 <__data_end>
 5c8:	50 93 73 00 	sts	0x0073, r21	; 0x800073 <__data_end+0x1>
 5cc:	60 93 74 00 	sts	0x0074, r22	; 0x800074 <__data_end+0x2>
 5d0:	70 93 75 00 	sts	0x0075, r23	; 0x800075 <__data_end+0x3>
 5d4:	89 2b       	or	r24, r25
 5d6:	8a 2b       	or	r24, r26
 5d8:	8b 2b       	or	r24, r27
 5da:	39 f0       	breq	.+14     	; 0x5ea <I2CWait+0x7a>
 5dc:	81 e0       	ldi	r24, 0x01	; 1
 5de:	90 e0       	ldi	r25, 0x00	; 0
 5e0:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
 5e4:	06 b6       	in	r0, 0x36	; 54
 5e6:	07 fe       	sbrs	r0, 7
 5e8:	df cf       	rjmp	.-66     	; 0x5a8 <I2CWait+0x38>
 5ea:	08 95       	ret

000005ec <I2CSend>:
    /* wait for any pending transfer */
}

unsigned char I2CSend(unsigned char dat) {
    delay_countdown=1000;
 5ec:	48 ee       	ldi	r20, 0xE8	; 232
 5ee:	53 e0       	ldi	r21, 0x03	; 3
 5f0:	60 e0       	ldi	r22, 0x00	; 0
 5f2:	70 e0       	ldi	r23, 0x00	; 0
 5f4:	40 93 72 00 	sts	0x0072, r20	; 0x800072 <__data_end>
 5f8:	50 93 73 00 	sts	0x0073, r21	; 0x800073 <__data_end+0x1>
 5fc:	60 93 74 00 	sts	0x0074, r22	; 0x800074 <__data_end+0x2>
 600:	70 93 75 00 	sts	0x0075, r23	; 0x800075 <__data_end+0x3>

	/* Transmit 1 byte*/

	TWDR = dat;
 604:	83 b9       	out	0x03, r24	; 3
	TWCR = (1 << TWINT) | (1 << TWEN);
 606:	84 e8       	ldi	r24, 0x84	; 132
 608:	86 bf       	out	0x36, r24	; 54
	
	/* Wait for TWINT flag to set */
	while (!(TWCR & (1 << TWINT)));
 60a:	06 b6       	in	r0, 0x36	; 54
 60c:	07 fe       	sbrs	r0, 7
 60e:	fd cf       	rjmp	.-6      	; 0x60a <I2CSend+0x1e>
	if (TW_STATUS != TW_MT_DATA_ACK)
 610:	81 b1       	in	r24, 0x01	; 1
 612:	88 7f       	andi	r24, 0xF8	; 248
 614:	88 32       	cpi	r24, 0x28	; 40
 616:	19 f0       	breq	.+6      	; 0x61e <I2CSend+0x32>
	{

		return TW_STATUS;
 618:	81 b1       	in	r24, 0x01	; 1
 61a:	88 7f       	andi	r24, 0xF8	; 248
 61c:	08 95       	ret
	}
	

	return SUCCESS;
 61e:	80 e0       	ldi	r24, 0x00	; 0

    I2CWait(); /* wait for any pending transfer */
}
 620:	08 95       	ret

00000622 <i2c_lcd_write_cmd.part.0>:
    
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
 622:	cf 93       	push	r28
 624:	c8 2f       	mov	r28, r24
    if(address == LCD_ADDRESS_DISABLED)return;

        I2CStart();
 626:	0e 94 a3 02 	call	0x546	; 0x546 <I2CStart>
        I2CSend(address<<1); //default address for PCA8547AT IO expander
 62a:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 62e:	88 0f       	add	r24, r24
 630:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2CSend>
        I2CSend(cmd&0xFF);     //
 634:	8c 2f       	mov	r24, r28
 636:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2CSend>
        I2CStop();               
 63a:	0e 94 b5 02 	call	0x56a	; 0x56a <I2CStop>
    delay_us(1000);
 63e:	88 ee       	ldi	r24, 0xE8	; 232
 640:	93 e0       	ldi	r25, 0x03	; 3
}
 642:	cf 91       	pop	r28

        I2CStart();
        I2CSend(address<<1); //default address for PCA8547AT IO expander
        I2CSend(cmd&0xFF);     //
        I2CStop();               
    delay_us(1000);
 644:	0c 94 49 00 	jmp	0x92	; 0x92 <delay_us>

00000648 <i2c_lcd_write_cmd>:
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 648:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <address>
 64c:	91 11       	cpse	r25, r1
 64e:	01 c0       	rjmp	.+2      	; 0x652 <i2c_lcd_write_cmd+0xa>
 650:	08 95       	ret
 652:	0c 94 11 03 	jmp	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>

00000656 <i2c_lcd_write_cmd_arg>:
        I2CSend(cmd&0xFF);     //
        I2CStop();               
    delay_us(1000);
}

void i2c_lcd_write_cmd_arg(unsigned char cmd, unsigned char arg){ 
 656:	cf 93       	push	r28
 658:	df 93       	push	r29
    if(address == LCD_ADDRESS_DISABLED)return;
 65a:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <address>
 65e:	91 11       	cpse	r25, r1
 660:	03 c0       	rjmp	.+6      	; 0x668 <i2c_lcd_write_cmd_arg+0x12>
    I2CSend(address<<1); //default address for PCA8547AT IO expander
    I2CSend(cmd&0xFF);     //
    I2CSend(arg&0xFF);     //
    I2CStop();               
    delay_us(1000);
}
 662:	df 91       	pop	r29
 664:	cf 91       	pop	r28
 666:	08 95       	ret
 668:	c6 2f       	mov	r28, r22
 66a:	d8 2f       	mov	r29, r24
}

void i2c_lcd_write_cmd_arg(unsigned char cmd, unsigned char arg){ 
    if(address == LCD_ADDRESS_DISABLED)return;

    I2CStart();
 66c:	0e 94 a3 02 	call	0x546	; 0x546 <I2CStart>
    I2CSend(address<<1); //default address for PCA8547AT IO expander
 670:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 674:	88 0f       	add	r24, r24
 676:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2CSend>
    I2CSend(cmd&0xFF);     //
 67a:	8d 2f       	mov	r24, r29
 67c:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2CSend>
    I2CSend(arg&0xFF);     //
 680:	8c 2f       	mov	r24, r28
 682:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2CSend>
    I2CStop();               
 686:	0e 94 b5 02 	call	0x56a	; 0x56a <I2CStop>
    delay_us(1000);
 68a:	88 ee       	ldi	r24, 0xE8	; 232
 68c:	93 e0       	ldi	r25, 0x03	; 3
}
 68e:	df 91       	pop	r29
 690:	cf 91       	pop	r28
    I2CStart();
    I2CSend(address<<1); //default address for PCA8547AT IO expander
    I2CSend(cmd&0xFF);     //
    I2CSend(arg&0xFF);     //
    I2CStop();               
    delay_us(1000);
 692:	0c 94 49 00 	jmp	0x92	; 0x92 <delay_us>

00000696 <i2c_lcd_strobe>:
}

void i2c_lcd_strobe(unsigned char data){
 696:	cf 93       	push	r28
 698:	c8 2f       	mov	r28, r24
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 69a:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 69e:	81 11       	cpse	r24, r1
 6a0:	12 c0       	rjmp	.+36     	; 0x6c6 <i2c_lcd_strobe+0x30>
    delay_us(1000);
}

void i2c_lcd_strobe(unsigned char data){
    i2c_lcd_write_cmd( (data&0xFF) | En | LCD_BACKLIGHT);
    delay_us(100);
 6a2:	84 ef       	ldi	r24, 0xF4	; 244
 6a4:	91 e0       	ldi	r25, 0x01	; 1
 6a6:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 6aa:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 6ae:	88 23       	and	r24, r24
 6b0:	29 f0       	breq	.+10     	; 0x6bc <i2c_lcd_strobe+0x26>
 6b2:	8c 2f       	mov	r24, r28
 6b4:	83 7f       	andi	r24, 0xF3	; 243
 6b6:	88 60       	ori	r24, 0x08	; 8
 6b8:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>

void i2c_lcd_strobe(unsigned char data){
    i2c_lcd_write_cmd( (data&0xFF) | En | LCD_BACKLIGHT);
    delay_us(100);
    i2c_lcd_write_cmd((( (data&0xFF) & ~En) | LCD_BACKLIGHT));
    delay_us(500);
 6bc:	80 ed       	ldi	r24, 0xD0	; 208
 6be:	97 e0       	ldi	r25, 0x07	; 7
}
 6c0:	cf 91       	pop	r28

void i2c_lcd_strobe(unsigned char data){
    i2c_lcd_write_cmd( (data&0xFF) | En | LCD_BACKLIGHT);
    delay_us(100);
    i2c_lcd_write_cmd((( (data&0xFF) & ~En) | LCD_BACKLIGHT));
    delay_us(500);
 6c2:	0c 94 49 00 	jmp	0x92	; 0x92 <delay_us>
 6c6:	8c 2f       	mov	r24, r28
 6c8:	8c 60       	ori	r24, 0x0C	; 12
 6ca:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
 6ce:	e9 cf       	rjmp	.-46     	; 0x6a2 <i2c_lcd_strobe+0xc>

000006d0 <i2c_lcd_write_four_bits>:
}

void i2c_lcd_write_four_bits(unsigned char data){   //USED ONLY BY I2C LCD for now.     
 6d0:	cf 93       	push	r28
 6d2:	c8 2f       	mov	r28, r24
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 6d4:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 6d8:	88 23       	and	r24, r24
 6da:	21 f0       	breq	.+8      	; 0x6e4 <i2c_lcd_write_four_bits+0x14>
 6dc:	8c 2f       	mov	r24, r28
 6de:	88 60       	ori	r24, 0x08	; 8
 6e0:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
    delay_us(500);
}

void i2c_lcd_write_four_bits(unsigned char data){   //USED ONLY BY I2C LCD for now.     
	    i2c_lcd_write_cmd((data&0xFF) | LCD_BACKLIGHT); 
	    i2c_lcd_strobe(data);
 6e4:	8c 2f       	mov	r24, r28
}
 6e6:	cf 91       	pop	r28
    delay_us(500);
}

void i2c_lcd_write_four_bits(unsigned char data){   //USED ONLY BY I2C LCD for now.     
	    i2c_lcd_write_cmd((data&0xFF) | LCD_BACKLIGHT); 
	    i2c_lcd_strobe(data);
 6e8:	0c 94 4b 03 	jmp	0x696	; 0x696 <i2c_lcd_strobe>

000006ec <i2c_lcd_write>:
}

// write a command to lcd
void i2c_lcd_write(unsigned char cmd){
 6ec:	cf 93       	push	r28
 6ee:	df 93       	push	r29
    if(address == LCD_ADDRESS_DISABLED)return;
 6f0:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <address>
 6f4:	99 23       	and	r25, r25
 6f6:	49 f1       	breq	.+82     	; 0x74a <i2c_lcd_write+0x5e>
 6f8:	c8 2f       	mov	r28, r24
    
    i2c_lcd_write_cmd( (cmd & 0xF0)           | LCD_BACKLIGHT);
 6fa:	d8 2f       	mov	r29, r24
 6fc:	d0 7f       	andi	r29, 0xF0	; 240
 6fe:	8d 2f       	mov	r24, r29
 700:	88 60       	ori	r24, 0x08	; 8
 702:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 706:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 70a:	81 11       	cpse	r24, r1
 70c:	2a c0       	rjmp	.+84     	; 0x762 <i2c_lcd_write+0x76>
// write a command to lcd
void i2c_lcd_write(unsigned char cmd){
    if(address == LCD_ADDRESS_DISABLED)return;
    
    i2c_lcd_write_cmd( (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
 70e:	88 ee       	ldi	r24, 0xE8	; 232
 710:	93 e0       	ldi	r25, 0x03	; 3
 712:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 716:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 71a:	81 11       	cpse	r24, r1
 71c:	2e c0       	rjmp	.+92     	; 0x77a <i2c_lcd_write+0x8e>
void i2c_lcd_write(unsigned char cmd){
    if(address == LCD_ADDRESS_DISABLED)return;
    
    i2c_lcd_write_cmd( (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 71e:	88 ee       	ldi	r24, 0xE8	; 232
 720:	93 e0       	ldi	r25, 0x03	; 3
 722:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 726:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 72a:	81 11       	cpse	r24, r1
 72c:	31 c0       	rjmp	.+98     	; 0x790 <i2c_lcd_write+0xa4>
    i2c_lcd_write_cmd( (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
 72e:	88 ee       	ldi	r24, 0xE8	; 232
 730:	93 e0       	ldi	r25, 0x03	; 3
 732:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 736:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 73a:	81 11       	cpse	r24, r1
 73c:	09 c0       	rjmp	.+18     	; 0x750 <i2c_lcd_write+0x64>
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 73e:	88 ee       	ldi	r24, 0xE8	; 232
 740:	93 e0       	ldi	r25, 0x03	; 3
    
}
 742:	df 91       	pop	r29
 744:	cf 91       	pop	r28
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 746:	0c 94 49 00 	jmp	0x92	; 0x92 <delay_us>
    
}
 74a:	df 91       	pop	r29
 74c:	cf 91       	pop	r28
 74e:	08 95       	ret
 750:	88 e0       	ldi	r24, 0x08	; 8
 752:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 756:	88 ee       	ldi	r24, 0xE8	; 232
 758:	93 e0       	ldi	r25, 0x03	; 3
    
}
 75a:	df 91       	pop	r29
 75c:	cf 91       	pop	r28
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 75e:	0c 94 49 00 	jmp	0x92	; 0x92 <delay_us>
 762:	8d 2f       	mov	r24, r29
 764:	8c 60       	ori	r24, 0x0C	; 12
 766:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
// write a command to lcd
void i2c_lcd_write(unsigned char cmd){
    if(address == LCD_ADDRESS_DISABLED)return;
    
    i2c_lcd_write_cmd( (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
 76a:	88 ee       	ldi	r24, 0xE8	; 232
 76c:	93 e0       	ldi	r25, 0x03	; 3
 76e:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 772:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 776:	88 23       	and	r24, r24
 778:	91 f2       	breq	.-92     	; 0x71e <i2c_lcd_write+0x32>
 77a:	88 e0       	ldi	r24, 0x08	; 8
 77c:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
void i2c_lcd_write(unsigned char cmd){
    if(address == LCD_ADDRESS_DISABLED)return;
    
    i2c_lcd_write_cmd( (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 780:	88 ee       	ldi	r24, 0xE8	; 232
 782:	93 e0       	ldi	r25, 0x03	; 3
 784:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 788:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 78c:	88 23       	and	r24, r24
 78e:	79 f2       	breq	.-98     	; 0x72e <i2c_lcd_write+0x42>
    
    i2c_lcd_write_cmd( (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
 790:	80 e1       	ldi	r24, 0x10	; 16
 792:	c8 9f       	mul	r28, r24
 794:	e0 01       	movw	r28, r0
 796:	11 24       	eor	r1, r1
 798:	8c 2f       	mov	r24, r28
 79a:	88 60       	ori	r24, 0x08	; 8
 79c:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
 7a0:	8c 2f       	mov	r24, r28
 7a2:	8c 60       	ori	r24, 0x0C	; 12
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 7a4:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <address>
 7a8:	99 23       	and	r25, r25
 7aa:	09 f2       	breq	.-126    	; 0x72e <i2c_lcd_write+0x42>
 7ac:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
    i2c_lcd_write_cmd( (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
 7b0:	88 ee       	ldi	r24, 0xE8	; 232
 7b2:	93 e0       	ldi	r25, 0x03	; 3
 7b4:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 7b8:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 7bc:	88 23       	and	r24, r24
 7be:	09 f4       	brne	.+2      	; 0x7c2 <i2c_lcd_write+0xd6>
 7c0:	be cf       	rjmp	.-132    	; 0x73e <i2c_lcd_write+0x52>
 7c2:	c6 cf       	rjmp	.-116    	; 0x750 <i2c_lcd_write+0x64>

000007c4 <i2c_lcd_init>:

static unsigned char address=LCD_ADDRESS_DISABLED;


unsigned int i2c_lcd_init(void){
    DDRC  |= (1 << TW_SDA_PIN) | (1 << TW_SCL_PIN);
 7c4:	84 b3       	in	r24, 0x14	; 20
 7c6:	83 60       	ori	r24, 0x03	; 3
 7c8:	84 bb       	out	0x14, r24	; 20
    if (pullup_en)
    {

	    PORTC |= (1 << TW_SDA_PIN) | (1 << TW_SCL_PIN);
 7ca:	85 b3       	in	r24, 0x15	; 21
 7cc:	83 60       	ori	r24, 0x03	; 3
 7ce:	85 bb       	out	0x15, r24	; 21
    }
    else
    {
	    PORTC &= ~((1 << TW_SDA_PIN) | (1 << TW_SCL_PIN));
    }
    DDRC  &= ~((1 << TW_SDA_PIN) | (1 << TW_SCL_PIN));
 7d0:	84 b3       	in	r24, 0x14	; 20
 7d2:	8c 7f       	andi	r24, 0xFC	; 252
 7d4:	84 bb       	out	0x14, r24	; 20

    /* Set bit rate register 12 and prescaler to 1 resulting in
    SCL_freq = 8MHz/(16 + 2*12*1) = 200KHz	*/
    TWBR = 12;
 7d6:	8c e0       	ldi	r24, 0x0C	; 12
 7d8:	80 b9       	out	0x00, r24	; 0


    delay_us(200);
 7da:	88 ee       	ldi	r24, 0xE8	; 232
 7dc:	93 e0       	ldi	r25, 0x03	; 3
 7de:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>

    //Search LCD

    I2CStart();
 7e2:	0e 94 a3 02 	call	0x546	; 0x546 <I2CStart>
    I2CSend(LCD_ADDRESS_A<<1);
 7e6:	8e e7       	ldi	r24, 0x7E	; 126
 7e8:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2CSend>
    if((TWSR&0xFC) == 0x18) //LCD Found
 7ec:	81 b1       	in	r24, 0x01	; 1
 7ee:	8c 7f       	andi	r24, 0xFC	; 252
 7f0:	88 31       	cpi	r24, 0x18	; 24
 7f2:	a1 f1       	breq	.+104    	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
        address = LCD_ADDRESS_A;
    I2CStop();
 7f4:	0e 94 b5 02 	call	0x56a	; 0x56a <I2CStop>

    I2CStart();
 7f8:	0e 94 a3 02 	call	0x546	; 0x546 <I2CStart>
    I2CSend(LCD_ADDRESS_B<<1);
 7fc:	8e e4       	ldi	r24, 0x4E	; 78
 7fe:	0e 94 f6 02 	call	0x5ec	; 0x5ec <I2CSend>
    if((TWSR&0xFC) == 0x18) //LCD Found
 802:	81 b1       	in	r24, 0x01	; 1
 804:	8c 7f       	andi	r24, 0xFC	; 252
 806:	88 31       	cpi	r24, 0x18	; 24
 808:	19 f4       	brne	.+6      	; 0x810 <__DATA_REGION_LENGTH__+0x10>
        address = LCD_ADDRESS_B;
 80a:	87 e2       	ldi	r24, 0x27	; 39
 80c:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <address>
    I2CStop();
 810:	0e 94 b5 02 	call	0x56a	; 0x56a <I2CStop>

    delay_us(100);
 814:	84 e6       	ldi	r24, 0x64	; 100
 816:	90 e0       	ldi	r25, 0x00	; 0
 818:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>


    i2c_lcd_write(0x03);
 81c:	83 e0       	ldi	r24, 0x03	; 3
 81e:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
    i2c_lcd_write(0x03);
 822:	83 e0       	ldi	r24, 0x03	; 3
 824:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
    i2c_lcd_write(0x03);
 828:	83 e0       	ldi	r24, 0x03	; 3
 82a:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
    i2c_lcd_write(0x02); 
 82e:	82 e0       	ldi	r24, 0x02	; 2
 830:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>

    i2c_lcd_write(LCD_FUNCTIONSET | LCD_2LINE | LCD_5x8DOTS | LCD_4BITMODE);
 834:	88 e2       	ldi	r24, 0x28	; 40
 836:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
    i2c_lcd_write(LCD_DISPLAYCONTROL | LCD_DISPLAYON);
 83a:	8c e0       	ldi	r24, 0x0C	; 12
 83c:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
    i2c_lcd_write(LCD_CLEARDISPLAY);
 840:	81 e0       	ldi	r24, 0x01	; 1
 842:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
    i2c_lcd_write(LCD_ENTRYMODESET | LCD_ENTRYLEFT);    
 846:	86 e0       	ldi	r24, 0x06	; 6
 848:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
    delay_us(10000);
 84c:	80 e2       	ldi	r24, 0x20	; 32
 84e:	9e e4       	ldi	r25, 0x4E	; 78
 850:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
    
    return address;
 854:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
    
}
 858:	90 e0       	ldi	r25, 0x00	; 0
 85a:	08 95       	ret
    //Search LCD

    I2CStart();
    I2CSend(LCD_ADDRESS_A<<1);
    if((TWSR&0xFC) == 0x18) //LCD Found
        address = LCD_ADDRESS_A;
 85c:	8f e3       	ldi	r24, 0x3F	; 63
 85e:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <address>
 862:	c8 cf       	rjmp	.-112    	; 0x7f4 <i2c_lcd_init+0x30>

00000864 <i2c_lcd_write_char>:
    i2c_lcd_write_cmd(                          LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
    
}

// write a character to lcd
void i2c_lcd_write_char(unsigned char cmd){
 864:	cf 93       	push	r28
 866:	df 93       	push	r29
    if(address == LCD_ADDRESS_DISABLED)return;
 868:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <address>
 86c:	99 23       	and	r25, r25
 86e:	49 f1       	breq	.+82     	; 0x8c2 <i2c_lcd_write_char+0x5e>
 870:	c8 2f       	mov	r28, r24

    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)           | LCD_BACKLIGHT);
 872:	d8 2f       	mov	r29, r24
 874:	d0 7f       	andi	r29, 0xF0	; 240
 876:	8d 2f       	mov	r24, r29
 878:	89 60       	ori	r24, 0x09	; 9
 87a:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 87e:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 882:	81 11       	cpse	r24, r1
 884:	2a c0       	rjmp	.+84     	; 0x8da <i2c_lcd_write_char+0x76>
// write a character to lcd
void i2c_lcd_write_char(unsigned char cmd){
    if(address == LCD_ADDRESS_DISABLED)return;

    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
 886:	88 ee       	ldi	r24, 0xE8	; 232
 888:	93 e0       	ldi	r25, 0x03	; 3
 88a:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 88e:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 892:	81 11       	cpse	r24, r1
 894:	2e c0       	rjmp	.+92     	; 0x8f2 <i2c_lcd_write_char+0x8e>
void i2c_lcd_write_char(unsigned char cmd){
    if(address == LCD_ADDRESS_DISABLED)return;

    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 896:	88 ee       	ldi	r24, 0xE8	; 232
 898:	93 e0       	ldi	r25, 0x03	; 3
 89a:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 89e:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 8a2:	81 11       	cpse	r24, r1
 8a4:	31 c0       	rjmp	.+98     	; 0x908 <i2c_lcd_write_char+0xa4>
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
 8a6:	88 ee       	ldi	r24, 0xE8	; 232
 8a8:	93 e0       	ldi	r25, 0x03	; 3
 8aa:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 8ae:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 8b2:	81 11       	cpse	r24, r1
 8b4:	09 c0       	rjmp	.+18     	; 0x8c8 <i2c_lcd_write_char+0x64>
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 8b6:	88 ee       	ldi	r24, 0xE8	; 232
 8b8:	93 e0       	ldi	r25, 0x03	; 3

}
 8ba:	df 91       	pop	r29
 8bc:	cf 91       	pop	r28
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 8be:	0c 94 49 00 	jmp	0x92	; 0x92 <delay_us>

}
 8c2:	df 91       	pop	r29
 8c4:	cf 91       	pop	r28
 8c6:	08 95       	ret
 8c8:	88 e0       	ldi	r24, 0x08	; 8
 8ca:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 8ce:	88 ee       	ldi	r24, 0xE8	; 232
 8d0:	93 e0       	ldi	r25, 0x03	; 3

}
 8d2:	df 91       	pop	r29
 8d4:	cf 91       	pop	r28
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 8d6:	0c 94 49 00 	jmp	0x92	; 0x92 <delay_us>
 8da:	8d 2f       	mov	r24, r29
 8dc:	8d 60       	ori	r24, 0x0D	; 13
 8de:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
// write a character to lcd
void i2c_lcd_write_char(unsigned char cmd){
    if(address == LCD_ADDRESS_DISABLED)return;

    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
 8e2:	88 ee       	ldi	r24, 0xE8	; 232
 8e4:	93 e0       	ldi	r25, 0x03	; 3
 8e6:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 8ea:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 8ee:	88 23       	and	r24, r24
 8f0:	91 f2       	breq	.-92     	; 0x896 <i2c_lcd_write_char+0x32>
 8f2:	88 e0       	ldi	r24, 0x08	; 8
 8f4:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
void i2c_lcd_write_char(unsigned char cmd){
    if(address == LCD_ADDRESS_DISABLED)return;

    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF
 8f8:	88 ee       	ldi	r24, 0xE8	; 232
 8fa:	93 e0       	ldi	r25, 0x03	; 3
 8fc:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 900:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 904:	88 23       	and	r24, r24
 906:	79 f2       	breq	.-98     	; 0x8a6 <i2c_lcd_write_char+0x42>

    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
 908:	80 e1       	ldi	r24, 0x10	; 16
 90a:	c8 9f       	mul	r28, r24
 90c:	e0 01       	movw	r28, r0
 90e:	11 24       	eor	r1, r1
 910:	8c 2f       	mov	r24, r28
 912:	89 60       	ori	r24, 0x09	; 9
 914:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
 918:	8c 2f       	mov	r24, r28
 91a:	8d 60       	ori	r24, 0x0D	; 13
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 91c:	90 91 76 00 	lds	r25, 0x0076	; 0x800076 <address>
 920:	99 23       	and	r25, r25
 922:	09 f2       	breq	.-126    	; 0x8a6 <i2c_lcd_write_char+0x42>
 924:	0e 94 11 03 	call	0x622	; 0x622 <i2c_lcd_write_cmd.part.0>
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)           | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | (cmd & 0xF0)      | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
    i2c_lcd_write_cmd(                               LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN OFF

    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0)      | LCD_BACKLIGHT);
    i2c_lcd_write_cmd( Rs | ((cmd<<4) & 0xF0) | En | LCD_BACKLIGHT); delay_us(LCD_DELAY); // EN ON
 928:	88 ee       	ldi	r24, 0xE8	; 232
 92a:	93 e0       	ldi	r25, 0x03	; 3
 92c:	0e 94 49 00 	call	0x92	; 0x92 <delay_us>
}



void i2c_lcd_write_cmd(unsigned char cmd){ 
    if(address == LCD_ADDRESS_DISABLED)return;
 930:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 934:	88 23       	and	r24, r24
 936:	09 f4       	brne	.+2      	; 0x93a <i2c_lcd_write_char+0xd6>
 938:	be cf       	rjmp	.-132    	; 0x8b6 <i2c_lcd_write_char+0x52>
 93a:	c6 cf       	rjmp	.-116    	; 0x8c8 <i2c_lcd_write_char+0x64>

0000093c <i2c_lcd_put_string>:
}



// put string function
void i2c_lcd_put_string(char *s, unsigned char line){
 93c:	bf 92       	push	r11
 93e:	cf 92       	push	r12
 940:	df 92       	push	r13
 942:	ef 92       	push	r14
 944:	ff 92       	push	r15
 946:	0f 93       	push	r16
 948:	1f 93       	push	r17
 94a:	cf 93       	push	r28
 94c:	df 93       	push	r29
 94e:	8c 01       	movw	r16, r24
 950:	b6 2e       	mov	r11, r22
    int xpos=0;
    if(line == 1)
 952:	81 e0       	ldi	r24, 0x01	; 1
 954:	68 17       	cp	r22, r24
 956:	09 f4       	brne	.+2      	; 0x95a <i2c_lcd_put_string+0x1e>
 958:	5d c0       	rjmp	.+186    	; 0xa14 <i2c_lcd_put_string+0xd8>
	    i2c_lcd_write(0x80);
    else if(line == 2)
 95a:	92 e0       	ldi	r25, 0x02	; 2
 95c:	69 17       	cp	r22, r25
 95e:	09 f4       	brne	.+2      	; 0x962 <i2c_lcd_put_string+0x26>
 960:	5d c0       	rjmp	.+186    	; 0xa1c <i2c_lcd_put_string+0xe0>
	    i2c_lcd_write(0xC0);
    else if(line == 3)
 962:	e3 e0       	ldi	r30, 0x03	; 3
 964:	6e 17       	cp	r22, r30
 966:	09 f4       	brne	.+2      	; 0x96a <i2c_lcd_put_string+0x2e>
 968:	5d c0       	rjmp	.+186    	; 0xa24 <i2c_lcd_put_string+0xe8>
	    i2c_lcd_write(0x94);
    else if(line == 4)
 96a:	f4 e0       	ldi	r31, 0x04	; 4
 96c:	6f 17       	cp	r22, r31
 96e:	09 f4       	brne	.+2      	; 0x972 <i2c_lcd_put_string+0x36>
 970:	5d c0       	rjmp	.+186    	; 0xa2c <i2c_lcd_put_string+0xf0>
 972:	78 01       	movw	r14, r16
	    }
	    if( *(s+i)=='\n' && line==1){
		    i2c_lcd_write(0xC0); //Move to the next line
		    xpos=0;                
	    }else
		    i2c_lcd_write_char(*(s+i));
 974:	c0 e0       	ldi	r28, 0x00	; 0
 976:	d0 e0       	ldi	r29, 0x00	; 0
 978:	20 e0       	ldi	r18, 0x00	; 0
 97a:	30 e0       	ldi	r19, 0x00	; 0
 97c:	0b c0       	rjmp	.+22     	; 0x994 <i2c_lcd_put_string+0x58>
 97e:	69 01       	movw	r12, r18
 980:	ff ef       	ldi	r31, 0xFF	; 255
 982:	cf 1a       	sub	r12, r31
 984:	df 0a       	sbc	r13, r31
 986:	0e 94 32 04 	call	0x864	; 0x864 <i2c_lcd_write_char>
 98a:	96 01       	movw	r18, r12
    else if(line == 3)
	    i2c_lcd_write(0x94);
    else if(line == 4)
	    i2c_lcd_write(0xD4);

    for (int i = 0; i < strlen(s) && i<32; i++){
 98c:	21 96       	adiw	r28, 0x01	; 1
 98e:	ff ef       	ldi	r31, 0xFF	; 255
 990:	ef 1a       	sub	r14, r31
 992:	ff 0a       	sbc	r15, r31
 994:	f8 01       	movw	r30, r16
 996:	01 90       	ld	r0, Z+
 998:	00 20       	and	r0, r0
 99a:	e9 f7       	brne	.-6      	; 0x996 <i2c_lcd_put_string+0x5a>
 99c:	31 97       	sbiw	r30, 0x01	; 1
 99e:	e0 1b       	sub	r30, r16
 9a0:	f1 0b       	sbc	r31, r17
 9a2:	ce 17       	cp	r28, r30
 9a4:	df 07       	cpc	r29, r31
 9a6:	d8 f4       	brcc	.+54     	; 0x9de <i2c_lcd_put_string+0xa2>
 9a8:	c0 32       	cpi	r28, 0x20	; 32
 9aa:	d1 05       	cpc	r29, r1
 9ac:	c1 f0       	breq	.+48     	; 0x9de <i2c_lcd_put_string+0xa2>
	    if(xpos==16 && line==1){
 9ae:	20 31       	cpi	r18, 0x10	; 16
 9b0:	31 05       	cpc	r19, r1
 9b2:	61 f0       	breq	.+24     	; 0x9cc <i2c_lcd_put_string+0x90>
		    i2c_lcd_write(0x14); //Move to the next line
		    xpos=0;
	    }
	    if( *(s+i)=='\n' && line==1){
 9b4:	f7 01       	movw	r30, r14
 9b6:	80 81       	ld	r24, Z
 9b8:	8a 30       	cpi	r24, 0x0A	; 10
 9ba:	09 f7       	brne	.-62     	; 0x97e <i2c_lcd_put_string+0x42>
 9bc:	91 e0       	ldi	r25, 0x01	; 1
 9be:	b9 16       	cp	r11, r25
 9c0:	c1 f0       	breq	.+48     	; 0x9f2 <i2c_lcd_put_string+0xb6>
 9c2:	69 01       	movw	r12, r18
 9c4:	ef ef       	ldi	r30, 0xFF	; 255
 9c6:	ce 1a       	sub	r12, r30
 9c8:	de 0a       	sbc	r13, r30
 9ca:	dd cf       	rjmp	.-70     	; 0x986 <i2c_lcd_put_string+0x4a>
	    i2c_lcd_write(0x94);
    else if(line == 4)
	    i2c_lcd_write(0xD4);

    for (int i = 0; i < strlen(s) && i<32; i++){
	    if(xpos==16 && line==1){
 9cc:	81 e0       	ldi	r24, 0x01	; 1
 9ce:	b8 16       	cp	r11, r24
 9d0:	b1 f0       	breq	.+44     	; 0x9fe <i2c_lcd_put_string+0xc2>
		    i2c_lcd_write(0x14); //Move to the next line
		    xpos=0;
	    }
	    if( *(s+i)=='\n' && line==1){
 9d2:	f7 01       	movw	r30, r14
 9d4:	80 81       	ld	r24, Z
 9d6:	91 e1       	ldi	r25, 0x11	; 17
 9d8:	c9 2e       	mov	r12, r25
 9da:	d1 2c       	mov	r13, r1
 9dc:	d4 cf       	rjmp	.-88     	; 0x986 <i2c_lcd_put_string+0x4a>
	    }else
		    i2c_lcd_write_char(*(s+i));
	    xpos++;
    }

}
 9de:	df 91       	pop	r29
 9e0:	cf 91       	pop	r28
 9e2:	1f 91       	pop	r17
 9e4:	0f 91       	pop	r16
 9e6:	ff 90       	pop	r15
 9e8:	ef 90       	pop	r14
 9ea:	df 90       	pop	r13
 9ec:	cf 90       	pop	r12
 9ee:	bf 90       	pop	r11
 9f0:	08 95       	ret
	    if(xpos==16 && line==1){
		    i2c_lcd_write(0x14); //Move to the next line
		    xpos=0;
	    }
	    if( *(s+i)=='\n' && line==1){
		    i2c_lcd_write(0xC0); //Move to the next line
 9f2:	80 ec       	ldi	r24, 0xC0	; 192
 9f4:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
		    xpos=0;                
 9f8:	21 e0       	ldi	r18, 0x01	; 1
 9fa:	30 e0       	ldi	r19, 0x00	; 0
 9fc:	c7 cf       	rjmp	.-114    	; 0x98c <i2c_lcd_put_string+0x50>
    else if(line == 4)
	    i2c_lcd_write(0xD4);

    for (int i = 0; i < strlen(s) && i<32; i++){
	    if(xpos==16 && line==1){
		    i2c_lcd_write(0x14); //Move to the next line
 9fe:	84 e1       	ldi	r24, 0x14	; 20
 a00:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
		    xpos=0;
	    }
	    if( *(s+i)=='\n' && line==1){
 a04:	f7 01       	movw	r30, r14
 a06:	80 81       	ld	r24, Z
 a08:	8a 30       	cpi	r24, 0x0A	; 10
 a0a:	99 f3       	breq	.-26     	; 0x9f2 <i2c_lcd_put_string+0xb6>
 a0c:	cc 24       	eor	r12, r12
 a0e:	c3 94       	inc	r12
 a10:	d1 2c       	mov	r13, r1
 a12:	b9 cf       	rjmp	.-142    	; 0x986 <i2c_lcd_put_string+0x4a>

// put string function
void i2c_lcd_put_string(char *s, unsigned char line){
    int xpos=0;
    if(line == 1)
	    i2c_lcd_write(0x80);
 a14:	80 e8       	ldi	r24, 0x80	; 128
 a16:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
 a1a:	ab cf       	rjmp	.-170    	; 0x972 <i2c_lcd_put_string+0x36>
    else if(line == 2)
	    i2c_lcd_write(0xC0);
 a1c:	80 ec       	ldi	r24, 0xC0	; 192
 a1e:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
 a22:	a7 cf       	rjmp	.-178    	; 0x972 <i2c_lcd_put_string+0x36>
    else if(line == 3)
	    i2c_lcd_write(0x94);
 a24:	84 e9       	ldi	r24, 0x94	; 148
 a26:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
 a2a:	a3 cf       	rjmp	.-186    	; 0x972 <i2c_lcd_put_string+0x36>
    else if(line == 4)
	    i2c_lcd_write(0xD4);
 a2c:	84 ed       	ldi	r24, 0xD4	; 212
 a2e:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
 a32:	9f cf       	rjmp	.-194    	; 0x972 <i2c_lcd_put_string+0x36>

00000a34 <i2c_lcd_put_shifted_string>:
    }

}


void i2c_lcd_put_shifted_string(char *s, unsigned char line, unsigned int xpos){
 a34:	ef 92       	push	r14
 a36:	ff 92       	push	r15
 a38:	0f 93       	push	r16
 a3a:	1f 93       	push	r17
 a3c:	cf 93       	push	r28
 a3e:	df 93       	push	r29
    if(address == LCD_ADDRESS_DISABLED)return;
 a40:	20 91 76 00 	lds	r18, 0x0076	; 0x800076 <address>
 a44:	21 11       	cpse	r18, r1
 a46:	07 c0       	rjmp	.+14     	; 0xa56 <i2c_lcd_put_shifted_string+0x22>
    	    
    for (int i = 0; i < strlen(s) && i<32; i++){
        i2c_lcd_write_char(*(s+i));
        xpos++;
    }
}
 a48:	df 91       	pop	r29
 a4a:	cf 91       	pop	r28
 a4c:	1f 91       	pop	r17
 a4e:	0f 91       	pop	r16
 a50:	ff 90       	pop	r15
 a52:	ef 90       	pop	r14
 a54:	08 95       	ret
 a56:	8c 01       	movw	r16, r24
void i2c_lcd_put_shifted_string(char *s, unsigned char line, unsigned int xpos){
    if(address == LCD_ADDRESS_DISABLED)return;

    unsigned char row_offsets[] = {0x00, 0x40, 0x14, 0x54};
    
    i2c_lcd_write(0xC8);
 a58:	88 ec       	ldi	r24, 0xC8	; 200
 a5a:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
 a5e:	78 01       	movw	r14, r16
    	    
    for (int i = 0; i < strlen(s) && i<32; i++){
 a60:	c0 e0       	ldi	r28, 0x00	; 0
 a62:	d0 e0       	ldi	r29, 0x00	; 0
 a64:	09 c0       	rjmp	.+18     	; 0xa78 <i2c_lcd_put_shifted_string+0x44>
 a66:	c0 32       	cpi	r28, 0x20	; 32
 a68:	d1 05       	cpc	r29, r1
 a6a:	71 f3       	breq	.-36     	; 0xa48 <i2c_lcd_put_shifted_string+0x14>
        i2c_lcd_write_char(*(s+i));
 a6c:	f7 01       	movw	r30, r14
 a6e:	81 91       	ld	r24, Z+
 a70:	7f 01       	movw	r14, r30
 a72:	0e 94 32 04 	call	0x864	; 0x864 <i2c_lcd_write_char>

    unsigned char row_offsets[] = {0x00, 0x40, 0x14, 0x54};
    
    i2c_lcd_write(0xC8);
    	    
    for (int i = 0; i < strlen(s) && i<32; i++){
 a76:	21 96       	adiw	r28, 0x01	; 1
 a78:	f8 01       	movw	r30, r16
 a7a:	01 90       	ld	r0, Z+
 a7c:	00 20       	and	r0, r0
 a7e:	e9 f7       	brne	.-6      	; 0xa7a <i2c_lcd_put_shifted_string+0x46>
 a80:	31 97       	sbiw	r30, 0x01	; 1
 a82:	e0 1b       	sub	r30, r16
 a84:	f1 0b       	sbc	r31, r17
 a86:	ce 17       	cp	r28, r30
 a88:	df 07       	cpc	r29, r31
 a8a:	68 f3       	brcs	.-38     	; 0xa66 <i2c_lcd_put_shifted_string+0x32>
        i2c_lcd_write_char(*(s+i));
        xpos++;
    }
}
 a8c:	df 91       	pop	r29
 a8e:	cf 91       	pop	r28
 a90:	1f 91       	pop	r17
 a92:	0f 91       	pop	r16
 a94:	ff 90       	pop	r15
 a96:	ef 90       	pop	r14
 a98:	08 95       	ret

00000a9a <i2c_lcd_clear>:

//clear lcd and set to home
void i2c_lcd_clear(){
    if(address == LCD_ADDRESS_DISABLED)return;
 a9a:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <address>
 a9e:	81 11       	cpse	r24, r1
 aa0:	01 c0       	rjmp	.+2      	; 0xaa4 <i2c_lcd_clear+0xa>
 aa2:	08 95       	ret

    i2c_lcd_write(LCD_CLEARDISPLAY);
 aa4:	81 e0       	ldi	r24, 0x01	; 1
 aa6:	0e 94 76 03 	call	0x6ec	; 0x6ec <i2c_lcd_write>
    i2c_lcd_write(LCD_RETURNHOME);
 aaa:	82 e0       	ldi	r24, 0x02	; 2
 aac:	0c 94 76 03 	jmp	0x6ec	; 0x6ec <i2c_lcd_write>

00000ab0 <main>:
 ab0:	cf 93       	push	r28
 ab2:	df 93       	push	r29
 ab4:	cd b7       	in	r28, 0x3d	; 61
 ab6:	de b7       	in	r29, 0x3e	; 62
 ab8:	e2 97       	sbiw	r28, 0x32	; 50
 aba:	0f b6       	in	r0, 0x3f	; 63
 abc:	f8 94       	cli
 abe:	de bf       	out	0x3e, r29	; 62
 ac0:	0f be       	out	0x3f, r0	; 63
 ac2:	cd bf       	out	0x3d, r28	; 61
 ac4:	4e 01       	movw	r8, r28
 ac6:	8f e1       	ldi	r24, 0x1F	; 31
 ac8:	88 0e       	add	r8, r24
 aca:	91 1c       	adc	r9, r1
 acc:	8a e0       	ldi	r24, 0x0A	; 10
 ace:	f4 01       	movw	r30, r8
 ad0:	11 92       	st	Z+, r1
 ad2:	8a 95       	dec	r24
 ad4:	e9 f7       	brne	.-6      	; 0xad0 <main+0x20>
 ad6:	0e 94 46 01 	call	0x28c	; 0x28c <i2c_init>
 ada:	0e 94 e2 03 	call	0x7c4	; 0x7c4 <i2c_lcd_init>
 ade:	a1 2c       	mov	r10, r1
 ae0:	bb 24       	eor	r11, r11
 ae2:	b3 94       	inc	r11
 ae4:	89 e7       	ldi	r24, 0x79	; 121
 ae6:	38 2e       	mov	r3, r24
 ae8:	97 e0       	ldi	r25, 0x07	; 7
 aea:	49 2e       	mov	r4, r25
 aec:	28 e0       	ldi	r18, 0x08	; 8
 aee:	52 2e       	mov	r5, r18
 af0:	34 ea       	ldi	r19, 0xA4	; 164
 af2:	63 2e       	mov	r6, r19
 af4:	42 e2       	ldi	r20, 0x22	; 34
 af6:	74 2e       	mov	r7, r20
 af8:	20 c0       	rjmp	.+64     	; 0xb3a <main+0x8a>
 afa:	26 e0       	ldi	r18, 0x06	; 6
 afc:	a4 01       	movw	r20, r8
 afe:	62 e1       	ldi	r22, 0x12	; 18
 b00:	84 e4       	ldi	r24, 0x44	; 68
 b02:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <i2c_read>
 b06:	62 e0       	ldi	r22, 0x02	; 2
 b08:	80 e6       	ldi	r24, 0x60	; 96
 b0a:	90 e0       	ldi	r25, 0x00	; 0
 b0c:	0e 94 9e 04 	call	0x93c	; 0x93c <i2c_lcd_put_string>
 b10:	8f 8d       	ldd	r24, Y+31	; 0x1f
 b12:	98 a1       	ldd	r25, Y+32	; 0x20
 b14:	4a e0       	ldi	r20, 0x0A	; 10
 b16:	50 e0       	ldi	r21, 0x00	; 0
 b18:	be 01       	movw	r22, r28
 b1a:	6b 5e       	subi	r22, 0xEB	; 235
 b1c:	7f 4f       	sbci	r23, 0xFF	; 255
 b1e:	98 27       	eor	r25, r24
 b20:	89 27       	eor	r24, r25
 b22:	98 27       	eor	r25, r24
 b24:	0e 94 05 06 	call	0xc0a	; 0xc0a <itoa>
 b28:	60 e0       	ldi	r22, 0x00	; 0
 b2a:	ce 01       	movw	r24, r28
 b2c:	45 96       	adiw	r24, 0x15	; 21
 b2e:	0e 94 9e 04 	call	0x93c	; 0x93c <i2c_lcd_put_string>
 b32:	8a e0       	ldi	r24, 0x0A	; 10
 b34:	90 e0       	ldi	r25, 0x00	; 0
 b36:	0e 94 7f 00 	call	0xfe	; 0xfe <delay_ms>
 b3a:	a1 10       	cpse	r10, r1
 b3c:	de cf       	rjmp	.-68     	; 0xafa <main+0x4a>
 b3e:	ce 01       	movw	r24, r28
 b40:	01 96       	adiw	r24, 0x01	; 1
 b42:	0e 94 4f 01 	call	0x29e	; 0x29e <i2c_scan>
 b46:	c8 2e       	mov	r12, r24
 b48:	0e 94 4d 05 	call	0xa9a	; 0xa9a <i2c_lcd_clear>
 b4c:	61 e0       	ldi	r22, 0x01	; 1
 b4e:	88 e6       	ldi	r24, 0x68	; 104
 b50:	90 e0       	ldi	r25, 0x00	; 0
 b52:	0e 94 9e 04 	call	0x93c	; 0x93c <i2c_lcd_put_string>
 b56:	cc 20       	and	r12, r12
 b58:	61 f3       	breq	.-40     	; 0xb32 <main+0x82>
 b5a:	8e 01       	movw	r16, r28
 b5c:	0f 5f       	subi	r16, 0xFF	; 255
 b5e:	1f 4f       	sbci	r17, 0xFF	; 255
 b60:	ca 94       	dec	r12
 b62:	d1 2c       	mov	r13, r1
 b64:	ff ef       	ldi	r31, 0xFF	; 255
 b66:	cf 1a       	sub	r12, r31
 b68:	df 0a       	sbc	r13, r31
 b6a:	c0 0e       	add	r12, r16
 b6c:	d1 1e       	adc	r13, r17
 b6e:	03 c0       	rjmp	.+6      	; 0xb76 <main+0xc6>
 b70:	c0 16       	cp	r12, r16
 b72:	d1 06       	cpc	r13, r17
 b74:	f1 f2       	breq	.-68     	; 0xb32 <main+0x82>
 b76:	78 01       	movw	r14, r16
 b78:	f8 01       	movw	r30, r16
 b7a:	81 91       	ld	r24, Z+
 b7c:	8f 01       	movw	r16, r30
 b7e:	4a e0       	ldi	r20, 0x0A	; 10
 b80:	50 e0       	ldi	r21, 0x00	; 0
 b82:	be 01       	movw	r22, r28
 b84:	6b 5e       	subi	r22, 0xEB	; 235
 b86:	7f 4f       	sbci	r23, 0xFF	; 255
 b88:	90 e0       	ldi	r25, 0x00	; 0
 b8a:	0e 94 1b 06 	call	0xc36	; 0xc36 <utoa>
 b8e:	60 e0       	ldi	r22, 0x00	; 0
 b90:	ce 01       	movw	r24, r28
 b92:	45 96       	adiw	r24, 0x15	; 21
 b94:	0e 94 9e 04 	call	0x93c	; 0x93c <i2c_lcd_put_string>
 b98:	60 e0       	ldi	r22, 0x00	; 0
 b9a:	8f e6       	ldi	r24, 0x6F	; 111
 b9c:	90 e0       	ldi	r25, 0x00	; 0
 b9e:	0e 94 9e 04 	call	0x93c	; 0x93c <i2c_lcd_put_string>
 ba2:	f7 01       	movw	r30, r14
 ba4:	80 81       	ld	r24, Z
 ba6:	84 34       	cpi	r24, 0x44	; 68
 ba8:	19 f7       	brne	.-58     	; 0xb70 <main+0xc0>
 baa:	19 aa       	std	Y+49, r1	; 0x31
 bac:	ba aa       	std	Y+50, r11	; 0x32
 bae:	42 e0       	ldi	r20, 0x02	; 2
 bb0:	be 01       	movw	r22, r28
 bb2:	6f 5c       	subi	r22, 0xCF	; 207
 bb4:	7f 4f       	sbci	r23, 0xFF	; 255
 bb6:	0e 94 a0 01 	call	0x340	; 0x340 <i2c_write>
 bba:	82 e0       	ldi	r24, 0x02	; 2
 bbc:	8f a7       	std	Y+47, r24	; 0x2f
 bbe:	38 aa       	std	Y+48, r3	; 0x30
 bc0:	42 e0       	ldi	r20, 0x02	; 2
 bc2:	be 01       	movw	r22, r28
 bc4:	61 5d       	subi	r22, 0xD1	; 209
 bc6:	7f 4f       	sbci	r23, 0xFF	; 255
 bc8:	84 e4       	ldi	r24, 0x44	; 68
 bca:	0e 94 a0 01 	call	0x340	; 0x340 <i2c_write>
 bce:	4d a6       	std	Y+45, r4	; 0x2d
 bd0:	be a6       	std	Y+46, r11	; 0x2e
 bd2:	42 e0       	ldi	r20, 0x02	; 2
 bd4:	be 01       	movw	r22, r28
 bd6:	63 5d       	subi	r22, 0xD3	; 211
 bd8:	7f 4f       	sbci	r23, 0xFF	; 255
 bda:	84 e4       	ldi	r24, 0x44	; 68
 bdc:	0e 94 a0 01 	call	0x340	; 0x340 <i2c_write>
 be0:	5b a6       	std	Y+43, r5	; 0x2b
 be2:	6c a6       	std	Y+44, r6	; 0x2c
 be4:	42 e0       	ldi	r20, 0x02	; 2
 be6:	be 01       	movw	r22, r28
 be8:	65 5d       	subi	r22, 0xD5	; 213
 bea:	7f 4f       	sbci	r23, 0xFF	; 255
 bec:	84 e4       	ldi	r24, 0x44	; 68
 bee:	0e 94 a0 01 	call	0x340	; 0x340 <i2c_write>
 bf2:	b9 a6       	std	Y+41, r11	; 0x29
 bf4:	7a a6       	std	Y+42, r7	; 0x2a
 bf6:	42 e0       	ldi	r20, 0x02	; 2
 bf8:	be 01       	movw	r22, r28
 bfa:	67 5d       	subi	r22, 0xD7	; 215
 bfc:	7f 4f       	sbci	r23, 0xFF	; 255
 bfe:	84 e4       	ldi	r24, 0x44	; 68
 c00:	0e 94 a0 01 	call	0x340	; 0x340 <i2c_write>
 c04:	aa 24       	eor	r10, r10
 c06:	a3 94       	inc	r10
 c08:	b3 cf       	rjmp	.-154    	; 0xb70 <main+0xc0>

00000c0a <itoa>:
 c0a:	45 32       	cpi	r20, 0x25	; 37
 c0c:	51 05       	cpc	r21, r1
 c0e:	20 f4       	brcc	.+8      	; 0xc18 <itoa+0xe>
 c10:	42 30       	cpi	r20, 0x02	; 2
 c12:	10 f0       	brcs	.+4      	; 0xc18 <itoa+0xe>
 c14:	0c 94 10 06 	jmp	0xc20	; 0xc20 <__itoa_ncheck>
 c18:	fb 01       	movw	r30, r22
 c1a:	10 82       	st	Z, r1
 c1c:	cb 01       	movw	r24, r22
 c1e:	08 95       	ret

00000c20 <__itoa_ncheck>:
 c20:	bb 27       	eor	r27, r27
 c22:	4a 30       	cpi	r20, 0x0A	; 10
 c24:	31 f4       	brne	.+12     	; 0xc32 <__itoa_ncheck+0x12>
 c26:	99 23       	and	r25, r25
 c28:	22 f4       	brpl	.+8      	; 0xc32 <__itoa_ncheck+0x12>
 c2a:	bd e2       	ldi	r27, 0x2D	; 45
 c2c:	90 95       	com	r25
 c2e:	81 95       	neg	r24
 c30:	9f 4f       	sbci	r25, 0xFF	; 255
 c32:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <__utoa_common>

00000c36 <utoa>:
 c36:	45 32       	cpi	r20, 0x25	; 37
 c38:	51 05       	cpc	r21, r1
 c3a:	20 f4       	brcc	.+8      	; 0xc44 <utoa+0xe>
 c3c:	42 30       	cpi	r20, 0x02	; 2
 c3e:	10 f0       	brcs	.+4      	; 0xc44 <utoa+0xe>
 c40:	0c 94 26 06 	jmp	0xc4c	; 0xc4c <__utoa_ncheck>
 c44:	fb 01       	movw	r30, r22
 c46:	10 82       	st	Z, r1
 c48:	cb 01       	movw	r24, r22
 c4a:	08 95       	ret

00000c4c <__utoa_ncheck>:
 c4c:	bb 27       	eor	r27, r27

00000c4e <__utoa_common>:
 c4e:	fb 01       	movw	r30, r22
 c50:	55 27       	eor	r21, r21
 c52:	aa 27       	eor	r26, r26
 c54:	88 0f       	add	r24, r24
 c56:	99 1f       	adc	r25, r25
 c58:	aa 1f       	adc	r26, r26
 c5a:	a4 17       	cp	r26, r20
 c5c:	10 f0       	brcs	.+4      	; 0xc62 <__utoa_common+0x14>
 c5e:	a4 1b       	sub	r26, r20
 c60:	83 95       	inc	r24
 c62:	50 51       	subi	r21, 0x10	; 16
 c64:	b9 f7       	brne	.-18     	; 0xc54 <__utoa_common+0x6>
 c66:	a0 5d       	subi	r26, 0xD0	; 208
 c68:	aa 33       	cpi	r26, 0x3A	; 58
 c6a:	08 f0       	brcs	.+2      	; 0xc6e <__utoa_common+0x20>
 c6c:	a9 5d       	subi	r26, 0xD9	; 217
 c6e:	a1 93       	st	Z+, r26
 c70:	00 97       	sbiw	r24, 0x00	; 0
 c72:	79 f7       	brne	.-34     	; 0xc52 <__utoa_common+0x4>
 c74:	b1 11       	cpse	r27, r1
 c76:	b1 93       	st	Z+, r27
 c78:	11 92       	st	Z+, r1
 c7a:	cb 01       	movw	r24, r22
 c7c:	0c 94 40 06 	jmp	0xc80	; 0xc80 <strrev>

00000c80 <strrev>:
 c80:	dc 01       	movw	r26, r24
 c82:	fc 01       	movw	r30, r24
 c84:	67 2f       	mov	r22, r23
 c86:	71 91       	ld	r23, Z+
 c88:	77 23       	and	r23, r23
 c8a:	e1 f7       	brne	.-8      	; 0xc84 <strrev+0x4>
 c8c:	32 97       	sbiw	r30, 0x02	; 2
 c8e:	04 c0       	rjmp	.+8      	; 0xc98 <strrev+0x18>
 c90:	7c 91       	ld	r23, X
 c92:	6d 93       	st	X+, r22
 c94:	70 83       	st	Z, r23
 c96:	62 91       	ld	r22, -Z
 c98:	ae 17       	cp	r26, r30
 c9a:	bf 07       	cpc	r27, r31
 c9c:	c8 f3       	brcs	.-14     	; 0xc90 <strrev+0x10>
 c9e:	08 95       	ret

00000ca0 <_exit>:
 ca0:	f8 94       	cli

00000ca2 <__stop_program>:
 ca2:	ff cf       	rjmp	.-2      	; 0xca2 <__stop_program>
