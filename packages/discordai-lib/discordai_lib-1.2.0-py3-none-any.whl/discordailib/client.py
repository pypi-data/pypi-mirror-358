import aiohttp
import asyncio
import json
import base64
from typing import Optional, Union
from .models import AIModel, AIFeature

# Import discord components only when needed
try:
    import discord
    from discord.ext import commands
    DISCORD_AVAILABLE = True
except ImportError:
    DISCORD_AVAILABLE = False
    discord = None
    commands = None

class DiscordAI:
    def __init__(
        self,
        bot = None,
        model: AIModel = AIModel.DEEPSEEK,
        aifeature: AIFeature = AIFeature.TEXT_ONLY,
        prefix: str = "!",
        slash: bool = False,
        api_key: Optional[str] = None
    ):
        """
        Initialize Discord AI Library

        Args:
            bot: Discord bot instance (optional)
            model: AI model to use (deepseek, grok, openai)
            aifeature: AI features to enable (textonly, imageonly, all)
            prefix: Command prefix for text commands
            slash: Enable slash commands
            api_key: Pollination.ai API key (optional)
        """
        self.bot = bot
        self.model = model
        self.aifeature = aifeature
        self.prefix = prefix
        self.slash_enabled = slash
        self.api_key = api_key

        # API endpoints
        self.text_endpoint = "https://text.pollinations.ai"
        self.image_endpoint = "https://image.pollinations.ai/prompt"

        # Model mappings for text generation
        self.model_mapping = {
            AIModel.DEEPSEEK: "deepseek",
            AIModel.GROK: "grok-beta", 
            AIModel.OPENAI: "openai"
        }

        # Setup commands only if Discord bot is provided
        if self.bot and DISCORD_AVAILABLE:
            self._setup_commands()
        elif self.bot and not DISCORD_AVAILABLE:
            raise ImportError("Discord.py is required when using a bot instance. Install with: pip install discord.py")

    def _setup_commands(self):
        """Setup Discord commands based on configuration"""
        if not DISCORD_AVAILABLE or not self.bot:
            return

        # Text AI command
        if self.aifeature in [AIFeature.TEXT_ONLY, AIFeature.ALL]:
            @self.bot.command(name="aichat")
            async def aichat(ctx, *, prompt: str):
                await self._handle_text_command(ctx, prompt)

            if self.slash_enabled:
                @self.bot.tree.command(name="aichat", description="Chat with AI")
                async def slash_aichat(interaction, prompt: str):
                    await interaction.response.defer()

                    try:
                        response = await self._generate_text(prompt)

                        if len(response) > 2000:
                            chunks = [response[i:i+2000] for i in range(0, len(response), 2000)]
                            await interaction.followup.send(chunks[0])
                            for chunk in chunks[1:]:
                                await interaction.followup.send(chunk)
                        else:
                            await interaction.followup.send(response)
                    except Exception as e:
                        await interaction.followup.send(f"âŒ Error generating AI response: {str(e)}")

        # Image AI command
        if self.aifeature in [AIFeature.IMAGE_ONLY, AIFeature.ALL]:
            @self.bot.command(name="aiimage")
            async def aiimage(ctx, *, prompt: str):
                await self._handle_image_command(ctx, prompt)

            if self.slash_enabled:
                @self.bot.tree.command(name="aiimage", description="Generate AI image")
                async def slash_aiimage(interaction, prompt: str):
                    await interaction.response.defer()

                    try:
                        image_url = await self._generate_image(prompt)

                        if DISCORD_AVAILABLE and discord:
                            embed = discord.Embed(
                                title="ðŸŽ¨ AI Generated Image",
                                description=f"Prompt: {prompt}",
                                color=0x00ff00
                            )
                            embed.set_image(url=image_url)
                            embed.set_footer(text="Generated by Pollination.ai")

                            await interaction.followup.send(embed=embed)
                        else:
                            await interaction.followup.send(f"ðŸŽ¨ Generated image: {image_url}")
                    except Exception as e:
                        await interaction.followup.send(f"âŒ Error generating AI image: {str(e)}")

    async def _handle_text_command(self, ctx, prompt: str):
        """Handle text AI generation"""
        try:
            # Send typing indicator if available
            if hasattr(ctx, 'typing'):
                async with ctx.typing():
                    response = await self._generate_text(prompt)
            else:
                response = await self._generate_text(prompt)

            # Split long responses
            if len(response) > 2000:
                chunks = [response[i:i+2000] for i in range(0, len(response), 2000)]
                for chunk in chunks:
                    await ctx.send(chunk)
            else:
                await ctx.send(response)

        except Exception as e:
            await ctx.send(f"âŒ Error generating AI response: {str(e)}")

    async def _handle_image_command(self, ctx, prompt: str):
        """Handle image AI generation"""
        try:
            if hasattr(ctx, 'typing'):
                async with ctx.typing():
                    image_url = await self._generate_image(prompt)
            else:
                image_url = await self._generate_image(prompt)

            if DISCORD_AVAILABLE and discord:
                embed = discord.Embed(
                    title="ðŸŽ¨ AI Generated Image",
                    description=f"Prompt: {prompt}",
                    color=0x00ff00
                )
                embed.set_image(url=image_url)
                embed.set_footer(text="Generated by Pollination.ai")

                await ctx.send(embed=embed)
            else:
                await ctx.send(f"ðŸŽ¨ Generated image: {image_url}")

        except Exception as e:
            await ctx.send(f"âŒ Error generating AI image: {str(e)}")

    async def _generate_text(self, prompt: str) -> str:
        """Generate text using Pollination.ai"""
        async with aiohttp.ClientSession() as session:
            # Updated payload format for Pollination.ai
            data = {
                "messages": [
                    {"role": "user", "content": prompt}
                ],
                "model": self.model_mapping[self.model]
            }

            headers = {
                "Content-Type": "application/json"
            }

            if self.api_key:
                headers["Authorization"] = f"Bearer {self.api_key}"

            try:
                async with session.post(
                    self.text_endpoint,
                    json=data,
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as response:
                    if response.status == 200:
                        result = await response.text()
                        return result.strip()
                    else:
                        response_text = await response.text()
                        raise Exception(f"API request failed: {response.status} - {response_text}")
            except aiohttp.ClientError as e:
                raise Exception(f"Network error: {str(e)}")

    async def _generate_image(self, prompt: str) -> str:
        """Generate image using Pollination.ai Flux model"""
        # Use Flux model for high quality images without watermark
        image_url = f"{self.image_endpoint}/{prompt.replace(' ', '%20')}?model=flux&nologo=true&width=1024&height=1024"

        # Verify the image exists
        async with aiohttp.ClientSession() as session:
            try:
                async with session.head(image_url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    if response.status == 200:
                        return image_url
                    else:
                        raise Exception(f"Image generation failed with status: {response.status}")
            except aiohttp.ClientError as e:
                raise Exception(f"Image generation network error: {str(e)}")

    async def generate_text(self, prompt: str, model: str = None) -> str:
        """Generate text using AI"""
        if not self.text_enabled:
            raise ValueError("Text generation is not enabled")

        model_to_use = model or self.model.value

        # Map model to API format
        if isinstance(model_to_use, str):
            # Handle string model names
            model_map = {
                'deepseek-v3': 'deepseek',
                'grok-3-mini': 'grok-beta', 
                'gpt-4.1': 'openai'
            }
            api_model = model_map.get(model_to_use, model_to_use)
        else:
            api_model = self.model_mapping.get(self.model, 'deepseek')

        # Construct proper API URL
        params = {
            'model': api_model,
            'prompt': prompt,
            'seed': -1,
            'jsonMode': 'false'
        }

        url = f"{self.text_endpoint}?" + "&".join([f"{k}={v}" for k, v in params.items()])

        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(url, timeout=30) as response:
                    if response.status == 200:
                        text = await response.text()
                        return text.strip() if text else "Sorry, I couldn't generate a response."
                    else:
                        error_text = await response.text()
                        raise Exception(f"API request failed: {response.status} - {error_text}")
            except aiohttp.ClientTimeout:
                raise Exception("Request timed out. Please try again.")
            except Exception as e:
                raise Exception(f"Network error: {str(e)}")

    async def generate_image(self, prompt: str) -> str:
        """
        Public method to generate image (can be used without Discord bot)

        Args:
            prompt: Image prompt

        Returns:
            Image URL
        """
        return await self._generate_image(prompt)

    async def custom_text_generation(self, prompt: str, model: str) -> str:
        """Generate text with custom model"""
        # Map common model names
        model_map = {
            'gpt-4.1': 'openai',
            'deepseek': 'deepseek',
            'grok': 'grok-beta',
            'openai': 'openai'
        }

        api_model = model_map.get(model.lower(), model)

        params = {
            'model': api_model,
            'prompt': prompt,
            'seed': -1,
            'jsonMode': 'false'
        }

        url = f"{self.text_endpoint}?" + "&".join([f"{k}={v}" for k, v in params.items()])

        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(url, timeout=30) as response:
                    if response.status == 200:
                        text = await response.text()
                        return text.strip() if text else "Sorry, I couldn't generate a response."
                    else:
                        error_text = await response.text()
                        raise Exception(f"API request failed: {response.status} - {error_text}")
            except aiohttp.ClientTimeout:
                raise Exception("Request timed out. Please try again.")
            except Exception as e:
                raise Exception(f"Network error: {str(e)}")

    async def custom_image_generation(
        self, 
        prompt: str, 
        width: int = 1024, 
        height: int = 1024,
        style: str = "realistic"
    ) -> str:
        """
        Custom image generation with parameters

        Args:
            prompt: Image prompt
            width: Image width
            height: Image height
            style: Image style

        Returns:
            Image URL
        """
        encoded_prompt = prompt.replace(' ', '%20')
        image_url = f"{self.image_endpoint}/{encoded_prompt}?model=flux&nologo=true&width={width}&height={height}&style={style}"

        async with aiohttp.ClientSession() as session:
            try:
                async with session.head(image_url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    if response.status == 200:
                        return image_url
                    else:
                        raise Exception(f"Custom image generation failed with status: {response.status}")
            except aiohttp.ClientError as e:
                raise Exception(f"Custom image generation network error: {str(e)}")

    async def sync_commands(self):
        """Sync slash commands with Discord"""
        if self.slash_enabled and self.bot and DISCORD_AVAILABLE:
            try:
                synced = await self.bot.tree.sync()
                print(f"âœ… Synced {len(synced)} slash commands")
                return len(synced)
            except Exception as e:
                print(f"âŒ Failed to sync commands: {e}")
                return 0
        return 0

    def get_model_info(self) -> dict:
        """Get current configuration information"""
        return {
            "model": self.model.value,
            "features": self.aifeature.value,
            "prefix": self.prefix,
            "slash_commands": self.slash_enabled,
            "text_enabled": self.aifeature in [AIFeature.TEXT_ONLY, AIFeature.ALL],
            "image_enabled": self.aifeature in [AIFeature.IMAGE_ONLY, AIFeature.ALL],
            "discord_available": DISCORD_AVAILABLE,
            "bot_connected": self.bot is not None
        }