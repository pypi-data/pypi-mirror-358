
import discord
from discord.ext import commands
import aiohttp
import asyncio
import json
import base64
from typing import Optional, Union
from .models import AIModel, AIFeature

class DiscordAI:
    def __init__(
        self,
        bot: commands.Bot,
        model: AIModel = AIModel.DEEPSEEK,
        aifeature: AIFeature = AIFeature.TEXT_ONLY,
        prefix: str = "!",
        slash: bool = False,
        api_key: Optional[str] = None
    ):
        """
        Initialize Discord AI Library
        
        Args:
            bot: Discord bot instance
            model: AI model to use (deepseek, grok, openai)
            aifeature: AI features to enable (textonly, imageonly, all)
            prefix: Command prefix for text commands
            slash: Enable slash commands
            api_key: Pollination.ai API key (optional)
        """
        self.bot = bot
        self.model = model
        self.aifeature = aifeature
        self.prefix = prefix
        self.slash_enabled = slash
        self.api_key = api_key
        
        # Pollination.ai endpoints
        self.text_endpoint = "https://text.pollinations.ai/generate"
        self.image_endpoint = "https://image.pollinations.ai/prompt"
        
        # Model mappings
        self.model_mapping = {
            AIModel.DEEPSEEK: "deepseek-v3",
            AIModel.GROK: "grok-3-mini", 
            AIModel.OPENAI: "gpt-4.1"
        }
        
        # Setup commands
        self._setup_commands()
    
    def _setup_commands(self):
        """Setup Discord commands based on configuration"""
        
        # Text AI command
        if self.aifeature in [AIFeature.TEXT_ONLY, AIFeature.ALL]:
            @self.bot.command(name="aichat")
            async def aichat(ctx, *, prompt: str):
                await self._handle_text_command(ctx, prompt)
            
            if self.slash_enabled:
                @self.bot.tree.command(name="aichat", description="Chat with AI")
                async def slash_aichat(interaction: discord.Interaction, prompt: str):
                    await interaction.response.defer()
                    
                    try:
                        response = await self._generate_text(prompt)
                        
                        if len(response) > 2000:
                            chunks = [response[i:i+2000] for i in range(0, len(response), 2000)]
                            await interaction.followup.send(chunks[0])
                            for chunk in chunks[1:]:
                                await interaction.followup.send(chunk)
                        else:
                            await interaction.followup.send(response)
                    except Exception as e:
                        await interaction.followup.send(f"❌ Error generating AI response: {str(e)}")
        
        # Image AI command
        if self.aifeature in [AIFeature.IMAGE_ONLY, AIFeature.ALL]:
            @self.bot.command(name="aiimage")
            async def aiimage(ctx, *, prompt: str):
                await self._handle_image_command(ctx, prompt)
            
            if self.slash_enabled:
                @self.bot.tree.command(name="aiimage", description="Generate AI image")
                async def slash_aiimage(interaction: discord.Interaction, prompt: str):
                    await interaction.response.defer()
                    
                    try:
                        image_url = await self._generate_image(prompt)
                        
                        embed = discord.Embed(
                            title="🎨 AI Generated Image",
                            description=f"Prompt: {prompt}",
                            color=0x00ff00
                        )
                        embed.set_image(url=image_url)
                        embed.set_footer(text="Generated by Pollination.ai")
                        
                        await interaction.followup.send(embed=embed)
                    except Exception as e:
                        await interaction.followup.send(f"❌ Error generating AI image: {str(e)}")
    
    async def _handle_text_command(self, ctx, prompt: str):
        """Handle text AI generation"""
        try:
            # Send typing indicator
            async with ctx.typing():
                response = await self._generate_text(prompt)
                
                # Split long responses
                if len(response) > 2000:
                    chunks = [response[i:i+2000] for i in range(0, len(response), 2000)]
                    for chunk in chunks:
                        await ctx.send(chunk)
                else:
                    await ctx.send(response)
                    
        except Exception as e:
            await ctx.send(f"❌ Error generating AI response: {str(e)}")
    
    async def _handle_image_command(self, ctx, prompt: str):
        """Handle image AI generation"""
        try:
            async with ctx.typing():
                image_url = await self._generate_image(prompt)
                
                embed = discord.Embed(
                    title="🎨 AI Generated Image",
                    description=f"Prompt: {prompt}",
                    color=0x00ff00
                )
                embed.set_image(url=image_url)
                embed.set_footer(text="Generated by Pollination.ai")
                
                await ctx.send(embed=embed)
                
        except Exception as e:
            await ctx.send(f"❌ Error generating AI image: {str(e)}")
    
    async def _generate_text(self, prompt: str) -> str:
        """Generate text using Pollination.ai"""
        async with aiohttp.ClientSession() as session:
            payload = {
                "messages": [
                    {"role": "user", "content": prompt}
                ],
                "model": self.model_mapping[self.model],
                "stream": False
            }
            
            headers = {}
            if self.api_key:
                headers["Authorization"] = f"Bearer {self.api_key}"
            
            async with session.post(
                self.text_endpoint,
                json=payload,
                headers=headers
            ) as response:
                if response.status == 200:
                    data = await response.text()
                    return data.strip()
                else:
                    raise Exception(f"API request failed: {response.status}")
    
    async def _generate_image(self, prompt: str) -> str:
        """Generate image using Pollination.ai Flux model"""
        # Use Flux model for high quality images without watermark
        image_url = f"{self.image_endpoint}/{prompt}?model=flux&nologo=true&width=1024&height=1024"
        
        # Verify the image exists
        async with aiohttp.ClientSession() as session:
            async with session.head(image_url) as response:
                if response.status == 200:
                    return image_url
                else:
                    raise Exception("Image generation failed")
    
    async def custom_text_generation(self, prompt: str, custom_model: str = None) -> str:
        """
        Custom text generation with optional model override
        
        Args:
            prompt: Text prompt
            custom_model: Override default model
            
        Returns:
            Generated text response
        """
        original_model = self.model
        if custom_model:
            # Temporarily override model
            for model_enum in AIModel:
                if self.model_mapping[model_enum] == custom_model:
                    self.model = model_enum
                    break
        
        try:
            result = await self._generate_text(prompt)
            return result
        finally:
            # Restore original model
            self.model = original_model
    
    async def custom_image_generation(
        self, 
        prompt: str, 
        width: int = 1024, 
        height: int = 1024,
        style: str = "realistic"
    ) -> str:
        """
        Custom image generation with parameters
        
        Args:
            prompt: Image prompt
            width: Image width
            height: Image height
            style: Image style
            
        Returns:
            Image URL
        """
        image_url = f"{self.image_endpoint}/{prompt}?model=flux&nologo=true&width={width}&height={height}&style={style}"
        
        async with aiohttp.ClientSession() as session:
            async with session.head(image_url) as response:
                if response.status == 200:
                    return image_url
                else:
                    raise Exception("Custom image generation failed")
    
    async def sync_commands(self):
        """Sync slash commands with Discord"""
        if self.slash_enabled:
            try:
                synced = await self.bot.tree.sync()
                print(f"✅ Synced {len(synced)} slash commands")
                return len(synced)
            except Exception as e:
                print(f"❌ Failed to sync commands: {e}")
                return 0
        return 0
    
    def get_model_info(self) -> dict:
        """Get current configuration information"""
        return {
            "model": self.model.value,
            "features": self.aifeature.value,
            "prefix": self.prefix,
            "slash_commands": self.slash_enabled,
            "text_enabled": self.aifeature in [AIFeature.TEXT_ONLY, AIFeature.ALL],
            "image_enabled": self.aifeature in [AIFeature.IMAGE_ONLY, AIFeature.ALL]
        }
