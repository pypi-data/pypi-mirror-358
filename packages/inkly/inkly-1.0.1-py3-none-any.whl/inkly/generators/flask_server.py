"""Flaskサーバーコードジェネレータ"""

from __future__ import annotations

import logging
import re
from pathlib import Path
from typing import Any

from .base import CodeGenerator
from .templates import (
    FLASK_ENUM_TEMPLATE,
    FLASK_MODEL_TEMPLATE,
    FLASK_SERVICE_INTERFACE_TEMPLATE,
)

logger = logging.getLogger(__name__)


class FlaskServerGenerator(CodeGenerator):
    """FlaskサーバコードジェネレータならびにGoogle Cloud Functions対応ジェネレータ"""

    def get_templates(self) -> dict[str, str]:
        """テンプレートを返す"""
        return {
            "service_interface.py": FLASK_SERVICE_INTERFACE_TEMPLATE,
            "model.py": FLASK_MODEL_TEMPLATE,
            "enum.py": FLASK_ENUM_TEMPLATE,
        }

    def generate_to_path(
        self, output_path: str | Path, mock_response: bool = False, **kwargs: Any
    ) -> None:
        """サーバコードを生成する

        Args:
            output_path: 出力パス
            mock_response: モックレスポンスを含むかどうか
        """
        output_dir = Path(output_path)
        output_dir.mkdir(parents=True, exist_ok=True)

        try:
            # OpenAPIデータ読み込み
            endpoints = self.parser.get_endpoints()
            schemas = self.parser.get_schemas()

            logger.info(
                "Flaskサーバ生成開始: endpoints=%d, schemas=%d",
                len(endpoints),
                len(schemas),
            )

            # タグ別にエンドポイントをグループ化
            routes_by_tag: dict[str, list[dict[str, Any]]] = {}
            for endpoint in endpoints:
                for tag in endpoint.get("tags", ["default"]):
                    if tag not in routes_by_tag:
                        routes_by_tag[tag] = []
                    routes_by_tag[tag].append(endpoint)

            # modelsディレクトリとサブディレクトリを作成
            models_dir = output_dir / "models"
            models_dir.mkdir(exist_ok=True)

            requests_dir = models_dir / "requests"
            responses_dir = models_dir / "responses"
            requests_dir.mkdir(exist_ok=True)
            responses_dir.mkdir(exist_ok=True)

            # __init__.pyファイルを作成してPythonモジュールとして認識させる
            (models_dir / "__init__.py").write_text("", encoding="utf-8")
            (requests_dir / "__init__.py").write_text("", encoding="utf-8")
            (responses_dir / "__init__.py").write_text("", encoding="utf-8")
            
            # プロジェクトルートにも__init__.pyを作成してパッケージ化
            (output_dir / "__init__.py").write_text("# Flask Server Package\n# Generated by inkly v1.0.0\n\n__all__ = []\n", encoding="utf-8")
            
            # IDEで相対インポートを認識させるためのpyproject.toml作成
            pyproject_content = '''[tool.pyright]
include = ["."]
typeCheckingMode = "basic"
pythonVersion = "3.8"
pythonPlatform = "All"
executionEnvironments = [
    { root = ".", pythonVersion = "3.8" }
]

[tool.pylsp-mypy]
enabled = true
live_mode = true

[tool.mypy]
python_version = "3.8"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true

[project]
name = "flask-server"
version = "0.1.0"
description = "Generated Flask server"
requires-python = ">=3.8"

[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta"
'''
            (output_dir / "pyproject.toml").write_text(pyproject_content, encoding="utf-8")

            # OpenAPI schemas から共通モデルを生成
            common_models = self._generate_models_from_schemas(schemas)
            model_template = self.env.get_template("model.py")
            for model in common_models:
                model_file = models_dir / f"{model['name'].lower()}.py"
                model_content = model_template.render(model=model, version="1.0.0")
                formatted_content = self._fix_model_formatting(model_content)
                model_file.write_text(formatted_content, encoding="utf-8")

            # 各タグ（サービス）別にファイル生成
            for tag, tag_endpoints in routes_by_tag.items():
                # endpoint-specific models を生成
                self._generate_endpoint_models(
                    {tag: tag_endpoints}, requests_dir, responses_dir
                )

                # サービスインターフェース生成
                service_template = self.env.get_template("service_interface.py")

                # エンドポイントのパラメータに型情報を追加
                enhanced_endpoints = []
                for endpoint in tag_endpoints:
                    enhanced_endpoint = endpoint.copy()
                    # パラメータに型情報を追加
                    if "parameters" in enhanced_endpoint:
                        enhanced_params = []
                        for param in enhanced_endpoint["parameters"]:
                            enhanced_param = param.copy()
                            # スキーマから型を生成
                            param_schema = param.get("schema", {})
                            if param_schema:
                                enhanced_param["type"] = self.python_type_from_openapi(param_schema)
                            else:
                                enhanced_param["type"] = "str"  # デフォルト型
                            enhanced_params.append(enhanced_param)
                        enhanced_endpoint["parameters"] = enhanced_params
                    enhanced_endpoints.append(enhanced_endpoint)

                # リクエスト・レスポンスモデルを収集
                request_models = []
                response_models = []
                for endpoint in enhanced_endpoints:
                    # リクエストモデル
                    if endpoint.get("request_body"):
                        request_class_name = (
                            f"{self._to_pascal_case(endpoint['operation_id'])}Request"
                        )
                        request_models.append({"class_name": request_class_name})

                    # レスポンスモデル
                    response_class_name = (
                        f"{self._to_pascal_case(endpoint['operation_id'])}Response"
                    )
                    response_models.append({"class_name": response_class_name})

                # サービスファイル生成
                service_content = service_template.render(
                    tag=tag,
                    endpoints=enhanced_endpoints,
                    request_models=request_models,
                    response_models=response_models,
                    version="1.0.0",
                )

                # インターフェース名とファイル名を調整
                service_interface_name = f"{tag.lower()}_service_interface.py"
                service_file = output_dir / service_interface_name

                # 後処理でフォーマットを調整
                formatted_content = self._fix_service_formatting(service_content)
                service_file.write_text(formatted_content, encoding="utf-8")

            # 生成されたenumファイルを出力
            if hasattr(self, '_generated_enums'):
                models_dir = output_dir / "models"
                models_dir.mkdir(exist_ok=True)
                
                for filename, content in self._generated_enums.items():
                    enum_file = models_dir / filename
                    enum_file.write_text(content, encoding="utf-8")

            logger.info(f"Flaskサーバ生成完了: {output_dir}")

        except Exception as e:
            logger.error(f"Flaskサーバ生成中にエラーが発生しました: {e}")
            raise

    def _generate_models_from_schemas(
        self, schemas: dict[str, dict[str, Any]]
    ) -> list[dict[str, Any]]:
        """OpenAPIスキーマから共通モデルを生成する"""
        models = []
        for schema_name, schema_data in schemas.items():
            model_data = self._create_model_from_schema(
                schema_name, schema_data, schemas
            )
            if model_data:
                models.append(model_data)
        return models

    def _generate_endpoint_models(
        self,
        routes_by_tag: dict[str, list[dict[str, Any]]],
        requests_dir: Path,
        responses_dir: Path,
    ) -> None:
        """エンドポイント専用のリクエスト・レスポンスモデルを生成する"""
        model_template = self.env.get_template("model.py")

        for tag, endpoints in routes_by_tag.items():
            for endpoint in endpoints:
                # リクエストモデル生成
                if endpoint.get("request_body"):
                    request_fields = self._extract_request_fields(endpoint)
                    if request_fields:
                        request_model = {
                            "name": f"{self._to_pascal_case(endpoint['operation_id'])}Request",
                            "description": f"Request model for {endpoint['operation_id']}",
                            "fields": request_fields,
                            "enums": [],
                        }

                        # リクエストモデルファイル生成
                        request_filename = (
                            f"{self._to_snake_case(endpoint['operation_id'])}_request.py"
                        )
                        request_content = model_template.render(
                            model=request_model, version="1.0.0"
                        )
                        formatted_request_content = self._fix_model_formatting(request_content)
                        request_file = requests_dir / request_filename
                        request_file.write_text(formatted_request_content, encoding="utf-8")

                # レスポンスモデル生成
                response_fields = self._extract_response_fields(endpoint)
                if response_fields:
                    response_model = {
                        "name": f"{self._to_pascal_case(endpoint['operation_id'])}Response",
                        "description": f"Response model for {endpoint['operation_id']}",
                        "fields": response_fields,
                        "enums": [],
                    }

                    # レスポンスモデルファイル生成
                    response_filename = (
                        f"{self._to_snake_case(endpoint['operation_id'])}_response.py"
                    )
                    response_content = model_template.render(
                        model=response_model, version="1.0.0"
                    )
                    formatted_response_content = self._fix_model_formatting(response_content)
                    response_file = responses_dir / response_filename
                    response_file.write_text(formatted_response_content, encoding="utf-8")

    def _extract_request_fields(self, endpoint: dict[str, Any]) -> list[dict[str, Any]]:
        """エンドポイントからリクエストフィールドを抽出する"""
        fields = []

        # パスパラメータとクエリパラメータを取得
        for param in endpoint.get("parameters", []):
            param_type = "str"
            param_schema = param.get("schema", {})
            if param_schema:
                param_type = self.python_type_from_openapi(param_schema)

            fields.append(
                {
                    "name": param["name"],
                    "type": param_type,
                    "description": param.get("description", ""),
                }
            )

        # リクエストボディのフィールドを取得
        request_body = endpoint.get("request_body")
        if request_body:
            content = request_body.get("content", {})
            json_content = content.get("application/json", {})
            schema = json_content.get("schema", {})

            if schema:
                if "$ref" in schema:
                    # $ref の場合はスキーマ名のみ記録
                    ref_name = schema["$ref"].split("/")[-1]
                    fields.append(
                        {
                            "name": "data",
                            "type": ref_name,
                            "description": "Request data",
                        }
                    )
                elif schema.get("type") == "object":
                    # オブジェクトの場合は各プロパティを展開
                    properties = schema.get("properties", {})
                    required = schema.get("required", [])

                    for field_name, field_schema in properties.items():
                        field_type = self.python_type_from_openapi(field_schema, field_name)
                        if field_name not in required:
                            field_type = f"{field_type} | None = None"

                        fields.append(
                            {
                                "name": field_name,
                                "type": field_type,
                                "description": field_schema.get("description", ""),
                            }
                        )

        return fields

    def _extract_response_fields(
        self, endpoint: dict[str, Any]
    ) -> list[dict[str, Any]]:
        """エンドポイントからレスポンスフィールドを抽出する"""
        fields = []

        responses = endpoint.get("responses", {})

        # 成功レスポンス（2xx）を探す
        success_response = None
        for status_code, response in responses.items():
            if str(status_code).startswith("2"):
                success_response = response
                break

        if not success_response:
            # 成功レスポンスがない場合はデフォルトの成功レスポンス
            fields.append(
                {
                    "name": "message",
                    "type": "str",
                    "description": "Success message",
                }
            )
            return fields

        content = success_response.get("content", {})
        json_content = content.get("application/json", {})
        schema = json_content.get("schema", {})

        if not schema:
            # スキーマがない場合はデフォルトの成功レスポンス
            fields.append(
                {
                    "name": "message",
                    "type": "str",
                    "description": "Success message",
                }
            )
            return fields

        # $ref参照を解決
        if "$ref" in schema:
            ref_name = schema["$ref"].split("/")[-1]
            # $refの場合はスキーマ名をそのまま使用
            fields.append(
                {
                    "name": "data",
                    "type": ref_name,
                    "description": "Response data",
                }
            )
            return fields

        # 配列の場合
        if schema.get("type") == "array":
            items = schema.get("items", {})
            if "$ref" in items:
                ref_name = items["$ref"].split("/")[-1]
                fields.append(
                    {
                        "name": "data",
                        "type": f"list[{ref_name}]",
                        "description": "List of items",
                    }
                )
            else:
                item_type = self.python_type_from_openapi(items)
                fields.append(
                    {
                        "name": "data",
                        "type": f"list[{item_type}]",
                        "description": "List of items",
                    }
                )
            return fields

        # オブジェクトの場合
        if schema.get("type") == "object":
            properties = schema.get("properties", {})
            required = schema.get("required", [])

            for field_name, field_schema in properties.items():
                field_type = self.python_type_from_openapi(field_schema, field_name)
                if field_name not in required:
                    field_type = f"{field_type} | None = None"

                fields.append(
                    {
                        "name": field_name,
                        "type": field_type,
                        "description": field_schema.get("description", ""),
                    }
                )
            return fields

        # プリミティブ型の場合
        if schema.get("type") in ["string", "integer", "boolean", "number"]:
            python_type = self.python_type_from_openapi(schema)
            fields.append(
                {
                    "name": "result",
                    "type": python_type,
                    "description": "Operation result",
                }
            )
            return fields

        # デフォルトケース
        fields.append(
            {
                "name": "data",
                "type": "dict[str, Any]",
                "description": "Response data",
            }
        )

        return fields

    def _create_model_from_schema(
        self,
        model_name: str,
        schema: dict[str, Any],
        all_schemas: dict[str, dict[str, Any]],
    ) -> dict[str, Any] | None:
        """スキーマからモデルデータを作成する"""
        # $ref参照の場合は解決
        if "$ref" in schema:
            ref_name = schema["$ref"].split("/")[-1]
            if ref_name in all_schemas:
                return self._create_model_from_schema(
                    ref_name, all_schemas[ref_name], all_schemas
                )
            return None

        # 独立したenum schemaの場合の処理
        if "enum" in schema and schema.get("type") in ["string", "integer"]:
            self._process_standalone_enum(model_name, schema)
            return None  # enumは独立ファイルで生成されるため、モデルデータは返さない

        # オブジェクト型でない場合はスキップ
        if schema.get("type") != "object" or "properties" not in schema:
            return None

        fields = []
        properties = schema.get("properties", {})
        required = schema.get("required", [])

        # enumを検出してenumファイル作成データを生成
        enums_data = []
        enum_template = self.env.get_template("enum.py")

        for field_name, field_schema in properties.items():
            if "enum" in field_schema:
                enum_name = f"{field_name.capitalize()}Enum"
                enum_values = []
                for enum_value in field_schema["enum"]:
                    if isinstance(enum_value, str):
                        value_name = (
                            enum_value.upper().replace(" ", "_").replace("-", "_")
                        )
                        enum_values.append(
                            {"name": value_name, "value": f'"{enum_value}"'}
                        )
                    else:
                        value_name = f"VALUE_{enum_value}"
                        enum_values.append(
                            {"name": value_name, "value": str(enum_value)}
                        )

                enum_data = {
                    "name": enum_name,
                    "description": field_schema.get(
                        "description", f"{field_name} enum values"
                    ),
                    "values": enum_values,
                }
                enums_data.append(enum_data)

                # enumファイルを生成して保存
                enum_filename = f"{self._to_snake_case(enum_name)}.py"
                # Jinjaテンプレートからenum内容を生成
                from jinja2 import Template
                template = Template(FLASK_ENUM_TEMPLATE)
                enum_content = template.render(
                    version="1.0.0",
                    enum={"name": enum_name, "description": enum_data["description"], "values": enum_data["values"]}
                )
                
                # enumファイル生成データを保存（後でまとめて出力）
                self._generated_enums = getattr(self, '_generated_enums', {})
                self._generated_enums[enum_filename] = enum_content

        for field_name, field_schema in properties.items():
            field_type = self.python_type_from_openapi(field_schema, field_name)

            # 必須でないフィールドはOptionalにする
            if field_name not in required:
                field_type = f"{field_type} | None = None"

            fields.append(
                {
                    "name": field_name,
                    "type": field_type,
                    "description": field_schema.get("description", ""),
                }
            )

        return {
            "name": model_name,
            "description": schema.get("description", f"{model_name} data model"),
            "fields": fields,
            "enums": enums_data,
        }

    def _to_snake_case(self, camel_str: str) -> str:
        """キャメルケースをスネークケースに変換する"""
        # 連続する大文字（例：XMLParser）も適切に処理
        s1 = re.sub(r'([A-Z]+)([A-Z][a-z])', r'\1_\2', camel_str)
        # 小文字+数字の後に大文字（例：version2A → version2_A）
        s2 = re.sub(r'([a-z\d])([A-Z])', r'\1_\2', s1)
        return s2.lower()

    def _to_pascal_case(self, snake_str: str) -> str:
        """スネークケースをPascalCaseに変換する"""
        # 最初にキャメルケースからスネークケースに変換
        snake_str = self._to_snake_case(snake_str)
        # アンダースコアで分割してタイトルケースに変換
        parts = snake_str.split("_")
        return "".join(word.capitalize() for word in parts)

    def _fix_service_formatting(self, content: str) -> str:
        """サービスファイルの書式を調整する"""
        # 余計な空行や改行を調整
        lines = content.split("\n")
        cleaned_lines = []

        for line in lines:
            # 空白のみの行を除去
            if line.strip():
                cleaned_lines.append(line)
            elif cleaned_lines and cleaned_lines[-1].strip():
                # 前の行が空でない場合のみ空行を追加
                cleaned_lines.append("")

        return "\n".join(cleaned_lines)

    def _fix_model_formatting(self, content: str) -> str:
        """モデルファイルのフィールド改行問題を修正する"""
        import re
        
        # 行を解析して連結されたフィールドを分離し、正しいインデントを適用
        lines = content.split('\n')
        fixed_lines = []
        in_class_body = False
        class_indent = ""
        
        for line in lines:
            # クラス定義の検出
            if re.match(r'^class\s+\w+', line):
                in_class_body = True
                class_indent = "    "  # クラス内のフィールドは4つのスペースでインデント
                fixed_lines.append(line)
                continue
            
            # フィールド定義の行を特定
            if in_class_body and re.match(r'\s*\w+:', line.strip()):
                # 複数のフィールドが連結されているかチェック
                field_parts = re.split(r'\s{4,}(?=\w+:)', line.strip())
                
                if len(field_parts) > 1:
                    # 連結されたフィールドを分離
                    for part in field_parts:
                        if part.strip() and ':' in part:
                            fixed_lines.append(f"{class_indent}{part.strip()}")
                else:
                    # 単一フィールドの場合、正しいインデントを適用
                    if line.strip():
                        fixed_lines.append(f"{class_indent}{line.strip()}")
                    else:
                        fixed_lines.append(line)
            else:
                fixed_lines.append(line)
                # クラス以外の定義が始まったらクラス内フラグをリセット
                if line.strip() and not line.startswith(' ') and not line.startswith('\t') and 'class ' not in line:
                    in_class_body = False
        
        # ファイル末尾に空白行を追加
        result = '\n'.join(fixed_lines)
        if not result.endswith('\n'):
            result += '\n'
        
        return result

    def _process_standalone_enum(self, enum_name: str, schema: dict[str, Any]) -> None:
        """独立したenum schemaを処理してenumファイルを生成する"""
        enum_values = []
        for enum_value in schema["enum"]:
            if isinstance(enum_value, str):
                value_name = (
                    enum_value.upper().replace(" ", "_").replace("-", "_")
                )
                enum_values.append(
                    {"name": value_name, "value": f'"{enum_value}"'}
                )
            else:
                value_name = f"VALUE_{enum_value}"
                enum_values.append(
                    {"name": value_name, "value": str(enum_value)}
                )

        enum_data = {
            "name": enum_name,
            "description": schema.get("description", f"{enum_name} enum values"),
            "values": enum_values,
        }

        # enumファイルを生成して保存
        enum_filename = f"{self._to_snake_case(enum_name)}.py"
        
        # Jinjaテンプレートからenum内容を生成
        from jinja2 import Template
        template = Template(FLASK_ENUM_TEMPLATE)
        enum_content = template.render(
            version="1.0.0",
            enum={"name": enum_name, "description": enum_data["description"], "values": enum_data["values"]}
        )
        
        # enumファイル生成データを保存（後でまとめて出力）
        self._generated_enums = getattr(self, '_generated_enums', {})
        self._generated_enums[enum_filename] = enum_content
