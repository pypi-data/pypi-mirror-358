import base64
import hashlib
import hmac
import logging
import time
import uuid
from urllib.parse import quote, urlparse

from ..errors import AuthError

logger = logging.getLogger(__name__)


class AuthHandler:
    """Handles the authentication operations."""

    def __init__(
        self,
        consumer_key: str | None,
        consumer_secret: str | None,
        access_token: str | None,
        access_token_secret: str | None,
    ) -> None:
        """Initialize the auth handler instance.

        Args:
            consumer_key (str | None): X API consumer key. Defaults to
                None.
            consumer_secret (str | None): X API consumer secret.
                Defaults to None.
            access_token (str | None): X API access token. Defaults to None.
            access_token_secret (str | None): X API access token
                secret. Defaults to None.

        Raises:
            AuthError: If all API keys are not present.
        """
        if not all([consumer_key, consumer_secret, access_token, access_token_secret]):
            raise AuthError("All API credentials must be provided.")

        # Converting the API key values to strings for consistency purposes
        self._consumer_key = str(consumer_key)
        self._consumer_secret = str(consumer_secret)
        self._access_token = str(access_token)
        self._access_token_secret = str(access_token_secret)

        self._base_parameters = {
            "oauth_consumer_key": self._consumer_key,
            "oauth_signature_method": "HMAC-SHA1",
            "oauth_token": self._access_token,
            "oauth_version": "1.0",
        }

        logger.debug("Auth handler instance has been initialized.")

    def _create_nonce(self) -> str:
        """Generate a string with 32 random alphanumeric characters.

        Returns:
            str: A string value with 32 random alphanumeric characters.
        """
        return str(uuid.uuid4()).replace("-", "")

    def _create_parameter_str(self, parameters: dict[str, str]) -> str:
        """Encode parameters into a string for an OAuth signature.

        Args:
            parameters (Dict[str, str]): A dictionary with all the
                parameters included in the request.

        Returns:
            str: A string containing the encoded paramemter items.
        """
        encoded_parameters = {
            quote(k, safe=""): quote(str(v), safe="") for k, v in parameters.items()
        }
        sorted_parameters = sorted(encoded_parameters.items())
        parameter_str = "&".join([f"{k}={v}" for k, v in sorted_parameters])

        return parameter_str

    def _create_signature(
        self, http_method: str, base_url: str, parameters: dict[str, str]
    ) -> str:
        """Create an oauth signature with specific request elements.

        Args:
            http_method (str): The method of the HTTP request.
            base_url (str): The base URL of the API endpoint.
            parameters (Dict[str, str]): A dictionary with all the
                parameters included in the request.

        Returns:
            str: A string containing a value which is generated by
                running all of the other request parameters and two
                secret values through a signing algorithm
        """
        parameter_str = self._create_parameter_str(parameters)

        signature_base_str = (
            f"{http_method}&{quote(base_url, safe='')}&{quote(parameter_str, safe='')}"
        )
        logger.debug("OAuth signature base string: %s", signature_base_str)

        signing_key = (
            f"{quote(self._consumer_secret, safe='')}&"
            f"{quote(self._access_token_secret, safe='')}"
        )

        # Calculate signature
        signing_key_bytes = signing_key.encode("UTF-8")
        signature_base_str_bytes = signature_base_str.encode("UTF-8")

        h = hmac.new(signing_key_bytes, signature_base_str_bytes, hashlib.sha1)
        raw_signature_bytes = h.digest()
        oauth_signature = base64.b64encode(raw_signature_bytes).decode("utf-8")

        return oauth_signature

    def _create_authorization_str(self, parameters: dict[str, str]) -> str:
        """Create a string for authenticating requests to X's API.

        Args:
            parameters (Dict[str, str]): A dictionary with all the
                parameters needed to authenticate a request.

        Returns:
            str: A string containing a value which is used to
                authenticate a request.
        """
        auth_str_builder = [
            f'{quote(k, safe="")}="{quote(str(v), safe="")}"'
            for k, v in parameters.items()
        ]
        return "OAuth " + ", ".join(auth_str_builder)

    def sign_request(
        self, http_method: str, url: str, params_for_signature: dict[str, str]
    ) -> str:
        """Sign a request to X's API with authentication.

        Args:
            http_method (str): The method of the HTTP request.
            url (str): The base URL of the API endpoint.
            params_for_signature (Dict[str, str]): A dictionary with all the
                parameters included in the request.

        Returns:
            str: A string containing a value which is used to
                authenticate a request.
        """
        logger.debug("Attempting to sign request for %s %s", http_method, url)

        # Parse the URL
        parsed_url = urlparse(url)
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"

        # Create nonce and timestamp for this request
        oauth_nonce = self._create_nonce()
        oauth_timestamp = str(int(time.time()))

        # Create oauth signature for this request
        parameters = {
            **self._base_parameters,
            **params_for_signature,
            "oauth_nonce": oauth_nonce,
            "oauth_timestamp": oauth_timestamp,
        }
        oauth_signature = self._create_signature(http_method, base_url, parameters)

        # Create authorization string for this request
        parameters = {
            **self._base_parameters,
            "oauth_nonce": oauth_nonce,
            "oauth_timestamp": oauth_timestamp,
            "oauth_signature": oauth_signature,
        }
        auth_str = self._create_authorization_str(parameters)

        logger.debug("Successfully generated Authorization header.")
        return auth_str
