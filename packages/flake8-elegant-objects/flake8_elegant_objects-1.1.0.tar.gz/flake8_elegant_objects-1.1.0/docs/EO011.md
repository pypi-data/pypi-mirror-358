# Elegant Objects: No Public Methods Without Contracts in Python

## Overview

In Elegant Objects, the principle "He Works by Contracts" states that every public method in a good object should implement a counterpart from an interface. This ensures that objects are mockable, extendable through decoration, and follow the contract-based design.

## Python Adaptation

Python doesn't have interfaces like Java, but we can achieve the same principle using:

1. **Protocols** (PEP 544, Python 3.8+)
2. **Abstract Base Classes (ABCs)**
3. **Type hints with structural subtyping**

## What This Principle Checks

The linter will flag as violations (EO011):

- Public methods that are not defined in any Protocol or ABC
- Public methods in classes that don't implement any contract
- Additional public methods beyond what the contract specifies

## What Is Allowed

- Private methods (starting with `_`) don't need contracts
- Protected methods (starting with `_`) don't need contracts
- Special/magic methods (`__init__`, `__str__`, etc.) don't need contracts
- All public methods that are defined in the implemented Protocol/ABC

## Examples

### ❌ Bad: No Contract

```python
class HTTPStatus:  # Violates EO principle
    def read(self) -> int:  # EO011: Public method without contract
        return 200
```

### ✅ Good: Using Protocol

```python
from typing import Protocol

class StatusProtocol(Protocol):
    def read(self) -> int: ...

class HTTPStatus(StatusProtocol):  # Good: Implements contract
    def read(self) -> int:  # OK: Method from StatusProtocol
        return 200
```

### ✅ Good: Using ABC

```python
from abc import ABC, abstractmethod

class StatusABC(ABC):
    @abstractmethod
    def read(self) -> int:
        pass

class HTTPStatus(StatusABC):  # Good: Implements contract
    def read(self) -> int:  # OK: Method from StatusABC
        return 200
```

### ❌ Bad: Extra Public Methods

```python
class HTTPStatus(StatusProtocol):
    def read(self) -> int:  # OK: From contract
        return 200

    def reset(self) -> None:  # EO011: Not in contract!
        pass
```

### ✅ Good: Private Methods Are OK

```python
class HTTPStatus(StatusProtocol):
    def read(self) -> int:  # OK: From contract
        return self._fetch_status()

    def _fetch_status(self) -> int:  # OK: Private method
        return 200
```

## Benefits in Python

1. **Testability**: Classes with contracts are easy to mock

   ```python
   def test_client(status: StatusProtocol):
       assert status.read() == 200
   ```

2. **Decoration**: Contract-based objects can be decorated

   ```python
   class CachedStatus(StatusProtocol):
       def __init__(self, origin: StatusProtocol):
           self._origin = origin
           self._cache = None

       def read(self) -> int:
           if self._cache is None:
               self._cache = self._origin.read()
           return self._cache
   ```

3. **Type Safety**: IDEs and type checkers can verify implementations

4. **Documentation**: Contracts serve as clear API documentation

## Best Practices

1. **Name your protocols/ABCs clearly**: Use suffixes like `Protocol`, `ABC`, or `Interface`
2. **Keep contracts small**: Follow the Interface Segregation Principle
3. **Use Protocol for duck typing**: When you want structural subtyping
4. **Use ABC for inheritance**: When you want nominal subtyping with shared behavior
5. **Document contracts**: Add docstrings to protocol methods

## Configuration

To disable this check in your project:

```ini
# .flake8
[flake8]
ignore = EO011
```

Or inline:

```python
def public_method(self):  # noqa: EO011
    pass
```

## Note on Python's Philosophy

This principle might seem to conflict with Python's "duck typing" philosophy. However, modern Python encourages explicit contracts through type hints and protocols. This principle helps create more maintainable, testable, and type-safe code while still allowing Python's flexibility through protocols.
