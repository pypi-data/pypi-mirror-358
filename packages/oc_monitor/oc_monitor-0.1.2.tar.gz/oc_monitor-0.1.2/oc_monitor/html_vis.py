import json

class ReportVisualiser:
    
    """
    A class for converting JSON monitoring reports into an HTML report using a predefined HTML template.

    :param json_file: The file path to the JSON report generated by MetaMonitor or IndexMonitor.
    :type json_file: str
    :param template_file: The file path to the HTML template used for rendering the report.
    :type template_file: str
    :param output_html_file: The file path where the generated HTML report will be saved.
    :type output_html_file: str

    :ivar data: The parsed content of the JSON report.
    :ivar html_template: The loaded HTML template used for generating the report.
    :ivar output_html_file: The file path where the generated HTML report will be written.
    """

    def __init__(self, json_file, template_file, output_html_file):

        """
        Initializes the ReportVisualiser with paths to the JSON report, HTML template, and output HTML file.

        :param json_file: The file path to the JSON report generated by MetaMonitor or IndexMonitor.
        :type json_file: str
        :param template_file: The file path to the HTML template used for rendering the report.
        :type template_file: str
        :param output_html_file: The file path where the generated HTML report will be saved.
        :type output_html_file: str
        """

        self.json_file = json_file
        self.template_file = template_file
        self.output_html_file = output_html_file
        with open(self.json_file, 'r', encoding='utf-8') as in_file:
            self.data = json.load(in_file)
        with open(self.template_file, 'r') as file:
            self.html_template = file.read()


    def generate_table_rows(self):
        """
        Generates HTML table rows for the monitoring results from the JSON report.
        
        The table includes information such as:

        - Test label
        - Test description
        - Whether the test passed or failed
        - The running time for each test
        - Any errors encountered during test execution

        :return: A string containing the HTML table rows for the monitoring results.
        :rtype: str
        """
        
        monitoring_results_rows = ""
        for entry in self.data.get('monitoring_results', []):
            error_message = f"<span class='error'>{entry['run']['error']}</span>" if entry['run']['error'] else "<span class='null'>-</span>"
            
            if entry.get('passed') is True:
                passed_status = f"<span class='passed'>Passed</span>"
            elif entry.get('passed') is False:
                passed_status = f"<span class='failed'>Failed</span>"
            else:
                passed_status = f"<span class='null'>-</span>"

            if entry.get('count') is not None:
                count = f"{int(entry['count']):,}"  # the query expected a count as result, which can be a positive integer or zero
            else:
                count = '<span class="null">-</span>'  # either the query did not include a count or the query execution failed

            monitoring_results_rows += f"""
                <tr>
                    <td>{entry['label']}</td>
                    <td>{entry['description']}</td>
                    <td>{passed_status}</td>
                    <td>{count}</td>
                    <td>{round(entry['run']['running_time'], 3)}</td>
                    <td>{error_message}</td>
                </tr>"""
        
        return monitoring_results_rows

    def generate_html(self):
        """
        Generates the HTML report by inserting the monitoring data into the HTML template.

        The method populates placeholders in the template with actual data from the JSON report, such as:

        - The name of the monitored collection (Meta or Index)
        - The SPARQL endpoint URL
        - The date and time of the report generation
        - The total running time of the tests
        - The results of the individual monitoring tests in a table format

        The HTML report is then written to the specified output file.

        :raises: Exception if there is an error writing the HTML file.
        """

        # Replace placeholders in the HTML template with actual data
        html_out = self.html_template.replace("{{collection}}", self.data.get('collection', ''))
        html_out = html_out.replace("{{endpoint}}", f'<a href="url">{self.data.get("endpoint", "")}</a>')
        html_out = html_out.replace("{{datetime}}", self.data.get('datetime', ''))
        html_out = html_out.replace("{{running_time}}", str(round(self.data.get('running_time', 0), 3)))
        html_out = html_out.replace("{{monitoring_results_rows}}", self.generate_table_rows())

        try:
            with open(self.output_html_file, "w") as file:
                file.write(html_out)
            print(f"HTML report generated successfully: {self.output_html_file}")
        except Exception as e:
            print(f"Error writing HTML report: {e}")

