r'''
# SSM Document CDK

This library provides a code-based utility for implementing SSM Documents. The SSM Document objects can be used to print YAML/JSON documents and to mimic document processing locally.

This library abstracts SSM Documents at a high level, with each step as well as the document itself being objects. The properties needed to build these objects correlate to the settings that apply to them, making them simple to make.
This library can be used to test your document locally before deploying it to SSM.

Since the library is written in JSII, it can be exported to other languages that support JSII (Java, Python).

This is what you'd use if you wanted to:

1. The ability to test without deploying resources or executing an actual SSM on AWS.
2. Reusability of steps between documents by reusing existing items
3. Create logical higher-level groupings of reusable groups of steps ("Patterns")
4. Simple to use interface for writing documents
5. Import existing documents from a file (or string) and mimic them locally to test them.

## Usage

### Document Creation

Typescript usage (Execute AWS API Step)...
The below creates the AutomationDocument in an AWS CDK stack.

```python
import { AutomationDocument } from './automation-document';

export class HelloWorld extends Stack {
  constructor(app: Construct, id: string) {
    super(app, id);

    // Create AutomationDocument
    const myDoc = new AutomationDocument(this, "MyDoc", {
      documentFormat: DocumentFormat.JSON,
      documentName: "MyDoc",
      docInputs: [Input.ofTypeString('MyInput', { defaultValue: 'a' })],
    });

    // Define your steps...
    myDoc.addStep(new PauseStep(this, "MyPauseStep", {
      name: "MyPauseStep",
      explicitNextStep: StepRef.fromName("step1") // Optional (will default to next added step)
    }));

    myDoc.addStep(new ExecuteScriptStep(this, "MyExecuteStep", {
      name: "step1",
      language: ScriptLanguage.python(PythonVersion.VERSION_3_11, 'my_func'),
      code: ScriptCode.fromFile(resolve("test/test_file.py")),
      // OR ScriptCode.inline("def my_func(args, context):\n  return {'MyReturn': args['MyInput'] + '-suffix'}\n"),
      outputs: [{
        outputType: DataTypeEnum.STRING,
        name: "MyFuncOut",
        selector: "$.Payload.MyReturn"
      }],
      onFailure: OnFailure.abort(),
      inputPayload: { MyInput: StringVariable.of('MyInput') },
    }));
  }
}
```

### Document JSON/YAML Export as YAML/JSON

You can deploy the above document using CDK.
To print the above document object as a JSON (or YAML), do the following:

```python
const myDocJson = myDoc.print(); // Print YAML by setting the documentFormat to YAML
```

### Document Simulation

To run the document object in simulation mode, use the below. Simulation mode does NOT hit the SSM API, rather it mimics the execution that will happen in an SSM execution. The run happens locally and allows you to mock the calls to external services (AWS APIs for example) or to invoke those services using your local credentials.

```python
import { Simulation } from './simulation';

const myDocJson = Simulation.ofAutomation(myDoc, {}).simulate({ MyInput: "FooBar" });
```

### Command Documents

Below is an example of how to use the library to create Command documents.
Simulation for command documents is not yet supported for all command plugins.
You can use a Docker image/container as a playground for testing the Command document execution for the supported plugins.

In this example there is a complete CDK stack. Notice that the `CommandDocument` is saved as a field so that it can be tested from the test code.

```python
export class HelloCdkStack extends Stack {
  readonly myCommandDoc: CommandDocument;
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);
    this.myCommandDoc = new CommandDocument(this, "MyCommandDoc", {
      docInputs: [Input.ofTypeString('FirstCommand', { defaultValue: 'a' })],
    })
    const runScriptStep = new RunShellScriptStep(this, "MyShellScript", {
      runCommand: [
        StringVariable.of("FirstCommand"),
        HardCodedString.of("mkdir asdf"),
      ],
    });
    this.myCommandDoc.addStep(runScriptStep);
  }
}
```

Below is an example of how you would run a simulation against the above `CommandDocument`.

Currently, `bash` must be available in the container or the executions against the docker will not succeed.

```python
test('Test command doc', () => {
  const app = new cdk.App();
  const stack = new HelloCdk.HelloCdkStack(app, 'MyTestStack');
  // 1. $ docker pull amazonlinux
  // 2. $ docker run -di amazonlinux
  const simulation = Simulation.ofCommand(stack.myCommandDoc, {
    simulationPlatform: Platform.LINUX,
    environment: DockerEnvironment.fromContainer('MY_CONTAINER_ID')
  });
  simulation.simulate({FirstCommand: 'mkdir foobar'})
  // 3. The document should run the first command (create 'foobar') and create file 'asdf'
  // 4. $ docker exec -it <container name> bash
  // 5. Ensure that 'asdf' and 'foobar' were written to /tmp
});
```

## Patterns (High-Level Constructs)

In typical CDK style, you can assemble often used groups of steps into higher level Constructs.

Consider if you typically create AutomationDocuments that start with logging the time and end with logging the total time taken. You can create a high-level Automation Document and extend that when you implement an Automation.

See the `TimedDocument` class to see such implementation.

Or consider the case of multiple steps that are always run together such as rebooting and instance and waiting for it to be active.

The below example is copied from the `RebootInstanceAndWait` class:

```python
export class RebootInstanceAndWait extends CompositeAutomationStep {

  readonly reboot: AwsApiStep;
  readonly describe: WaitForResourceStep;

  constructor(scope: Construct, id: string, instanceId: IStringVariable) {
    super(scope, id);
    this.reboot = new AwsApiStep(this, 'RebootInstances', {
      service: AwsService.EC2,
      pascalCaseApi: 'RebootInstances',
      apiParams: { InstanceIds: [instanceId] },
      outputs: [],
    });
    this.describe = new WaitForResourceStep(this, 'DescribeInstances', {
      service: AwsService.EC2,
      pascalCaseApi: 'DescribeInstances',
      apiParams: { InstanceIds: [instanceId] },
      selector: '$.Reservations[0].Instances[0].State.Name',
      desiredValues: ['running'],
    });
  }

  addToDocument(doc: AutomationDocumentBuilder): void {
    doc.addStep(this.reboot);
    doc.addStep(this.describe);
  }
}
```

Now, you can use `RebootInstanceAndWait` as a step in a document and the child steps will be included.

## Existing Documents

Do you have an existing document that you want to convert to code and/or test locally using the simulation?

### Import Existing Document

Here is an example of how you can import an existing document and then simulate it locally with mocked AWS resources:

```python
// Initialize Mocks
const sleeper = new MockSleep();
const awsInvoker = new MockAwsInvoker();
awsInvoker.whenThen(
    // when invoked with...
    {awsApi: 'listBuckets', awsParams: {}, service: AwsService.S3},
    // then response with...
    {Owner: {ID: "BUCKET_ID"}})

// ======> Create document from file <=======
const stack: Stack = new Stack();
const myAutomationDoc = StringDocument.fromFile(stack, "MyAutomationDoc", 'test/myAutomation.json', {
                                                                        // ======================
});

// Execute simulation
const simOutput = Simulation.ofAutomation(myAutomationDoc, {
  sleepHook: sleeper,
  awsInvoker: awsInvoker
}).simulate({});

// Assert simulation result
assert.deepEqual(awsInvoker.previousInvocations, [
    { awsApi: 'listBuckets', awsParams: {}, service: AwsService.S3 }]);
assert.deepEqual(sleeper.sleepMilliInvocations, [3000]);
assert.deepEqual(simOutput.outputs['simulationSteps'], ['MySleep', 'GetBucketId']);
```

### Import Existing Steps

You can also grab a string step (or steps) and import them as CDK step constructs.
This can be used to convert existing documents into CDK with each step defined separately.
Doing so will allow you do modify steps and reuse them in other documents.

Here's a simple example of a sleep step copy and pasted from its original yaml:

```python
StringStep.fromYaml(this, `
    name: sleep
    action: aws:sleep
    inputs:
      Duration: PT0M
`, {});
```

The above will return the CDK construct SleepStep.

## Incident Manager

This library provides L2 constructs for IncidentResponse as follows:

```python
new IncidentResponse(this, "MyIncidentResponsePlan", {
      incidentTemplate: IncidentTemplate.critical('EC2 Instance Utilization Impacted', {
        summary: 'EC2 Instance Impacted'
      }),
      actions: [
        IncidentResponseAction.ssmAutomation(myAutomationDoc, ec2CwAlarmRole, {
          parameters: {
            IncidentRecordArn: StringVariable.of('INCIDENT_RECORD_ARN'),
            InvolvedResources: StringVariable.of('INVOLVED_RESOURCES'),
            AutomationAssumeRole: HardCodedString.of(ec2CwAlarmRole.roleArn),
          }
        })
      ]
});
```

Notice how the `myAutomationDoc` is specified which is a reference to an AutomationDocument created using this library.

## What is Planned?

This library currently contains AutomationDocument and CommandDocument steps.
Simulation for AutomationDocuments is fully supported. Simulation for CommandDocuments is limited.

Stay tuned!

## Related Projects

* https://github.com/udondan/cdk-ssm-document

## Security

See [CONTRIBUTING](CONTRIBUTING.md#security-issue-notifications) for more information.

## License

This project is licensed under the Apache-2.0 License.
'''
from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.aws_iam as _aws_cdk_aws_iam_ceddda9d
import aws_cdk.aws_ssm as _aws_cdk_aws_ssm_ceddda9d
import aws_cdk.aws_ssmincidents as _aws_cdk_aws_ssmincidents_ceddda9d
import aws_cdk.cx_api as _aws_cdk_cx_api_ceddda9d
import constructs as _constructs_77d1e7e8


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ApiExecuteAutomationProps",
    jsii_struct_bases=[],
    name_mapping={"aws_invoker": "awsInvoker", "sleep_hook": "sleepHook"},
)
class ApiExecuteAutomationProps:
    def __init__(self, *, aws_invoker: "IAwsInvoker", sleep_hook: "ISleepHook") -> None:
        '''
        :param aws_invoker: 
        :param sleep_hook: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08c02016993b2a117240a5a7dcb1b3700304d1339c2a5a8420b238642be31116)
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "aws_invoker": aws_invoker,
            "sleep_hook": sleep_hook,
        }

    @builtins.property
    def aws_invoker(self) -> "IAwsInvoker":
        result = self._values.get("aws_invoker")
        assert result is not None, "Required property 'aws_invoker' is missing"
        return typing.cast("IAwsInvoker", result)

    @builtins.property
    def sleep_hook(self) -> "ISleepHook":
        result = self._values.get("sleep_hook")
        assert result is not None, "Required property 'sleep_hook' is missing"
        return typing.cast("ISleepHook", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiExecuteAutomationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ApiRunCommandProps",
    jsii_struct_bases=[],
    name_mapping={"aws_invoker": "awsInvoker", "sleep_hook": "sleepHook"},
)
class ApiRunCommandProps:
    def __init__(self, *, aws_invoker: "IAwsInvoker", sleep_hook: "ISleepHook") -> None:
        '''
        :param aws_invoker: 
        :param sleep_hook: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af38a0ce6274be1a306023040c89b3c06084afa621dbe98eba5701332739f564)
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "aws_invoker": aws_invoker,
            "sleep_hook": sleep_hook,
        }

    @builtins.property
    def aws_invoker(self) -> "IAwsInvoker":
        result = self._values.get("aws_invoker")
        assert result is not None, "Required property 'aws_invoker' is missing"
        return typing.cast("IAwsInvoker", result)

    @builtins.property
    def sleep_hook(self) -> "ISleepHook":
        result = self._values.get("sleep_hook")
        assert result is not None, "Required property 'sleep_hook' is missing"
        return typing.cast("ISleepHook", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiRunCommandProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ApproveSimulationProps",
    jsii_struct_bases=[],
    name_mapping={"approve_hook": "approveHook"},
)
class ApproveSimulationProps:
    def __init__(self, *, approve_hook: "IApproveHook") -> None:
        '''Properties for ApproveStep.

        :param approve_hook: (Optional) Approve hook to be called to pause the execution. To mock this implementation either inject an instance of IApproveHook or use the provided MockApprove class. Default: ApproveHook instance. ApproveHook may not work in exported JSII languages. Override interface as needed.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eaceda1463f14e4337fab5997598856eaf05edd73ec5a489c733161db5408e43)
            check_type(argname="argument approve_hook", value=approve_hook, expected_type=type_hints["approve_hook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "approve_hook": approve_hook,
        }

    @builtins.property
    def approve_hook(self) -> "IApproveHook":
        '''(Optional) Approve hook to be called to pause the execution.

        To mock this implementation either inject an instance of IApproveHook or use the provided MockApprove class.

        :default: ApproveHook instance. ApproveHook may not work in exported JSII languages. Override interface as needed.
        '''
        result = self._values.get("approve_hook")
        assert result is not None, "Required property 'approve_hook' is missing"
        return typing.cast("IApproveHook", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApproveSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AuthMethod(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.AuthMethod",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="ofBasic")
    @builtins.classmethod
    def of_basic(
        cls,
        user_name: "SecureVariable",
        password: "SecureVariable",
    ) -> "AuthMethod":
        '''
        :param user_name: -
        :param password: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a3591df80e77dbb8ef5aa57aea6dec940e019e52c5565dfe17720fddd13b45c)
            check_type(argname="argument user_name", value=user_name, expected_type=type_hints["user_name"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
        return typing.cast("AuthMethod", jsii.sinvoke(cls, "ofBasic", [user_name, password]))

    @jsii.member(jsii_name="ofDigest")
    @builtins.classmethod
    def of_digest(
        cls,
        user_name: "SecureVariable",
        password: "SecureVariable",
    ) -> "AuthMethod":
        '''
        :param user_name: -
        :param password: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e1520d00b0d311b02bf0ab8526c7a5f475ab8489924998b7920be6be1a16695)
            check_type(argname="argument user_name", value=user_name, expected_type=type_hints["user_name"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
        return typing.cast("AuthMethod", jsii.sinvoke(cls, "ofDigest", [user_name, password]))

    @jsii.member(jsii_name="ofNone")
    @builtins.classmethod
    def of_none(cls) -> "AuthMethod":
        return typing.cast("AuthMethod", jsii.sinvoke(cls, "ofNone", []))

    @jsii.member(jsii_name="requiredInputs")
    @abc.abstractmethod
    def required_inputs(self) -> typing.List[builtins.str]:
        ...

    @jsii.member(jsii_name="toEntry")
    @abc.abstractmethod
    def to_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        ...


class _AuthMethodProxy(AuthMethod):
    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="toEntry")
    def to_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toEntry", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, AuthMethod).__jsii_proxy_class__ = lambda : _AuthMethodProxy


class AutomationDocumentBuilder(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.AutomationDocumentBuilder",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="addStep")
    def add_step(self, step: "AutomationStep") -> None:
        '''
        :param step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35c46ba75b77e145ad70cc1ac20d0e7a95ac57a50251cb403bbbf783ae3d7ef2)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        return typing.cast(None, jsii.invoke(self, "addStep", [step]))

    @builtins.property
    @jsii.member(jsii_name="steps")
    def steps(self) -> typing.List["AutomationStep"]:
        return typing.cast(typing.List["AutomationStep"], jsii.get(self, "steps"))


class AutomationSimulation(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.AutomationSimulation",
):
    def __init__(
        self,
        automation_document: "AutomationDocument",
        *,
        approve_hook: typing.Optional["IApproveHook"] = None,
        aws_invoker: typing.Optional["IAwsInvoker"] = None,
        environment: typing.Optional["IEnvironment"] = None,
        input_observer: typing.Optional["IObserver"] = None,
        output_observer: typing.Optional["IObserver"] = None,
        parameter_resolver: typing.Optional["IParameterResolver"] = None,
        pause_hook: typing.Optional["IPauseHook"] = None,
        run_command_hook: typing.Optional["IRunCommandHook"] = None,
        simulation_platform: typing.Optional["Platform"] = None,
        sleep_hook: typing.Optional["ISleepHook"] = None,
        webhook: typing.Optional["IWebhook"] = None,
    ) -> None:
        '''
        :param automation_document: -
        :param approve_hook: 
        :param aws_invoker: 
        :param environment: 
        :param input_observer: 
        :param output_observer: 
        :param parameter_resolver: 
        :param pause_hook: 
        :param run_command_hook: 
        :param simulation_platform: 
        :param sleep_hook: 
        :param webhook: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e9e5dd611b035717db2dd8cc76801acfda0588b3e4bb3540a4dde83ea38c5a9)
            check_type(argname="argument automation_document", value=automation_document, expected_type=type_hints["automation_document"])
        props = SimulationProps(
            approve_hook=approve_hook,
            aws_invoker=aws_invoker,
            environment=environment,
            input_observer=input_observer,
            output_observer=output_observer,
            parameter_resolver=parameter_resolver,
            pause_hook=pause_hook,
            run_command_hook=run_command_hook,
            simulation_platform=simulation_platform,
            sleep_hook=sleep_hook,
            webhook=webhook,
        )

        jsii.create(self.__class__, self, [automation_document, props])

    @jsii.member(jsii_name="start")
    def start(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> "SimulationResult":
        '''Starts the execution of the steps by invoking the first step.

        The subsequent steps will be invoked by the steps themselves.

        :param inputs: all of the inputs necessary for the document to execute.

        :return: the outputs specified by all the steps.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecf0a07e5abd7e015b8dede33a5831d80785e3aea8d5e27a50e45e303f59d51f)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast("SimulationResult", jsii.invoke(self, "start", [inputs]))


class AutomationSimulationBase(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.AutomationSimulationBase",
):
    def __init__(self, step: "AutomationStep") -> None:
        '''
        :param step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5cc79b84b9c1335c3d739020a4923e18fd2763b2b8bc1417c07e1af3c65eb26c)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        jsii.create(self.__class__, self, [step])

    @jsii.member(jsii_name="executeStep")
    @abc.abstractmethod
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        ...

    @jsii.member(jsii_name="nextStep")
    def next_step(
        self,
        _inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Optional["AutomationStep"]:
        '''
        :param _inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec46109eb8632ec31ffe946bde1b1ff0fe13885e470a4640ff2d9c762f2b43d1)
            check_type(argname="argument _inputs", value=_inputs, expected_type=type_hints["_inputs"])
        return typing.cast(typing.Optional["AutomationStep"], jsii.invoke(self, "nextStep", [_inputs]))

    @builtins.property
    @jsii.member(jsii_name="step")
    def step(self) -> "AutomationStep":
        return typing.cast("AutomationStep", jsii.get(self, "step"))


class _AutomationSimulationBaseProxy(AutomationSimulationBase):
    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3eb11e49220ee922a0113c6f96e39ffaf50b01adacce55faa806e428b412cdc2)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, AutomationSimulationBase).__jsii_proxy_class__ = lambda : _AutomationSimulationBaseProxy


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.AutomationSimulationProps",
    jsii_struct_bases=[],
    name_mapping={
        "approve_hook": "approveHook",
        "aws_invoker": "awsInvoker",
        "execute_automation_hook": "executeAutomationHook",
        "input_observer": "inputObserver",
        "output_observer": "outputObserver",
        "parameter_resolver": "parameterResolver",
        "pause_hook": "pauseHook",
        "run_command_hook": "runCommandHook",
        "sleep_hook": "sleepHook",
        "webhook": "webhook",
    },
)
class AutomationSimulationProps:
    def __init__(
        self,
        *,
        approve_hook: typing.Optional["IApproveHook"] = None,
        aws_invoker: typing.Optional["IAwsInvoker"] = None,
        execute_automation_hook: typing.Optional["IExecuteAutomationHook"] = None,
        input_observer: typing.Optional["IObserver"] = None,
        output_observer: typing.Optional["IObserver"] = None,
        parameter_resolver: typing.Optional["IParameterResolver"] = None,
        pause_hook: typing.Optional["IPauseHook"] = None,
        run_command_hook: typing.Optional["IRunCommandHook"] = None,
        sleep_hook: typing.Optional["ISleepHook"] = None,
        webhook: typing.Optional["IWebhook"] = None,
    ) -> None:
        '''
        :param approve_hook: (Optional) Approve hook to be called to pause the execution. To mock this implementation either inject an instance of IApproveHook or use the provided MockApprove class. Default: ApproveHook instance. ApproveHook may not work in exported JSII languages. Override interface as needed.
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param execute_automation_hook: Hook for simulating aws:executeAutomation. Default: - Uses AWS API to execute the document remotely.
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param parameter_resolver: (Optional) Resolver for secure strings in parameters. Required to simulate if using tokens in parameters input. Default: - Treats parameters as literal
        :param pause_hook: (Optional) Pause hook to be called to pause the execution. To mock this implemenation either inject an instance of IPauseHook or use the provided MockPause class. Default: PauseHook instance. PauseHook may not work in exported JSII languages. Override interface as needed.
        :param run_command_hook: Hook for simulating aws:runCommand. Default: - Uses AWS API to execute the document remotely.
        :param sleep_hook: (Optional) Hook to inject alternate ISleeper (to mock the sleep between failed invocations). Default: - really perform sleep using SleeperImpl class.
        :param webhook: (Optional) Hook for simulating aws:invokeWebhook. Default: - Returns 204 with an empty response
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d3b4d1ff1eeb559a44a1bad3921e706376c5c57dbd8a11e22add82bb29ef150e)
            check_type(argname="argument approve_hook", value=approve_hook, expected_type=type_hints["approve_hook"])
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument execute_automation_hook", value=execute_automation_hook, expected_type=type_hints["execute_automation_hook"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument parameter_resolver", value=parameter_resolver, expected_type=type_hints["parameter_resolver"])
            check_type(argname="argument pause_hook", value=pause_hook, expected_type=type_hints["pause_hook"])
            check_type(argname="argument run_command_hook", value=run_command_hook, expected_type=type_hints["run_command_hook"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if approve_hook is not None:
            self._values["approve_hook"] = approve_hook
        if aws_invoker is not None:
            self._values["aws_invoker"] = aws_invoker
        if execute_automation_hook is not None:
            self._values["execute_automation_hook"] = execute_automation_hook
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if parameter_resolver is not None:
            self._values["parameter_resolver"] = parameter_resolver
        if pause_hook is not None:
            self._values["pause_hook"] = pause_hook
        if run_command_hook is not None:
            self._values["run_command_hook"] = run_command_hook
        if sleep_hook is not None:
            self._values["sleep_hook"] = sleep_hook
        if webhook is not None:
            self._values["webhook"] = webhook

    @builtins.property
    def approve_hook(self) -> typing.Optional["IApproveHook"]:
        '''(Optional) Approve hook to be called to pause the execution.

        To mock this implementation either inject an instance of IApproveHook or use the provided MockApprove class.

        :default: ApproveHook instance. ApproveHook may not work in exported JSII languages. Override interface as needed.
        '''
        result = self._values.get("approve_hook")
        return typing.cast(typing.Optional["IApproveHook"], result)

    @builtins.property
    def aws_invoker(self) -> typing.Optional["IAwsInvoker"]:
        '''(Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call).

        :default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        result = self._values.get("aws_invoker")
        return typing.cast(typing.Optional["IAwsInvoker"], result)

    @builtins.property
    def execute_automation_hook(self) -> typing.Optional["IExecuteAutomationHook"]:
        '''Hook for simulating aws:executeAutomation.

        :default: - Uses AWS API to execute the document remotely.
        '''
        result = self._values.get("execute_automation_hook")
        return typing.cast(typing.Optional["IExecuteAutomationHook"], result)

    @builtins.property
    def input_observer(self) -> typing.Optional["IObserver"]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional["IObserver"], result)

    @builtins.property
    def output_observer(self) -> typing.Optional["IObserver"]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional["IObserver"], result)

    @builtins.property
    def parameter_resolver(self) -> typing.Optional["IParameterResolver"]:
        '''(Optional) Resolver for secure strings in parameters.

        Required to simulate if using tokens in parameters input.

        :default: - Treats parameters as literal
        '''
        result = self._values.get("parameter_resolver")
        return typing.cast(typing.Optional["IParameterResolver"], result)

    @builtins.property
    def pause_hook(self) -> typing.Optional["IPauseHook"]:
        '''(Optional) Pause hook to be called to pause the execution.

        To mock this implemenation either inject an instance of IPauseHook or use the provided MockPause class.

        :default: PauseHook instance. PauseHook may not work in exported JSII languages. Override interface as needed.
        '''
        result = self._values.get("pause_hook")
        return typing.cast(typing.Optional["IPauseHook"], result)

    @builtins.property
    def run_command_hook(self) -> typing.Optional["IRunCommandHook"]:
        '''Hook for simulating aws:runCommand.

        :default: - Uses AWS API to execute the document remotely.
        '''
        result = self._values.get("run_command_hook")
        return typing.cast(typing.Optional["IRunCommandHook"], result)

    @builtins.property
    def sleep_hook(self) -> typing.Optional["ISleepHook"]:
        '''(Optional) Hook to inject alternate ISleeper (to mock the sleep between failed invocations).

        :default: - really perform sleep using SleeperImpl class.
        '''
        result = self._values.get("sleep_hook")
        return typing.cast(typing.Optional["ISleepHook"], result)

    @builtins.property
    def webhook(self) -> typing.Optional["IWebhook"]:
        '''(Optional) Hook for simulating aws:invokeWebhook.

        :default: - Returns 204 with an empty response
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["IWebhook"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutomationSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AutomationStepSimulation(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.AutomationStepSimulation",
):
    def __init__(
        self,
        step: "AutomationStep",
        *,
        approve_hook: typing.Optional["IApproveHook"] = None,
        aws_invoker: typing.Optional["IAwsInvoker"] = None,
        execute_automation_hook: typing.Optional["IExecuteAutomationHook"] = None,
        input_observer: typing.Optional["IObserver"] = None,
        output_observer: typing.Optional["IObserver"] = None,
        parameter_resolver: typing.Optional["IParameterResolver"] = None,
        pause_hook: typing.Optional["IPauseHook"] = None,
        run_command_hook: typing.Optional["IRunCommandHook"] = None,
        sleep_hook: typing.Optional["ISleepHook"] = None,
        webhook: typing.Optional["IWebhook"] = None,
    ) -> None:
        '''
        :param step: -
        :param approve_hook: (Optional) Approve hook to be called to pause the execution. To mock this implementation either inject an instance of IApproveHook or use the provided MockApprove class. Default: ApproveHook instance. ApproveHook may not work in exported JSII languages. Override interface as needed.
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param execute_automation_hook: Hook for simulating aws:executeAutomation. Default: - Uses AWS API to execute the document remotely.
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param parameter_resolver: (Optional) Resolver for secure strings in parameters. Required to simulate if using tokens in parameters input. Default: - Treats parameters as literal
        :param pause_hook: (Optional) Pause hook to be called to pause the execution. To mock this implemenation either inject an instance of IPauseHook or use the provided MockPause class. Default: PauseHook instance. PauseHook may not work in exported JSII languages. Override interface as needed.
        :param run_command_hook: Hook for simulating aws:runCommand. Default: - Uses AWS API to execute the document remotely.
        :param sleep_hook: (Optional) Hook to inject alternate ISleeper (to mock the sleep between failed invocations). Default: - really perform sleep using SleeperImpl class.
        :param webhook: (Optional) Hook for simulating aws:invokeWebhook. Default: - Returns 204 with an empty response
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4360175161f1d9c2ebbfc76f2dee4e24cd4eb99b9870cb7d8ac98d069d885a3)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = AutomationSimulationProps(
            approve_hook=approve_hook,
            aws_invoker=aws_invoker,
            execute_automation_hook=execute_automation_hook,
            input_observer=input_observer,
            output_observer=output_observer,
            parameter_resolver=parameter_resolver,
            pause_hook=pause_hook,
            run_command_hook=run_command_hook,
            sleep_hook=sleep_hook,
            webhook=webhook,
        )

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="invoke")
    def invoke(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> "SimulationResult":
        '''Invokes the current step on the input and will return a SimulationResult.

        :param inputs: must contain all of the inputs declared by the current step.

        :return: a SimulationResult with the step outputs in the case of success or stacktrace in the case of failure.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3a2871067490f5b1404f08b97e29340d52a386005e9a9eac44faed17eb76a33)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast("SimulationResult", jsii.invoke(self, "invoke", [inputs]))

    @jsii.member(jsii_name="prependSelf")
    def _prepend_self(
        self,
        subsequent_steps: typing.Sequence[builtins.str],
    ) -> typing.List[builtins.str]:
        '''Adds this step name to the list of executed steps.

        Since the steps are invoked as a chain, the current step is prepended as invocation stack is popped.

        :param subsequent_steps: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c46aeb8cc3ab966aa4205338f39dab478acdbfc408de61c7a389fb3e10a209e)
            check_type(argname="argument subsequent_steps", value=subsequent_steps, expected_type=type_hints["subsequent_steps"])
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "prependSelf", [subsequent_steps]))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> "RequiredAutomationSimulationProps":
        return typing.cast("RequiredAutomationSimulationProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="step")
    def step(self) -> "AutomationStep":
        return typing.cast("AutomationStep", jsii.get(self, "step"))


class AwsApiSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.AwsApiSimulation",
):
    '''AutomationStep implementation of aws:executeAwsApi.'''

    def __init__(self, step: "AwsApiStep", *, aws_invoker: "IAwsInvoker") -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__76009844085f37a4b87980d0948a019c5e2c3a0a71fcbb5083fe75d1f9f7902b)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = AwsInvocationSimulationProps(aws_invoker=aws_invoker)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Invokes the specified service (param) with the specified api (param) with the specified apiParams (param).

        This call will be invoked synchronously.
        The input variables in apiParams (param) specified using "{{ INPUT }}" syntax will be replaced with the inputs.

        :param inputs: -

        :return: the AWS api response. The Output selection will take place outside of this function.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01a9fbab0e98cf6ec11d4ca1992708709512dfcf10e3d0b87e93f1b469906e5e)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="awsApiStep")
    def aws_api_step(self) -> "AwsApiStep":
        return typing.cast("AwsApiStep", jsii.get(self, "awsApiStep"))

    @builtins.property
    @jsii.member(jsii_name="awsInvoker")
    def aws_invoker(self) -> "IAwsInvoker":
        return typing.cast("IAwsInvoker", jsii.get(self, "awsInvoker"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.AwsInvocationSimulationProps",
    jsii_struct_bases=[],
    name_mapping={"aws_invoker": "awsInvoker"},
)
class AwsInvocationSimulationProps:
    def __init__(self, *, aws_invoker: "IAwsInvoker") -> None:
        '''
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0961d9e7ba7539e90ab20d28dd6f14e7553b08b42107cbbb7d3a3192a35b60d6)
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "aws_invoker": aws_invoker,
        }

    @builtins.property
    def aws_invoker(self) -> "IAwsInvoker":
        '''(Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call).

        :default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        result = self._values.get("aws_invoker")
        assert result is not None, "Required property 'aws_invoker' is missing"
        return typing.cast("IAwsInvoker", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AwsInvocationSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AwsService(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.AwsService",
):
    '''Represents an AWS service.

    The namespace which is meant to be used for the service declaration in SSM may be difficult to guess.
    The name provided for simulation may at times be different.
    This class provides many ready-to-use implementations of AWS services.
    If a service is not on the list, you can fall back to constructing this object on your own.
    In other words, you can reference S3 using ``AwsService.S3``
    For a NewService, you can reference it using ``new AwsService('new-service', 'NewService')``.
    It is risky to auto convert between namespace and javaScriptName because they are not consistent in all cases.
    '''

    def __init__(self, namespace: builtins.str, java_script_name: builtins.str) -> None:
        '''
        :param namespace: -
        :param java_script_name: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__011beaadde5cbf101b3b2c4a2870f6dbad6e426fd33bc5fd7c34df2f0fd60ef5)
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument java_script_name", value=java_script_name, expected_type=type_hints["java_script_name"])
        jsii.create(self.__class__, self, [namespace, java_script_name])

    @jsii.member(jsii_name="toJSON")
    def to_json(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "toJSON", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ACCESS_ANALYZER")
    def ACCESS_ANALYZER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ACCESS_ANALYZER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ACCOUNT")
    def ACCOUNT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ACCOUNT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ACM")
    def ACM(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ACM"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ACMPCA")
    def ACMPCA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ACMPCA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ALEXA_FOR_BUSINESS")
    def ALEXA_FOR_BUSINESS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ALEXA_FOR_BUSINESS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AMP")
    def AMP(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "AMP"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AMPLIFY")
    def AMPLIFY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "AMPLIFY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AMPLIFY_BACKEND")
    def AMPLIFY_BACKEND(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "AMPLIFY_BACKEND"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AMPLIFY_UI_BUILDER")
    def AMPLIFY_UI_BUILDER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "AMPLIFY_UI_BUILDER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="API_GATEWAY_MANAGEMENT_API")
    def API_GATEWAY_MANAGEMENT_API(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "API_GATEWAY_MANAGEMENT_API"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="API_GATEWAY_V2")
    def API_GATEWAY_V2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "API_GATEWAY_V2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APIGATEWAY")
    def APIGATEWAY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APIGATEWAY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APP_CONFIG")
    def APP_CONFIG(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APP_CONFIG"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APP_CONFIG_DATA")
    def APP_CONFIG_DATA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APP_CONFIG_DATA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APP_INTEGRATIONS")
    def APP_INTEGRATIONS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APP_INTEGRATIONS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APP_MESH")
    def APP_MESH(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APP_MESH"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APP_RUNNER")
    def APP_RUNNER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APP_RUNNER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APP_STREAM")
    def APP_STREAM(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APP_STREAM"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APP_SYNC")
    def APP_SYNC(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APP_SYNC"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APPFLOW")
    def APPFLOW(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APPFLOW"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APPLICATION_AUTO_SCALING")
    def APPLICATION_AUTO_SCALING(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APPLICATION_AUTO_SCALING"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APPLICATION_COST_PROFILER")
    def APPLICATION_COST_PROFILER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APPLICATION_COST_PROFILER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="APPLICATION_INSIGHTS")
    def APPLICATION_INSIGHTS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "APPLICATION_INSIGHTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ATHENA")
    def ATHENA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ATHENA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AUDIT_MANAGER")
    def AUDIT_MANAGER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "AUDIT_MANAGER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AUTO_SCALING")
    def AUTO_SCALING(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "AUTO_SCALING"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AUTO_SCALING_PLANS")
    def AUTO_SCALING_PLANS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "AUTO_SCALING_PLANS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="BACKUP")
    def BACKUP(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "BACKUP"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="BACKUP_GATEWAY")
    def BACKUP_GATEWAY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "BACKUP_GATEWAY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="BACKUP_STORAGE")
    def BACKUP_STORAGE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "BACKUP_STORAGE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="BATCH")
    def BATCH(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "BATCH"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="BILLINGCONDUCTOR")
    def BILLINGCONDUCTOR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "BILLINGCONDUCTOR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="BRAKET")
    def BRAKET(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "BRAKET"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="BUDGETS")
    def BUDGETS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "BUDGETS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CHIME")
    def CHIME(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CHIME"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CHIME_SDK_IDENTITY")
    def CHIME_SDK_IDENTITY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CHIME_SDK_IDENTITY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CHIME_SDK_MEDIA_PIPELINES")
    def CHIME_SDK_MEDIA_PIPELINES(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CHIME_SDK_MEDIA_PIPELINES"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CHIME_SDK_MEETINGS")
    def CHIME_SDK_MEETINGS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CHIME_SDK_MEETINGS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CHIME_SDK_MESSAGING")
    def CHIME_SDK_MESSAGING(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CHIME_SDK_MESSAGING"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD_CONTROL")
    def CLOUD_CONTROL(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD_CONTROL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD_DIRECTORY")
    def CLOUD_DIRECTORY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD_DIRECTORY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD_FORMATION")
    def CLOUD_FORMATION(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD_FORMATION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD_FRONT")
    def CLOUD_FRONT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD_FRONT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD_HS_M")
    def CLOUD_HS_M(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD_HS_M"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD_HSM_V2")
    def CLOUD_HSM_V2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD_HSM_V2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD_SEARCH")
    def CLOUD_SEARCH(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD_SEARCH"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD_SEARCH_DOMAIN")
    def CLOUD_SEARCH_DOMAIN(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD_SEARCH_DOMAIN"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD_TRAIL")
    def CLOUD_TRAIL(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD_TRAIL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD_WATCH")
    def CLOUD_WATCH(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD_WATCH"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CLOUD9")
    def CLOUD9(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CLOUD9"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_ARTIFACT")
    def CODE_ARTIFACT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CODE_ARTIFACT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_BUILD")
    def CODE_BUILD(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CODE_BUILD"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_COMMIT")
    def CODE_COMMIT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CODE_COMMIT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_DEPLOY")
    def CODE_DEPLOY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CODE_DEPLOY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_GURU_PROFILER")
    def CODE_GURU_PROFILER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CODE_GURU_PROFILER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_GURU_REVIEWER")
    def CODE_GURU_REVIEWER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CODE_GURU_REVIEWER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_PIPELINE")
    def CODE_PIPELINE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CODE_PIPELINE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_STAR")
    def CODE_STAR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CODE_STAR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_STAR_NOTIFICATIONS")
    def CODE_STAR_NOTIFICATIONS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CODE_STAR_NOTIFICATIONS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_STARCONNECTIONS")
    def CODE_STARCONNECTIONS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CODE_STARCONNECTIONS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="COGNITO_IDENTITY")
    def COGNITO_IDENTITY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "COGNITO_IDENTITY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="COGNITO_SYNC")
    def COGNITO_SYNC(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "COGNITO_SYNC"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="COMPREHEND")
    def COMPREHEND(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "COMPREHEND"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="COMPREHEND_MEDICAL")
    def COMPREHEND_MEDICAL(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "COMPREHEND_MEDICAL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="COMPUTE_OPTIMIZER")
    def COMPUTE_OPTIMIZER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "COMPUTE_OPTIMIZER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CONNECT")
    def CONNECT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CONNECT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CONNECT_CAMPAIGNS")
    def CONNECT_CAMPAIGNS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CONNECT_CAMPAIGNS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CONNECT_CASES")
    def CONNECT_CASES(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CONNECT_CASES"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CONNECT_CONTACT_LENS")
    def CONNECT_CONTACT_LENS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CONNECT_CONTACT_LENS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CONNECT_PARTICIPANT")
    def CONNECT_PARTICIPANT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CONNECT_PARTICIPANT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CONTROL_TOWER")
    def CONTROL_TOWER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CONTROL_TOWER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CUR")
    def CUR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CUR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CUSTOMER_PROFILES")
    def CUSTOMER_PROFILES(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "CUSTOMER_PROFILES"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DATA_BREW")
    def DATA_BREW(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DATA_BREW"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DATA_EXCHANGE")
    def DATA_EXCHANGE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DATA_EXCHANGE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DATA_PIPELINE")
    def DATA_PIPELINE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DATA_PIPELINE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DATA_SYNC")
    def DATA_SYNC(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DATA_SYNC"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DAX")
    def DAX(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DAX"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DETECTIVE")
    def DETECTIVE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DETECTIVE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DEV_OPS_GURU")
    def DEV_OPS_GURU(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DEV_OPS_GURU"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DEVICE_FARM")
    def DEVICE_FARM(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DEVICE_FARM"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DIRECT_CONNECT")
    def DIRECT_CONNECT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DIRECT_CONNECT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DISCOVERY")
    def DISCOVERY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DISCOVERY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DLM")
    def DLM(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DLM"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DMS")
    def DMS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DMS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DOC_DB")
    def DOC_DB(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DOC_DB"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DRS")
    def DRS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DRS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DYNAMO_DB")
    def DYNAMO_DB(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DYNAMO_DB"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DYNAMO_DB_STREAMS")
    def DYNAMO_DB_STREAMS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "DYNAMO_DB_STREAMS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EBS")
    def EBS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "EBS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EC2")
    def EC2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "EC2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EC2_INSTANCE_CONNECT")
    def EC2_INSTANCE_CONNECT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "EC2_INSTANCE_CONNECT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ECR")
    def ECR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ECR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ECRPUBLIC")
    def ECRPUBLIC(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ECRPUBLIC"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ECS")
    def ECS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ECS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EFS")
    def EFS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "EFS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EKS")
    def EKS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "EKS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ELASTI_CACHE")
    def ELASTI_CACHE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ELASTI_CACHE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ELASTIC_BEANSTALK")
    def ELASTIC_BEANSTALK(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ELASTIC_BEANSTALK"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ELASTIC_INFERENCE")
    def ELASTIC_INFERENCE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ELASTIC_INFERENCE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ELASTIC_TRANSCODER")
    def ELASTIC_TRANSCODER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ELASTIC_TRANSCODER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ELB")
    def ELB(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ELB"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ELBV2")
    def ELBV2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ELBV2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EMR")
    def EMR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "EMR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EMRCONTAINERS")
    def EMRCONTAINERS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "EMRCONTAINERS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EMRSERVERLESS")
    def EMRSERVERLESS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "EMRSERVERLESS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ES")
    def ES(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ES"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="EVIDENTLY")
    def EVIDENTLY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "EVIDENTLY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="FINSPACE")
    def FINSPACE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "FINSPACE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="FINSPACEDATA")
    def FINSPACEDATA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "FINSPACEDATA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="FIREHOSE")
    def FIREHOSE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "FIREHOSE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="FIS")
    def FIS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "FIS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="FMS")
    def FMS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "FMS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="FRAUD_DETECTOR")
    def FRAUD_DETECTOR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "FRAUD_DETECTOR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="FSX")
    def FSX(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "FSX"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GAME_LIFT")
    def GAME_LIFT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "GAME_LIFT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GAME_SPARKS")
    def GAME_SPARKS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "GAME_SPARKS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GLACIER")
    def GLACIER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "GLACIER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GLOBAL_ACCELERATOR")
    def GLOBAL_ACCELERATOR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "GLOBAL_ACCELERATOR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GLUE")
    def GLUE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "GLUE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GRAFANA")
    def GRAFANA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "GRAFANA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GREENGRASS")
    def GREENGRASS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "GREENGRASS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GREENGRASS_V2")
    def GREENGRASS_V2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "GREENGRASS_V2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GROUND_STATION")
    def GROUND_STATION(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "GROUND_STATION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GUARD_DUTY")
    def GUARD_DUTY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "GUARD_DUTY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="HEALTH")
    def HEALTH(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "HEALTH"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="HEALTH_LAKE")
    def HEALTH_LAKE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "HEALTH_LAKE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="HONEYCODE")
    def HONEYCODE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "HONEYCODE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IAM")
    def IAM(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IAM"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IDENTITY_STORE")
    def IDENTITY_STORE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IDENTITY_STORE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IMAGEBUILDER")
    def IMAGEBUILDER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IMAGEBUILDER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IMPORT_EXPORT")
    def IMPORT_EXPORT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IMPORT_EXPORT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="INSPECTOR")
    def INSPECTOR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "INSPECTOR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="INSPECTOR2")
    def INSPECTOR2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "INSPECTOR2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IO_T_ANALYTICS")
    def IO_T_ANALYTICS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IO_T_ANALYTICS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IO_T1_CLICK_PROJECTS")
    def IO_T1_CLICK_PROJECTS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IO_T1_CLICK_PROJECTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT")
    def IOT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_DATA")
    def IOT_DATA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_DATA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_DEVICE_ADVISOR")
    def IOT_DEVICE_ADVISOR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_DEVICE_ADVISOR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_EVENTS")
    def IOT_EVENTS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_EVENTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_EVENTS_DATA")
    def IOT_EVENTS_DATA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_EVENTS_DATA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_FLEET_HUB")
    def IOT_FLEET_HUB(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_FLEET_HUB"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_FLEET_WISE")
    def IOT_FLEET_WISE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_FLEET_WISE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_SECURE_TUNNELING")
    def IOT_SECURE_TUNNELING(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_SECURE_TUNNELING"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_SITE_WISE")
    def IOT_SITE_WISE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_SITE_WISE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_THINGS_GRAPH")
    def IOT_THINGS_GRAPH(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_THINGS_GRAPH"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_TWIN_MAKER")
    def IOT_TWIN_MAKER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_TWIN_MAKER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IOT_WIRELESS")
    def IOT_WIRELESS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IOT_WIRELESS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IVS")
    def IVS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IVS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="IVSCHAT")
    def IVSCHAT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "IVSCHAT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KAFKA")
    def KAFKA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KAFKA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KAFKA_CONNECT")
    def KAFKA_CONNECT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KAFKA_CONNECT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KENDRA")
    def KENDRA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KENDRA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KEYSPACES")
    def KEYSPACES(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KEYSPACES"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KINESIS")
    def KINESIS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KINESIS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KINESIS_ANALYTICS")
    def KINESIS_ANALYTICS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KINESIS_ANALYTICS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KINESIS_ANALYTICS_V2")
    def KINESIS_ANALYTICS_V2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KINESIS_ANALYTICS_V2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KINESIS_VIDEO")
    def KINESIS_VIDEO(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KINESIS_VIDEO"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KINESIS_VIDEO_ARCHIVED_MEDIA")
    def KINESIS_VIDEO_ARCHIVED_MEDIA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KINESIS_VIDEO_ARCHIVED_MEDIA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KINESIS_VIDEO_MEDIA")
    def KINESIS_VIDEO_MEDIA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KINESIS_VIDEO_MEDIA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="KMS")
    def KMS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "KMS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LAKE_FORMATION")
    def LAKE_FORMATION(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "LAKE_FORMATION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LAMBDA")
    def LAMBDA_(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "LAMBDA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LEX_RUNTIME")
    def LEX_RUNTIME(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "LEX_RUNTIME"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LICENSE_MANAGER")
    def LICENSE_MANAGER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "LICENSE_MANAGER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LICENSE_MANAGER_USER_SUBSCRIPTIONS")
    def LICENSE_MANAGER_USER_SUBSCRIPTIONS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "LICENSE_MANAGER_USER_SUBSCRIPTIONS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LIGHTSAIL")
    def LIGHTSAIL(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "LIGHTSAIL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LOCATION")
    def LOCATION(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "LOCATION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LOOKOUT_EQUIPMENT")
    def LOOKOUT_EQUIPMENT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "LOOKOUT_EQUIPMENT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LOOKOUT_METRICS")
    def LOOKOUT_METRICS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "LOOKOUT_METRICS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LOOKOUT_VISION")
    def LOOKOUT_VISION(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "LOOKOUT_VISION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="M2")
    def M2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "M2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MACHINE_LEARNING")
    def MACHINE_LEARNING(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MACHINE_LEARNING"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MACIE")
    def MACIE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MACIE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MACIE2")
    def MACIE2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MACIE2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MANAGED_BLOCKCHAIN")
    def MANAGED_BLOCKCHAIN(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MANAGED_BLOCKCHAIN"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MARKETPLACE_CATALOG")
    def MARKETPLACE_CATALOG(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MARKETPLACE_CATALOG"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MARKETPLACE_COMMERCE_ANALYTICS")
    def MARKETPLACE_COMMERCE_ANALYTICS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MARKETPLACE_COMMERCE_ANALYTICS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MEDIA_CONNECT")
    def MEDIA_CONNECT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MEDIA_CONNECT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MEDIA_CONVERT")
    def MEDIA_CONVERT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MEDIA_CONVERT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MEDIA_LIVE")
    def MEDIA_LIVE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MEDIA_LIVE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MEDIA_PACKAGE")
    def MEDIA_PACKAGE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MEDIA_PACKAGE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MEDIA_PACKAGE_VOD")
    def MEDIA_PACKAGE_VOD(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MEDIA_PACKAGE_VOD"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MEDIA_STORE")
    def MEDIA_STORE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MEDIA_STORE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MEDIA_STORE_DATA")
    def MEDIA_STORE_DATA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MEDIA_STORE_DATA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MEDIA_TAILOR")
    def MEDIA_TAILOR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MEDIA_TAILOR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MEMORY_DB")
    def MEMORY_DB(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MEMORY_DB"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MGN")
    def MGN(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MGN"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MIGRATION_HUB_CONFIG")
    def MIGRATION_HUB_CONFIG(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MIGRATION_HUB_CONFIG"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MIGRATION_HUB_ORCHESTRATOR")
    def MIGRATION_HUB_ORCHESTRATOR(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MIGRATION_HUB_ORCHESTRATOR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MIGRATION_HUB_REFACTOR_SPACES")
    def MIGRATION_HUB_REFACTOR_SPACES(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MIGRATION_HUB_REFACTOR_SPACES"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MIGRATION_HUB_STRATEGY")
    def MIGRATION_HUB_STRATEGY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MIGRATION_HUB_STRATEGY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MOBILE")
    def MOBILE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MOBILE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MQ")
    def MQ(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MQ"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MTURK")
    def MTURK(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MTURK"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MWAA")
    def MWAA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "MWAA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="NEPTUNE")
    def NEPTUNE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "NEPTUNE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="NETWORK_FIREWALL")
    def NETWORK_FIREWALL(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "NETWORK_FIREWALL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="NETWORK_MANAGER")
    def NETWORK_MANAGER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "NETWORK_MANAGER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="NIMBLE")
    def NIMBLE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "NIMBLE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="OPEN_SEARCH")
    def OPEN_SEARCH(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "OPEN_SEARCH"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="OPS_WORKS")
    def OPS_WORKS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "OPS_WORKS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="OPS_WORKS_C_M")
    def OPS_WORKS_C_M(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "OPS_WORKS_C_M"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ORGANIZATIONS")
    def ORGANIZATIONS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ORGANIZATIONS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="OUTPOSTS")
    def OUTPOSTS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "OUTPOSTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PANORAMA")
    def PANORAMA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PANORAMA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PERSONALIZE")
    def PERSONALIZE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PERSONALIZE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PERSONALIZE_EVENTS")
    def PERSONALIZE_EVENTS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PERSONALIZE_EVENTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PERSONALIZE_RUNTIME")
    def PERSONALIZE_RUNTIME(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PERSONALIZE_RUNTIME"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PI")
    def PI(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PI"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PINPOINT")
    def PINPOINT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PINPOINT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PINPOINT_EMAIL")
    def PINPOINT_EMAIL(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PINPOINT_EMAIL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PINPOINT_SMS_VOICE")
    def PINPOINT_SMS_VOICE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PINPOINT_SMS_VOICE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PINPOINT_SMS_VOICE_V2")
    def PINPOINT_SMS_VOICE_V2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PINPOINT_SMS_VOICE_V2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="POLLY")
    def POLLY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "POLLY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PRICING")
    def PRICING(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PRICING"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PRIVATE_NETWORKS")
    def PRIVATE_NETWORKS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PRIVATE_NETWORKS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PROTON")
    def PROTON(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "PROTON"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="QLDB")
    def QLDB(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "QLDB"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="QLDB_SESSION")
    def QLDB_SESSION(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "QLDB_SESSION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="QUICK_SIGHT")
    def QUICK_SIGHT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "QUICK_SIGHT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="RAM")
    def RAM(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "RAM"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="RBIN")
    def RBIN(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "RBIN"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="RDS")
    def RDS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "RDS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="REDSHIFT")
    def REDSHIFT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "REDSHIFT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="REDSHIFT_DATA")
    def REDSHIFT_DATA(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "REDSHIFT_DATA"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="REDSHIFT_SERVERLESS")
    def REDSHIFT_SERVERLESS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "REDSHIFT_SERVERLESS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="REKOGNITION")
    def REKOGNITION(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "REKOGNITION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="RESILIENCEHUB")
    def RESILIENCEHUB(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "RESILIENCEHUB"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="RESOURCE_EXPLORER2")
    def RESOURCE_EXPLORER2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "RESOURCE_EXPLORER2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="RESOURCE_GROUPS")
    def RESOURCE_GROUPS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "RESOURCE_GROUPS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="RESOURCE_GROUPS_TAGGING_AP_I")
    def RESOURCE_GROUPS_TAGGING_AP_I(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "RESOURCE_GROUPS_TAGGING_AP_I"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROBO_MAKER")
    def ROBO_MAKER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ROBO_MAKER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROLES_ANYWHERE")
    def ROLES_ANYWHERE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ROLES_ANYWHERE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROUTE53")
    def ROUTE53(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ROUTE53"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROUTE53_DOMAINS")
    def ROUTE53_DOMAINS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ROUTE53_DOMAINS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROUTE53_RECOVERY_CLUSTER")
    def ROUTE53_RECOVERY_CLUSTER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ROUTE53_RECOVERY_CLUSTER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROUTE53_RECOVERY_CONTROL_CONFIG")
    def ROUTE53_RECOVERY_CONTROL_CONFIG(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ROUTE53_RECOVERY_CONTROL_CONFIG"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROUTE53_RECOVERY_READINESS")
    def ROUTE53_RECOVERY_READINESS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ROUTE53_RECOVERY_READINESS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROUTE53_RESOLVER")
    def ROUTE53_RESOLVER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "ROUTE53_RESOLVER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="RUM")
    def RUM(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "RUM"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="S3")
    def S3(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "S3"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="S3_CONTROL")
    def S3_CONTROL(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "S3_CONTROL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="S3_OUTPOSTS")
    def S3_OUTPOSTS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "S3_OUTPOSTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SAGE_MAKER")
    def SAGE_MAKER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SAGE_MAKER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SAGE_MAKER_FEATURE_STORE_RUNTIME")
    def SAGE_MAKER_FEATURE_STORE_RUNTIME(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SAGE_MAKER_FEATURE_STORE_RUNTIME"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SAGE_MAKER_RUNTIME")
    def SAGE_MAKER_RUNTIME(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SAGE_MAKER_RUNTIME"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SAGEMAKER_EDGE")
    def SAGEMAKER_EDGE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SAGEMAKER_EDGE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SAVINGS_PLANS")
    def SAVINGS_PLANS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SAVINGS_PLANS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SCHEDULER")
    def SCHEDULER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SCHEDULER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SCHEMAS")
    def SCHEMAS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SCHEMAS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SECRETS_MANAGER")
    def SECRETS_MANAGER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SECRETS_MANAGER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SECURITY_HUB")
    def SECURITY_HUB(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SECURITY_HUB"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SERVICE_CATALOG")
    def SERVICE_CATALOG(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SERVICE_CATALOG"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SERVICE_CATALOG_APP_REGISTRY")
    def SERVICE_CATALOG_APP_REGISTRY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SERVICE_CATALOG_APP_REGISTRY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SERVICE_DISCOVERY")
    def SERVICE_DISCOVERY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SERVICE_DISCOVERY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SERVICE_QUOTAS")
    def SERVICE_QUOTAS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SERVICE_QUOTAS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SES")
    def SES(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SES"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SES_V2")
    def SES_V2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SES_V2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SHIELD")
    def SHIELD(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SHIELD"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SIGNER")
    def SIGNER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SIGNER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SMS")
    def SMS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SMS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SNOW_DEVICE_MANAGEMENT")
    def SNOW_DEVICE_MANAGEMENT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SNOW_DEVICE_MANAGEMENT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SNOWBALL")
    def SNOWBALL(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SNOWBALL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SNS")
    def SNS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SNS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SQS")
    def SQS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SQS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SSM")
    def SSM(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SSM"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SSM_CONTACTS")
    def SSM_CONTACTS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SSM_CONTACTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SSM_INCIDENTS")
    def SSM_INCIDENTS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SSM_INCIDENTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SSO")
    def SSO(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SSO"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SSO_ADMIN")
    def SSO_ADMIN(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SSO_ADMIN"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SSO_OIDC")
    def SSO_OIDC(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SSO_OIDC"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="STEP_FUNCTIONS")
    def STEP_FUNCTIONS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "STEP_FUNCTIONS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="STORAGE_GATEWAY")
    def STORAGE_GATEWAY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "STORAGE_GATEWAY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="STS")
    def STS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "STS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SUPPORT")
    def SUPPORT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SUPPORT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SUPPORT_APP")
    def SUPPORT_APP(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SUPPORT_APP"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SWF")
    def SWF(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SWF"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SYNTHETICS")
    def SYNTHETICS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "SYNTHETICS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="TEXTRACT")
    def TEXTRACT(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "TEXTRACT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="TIMESTREAM_QUERY")
    def TIMESTREAM_QUERY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "TIMESTREAM_QUERY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="TIMESTREAM_WRITE")
    def TIMESTREAM_WRITE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "TIMESTREAM_WRITE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="TRANSFER")
    def TRANSFER(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "TRANSFER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="TRANSLATE")
    def TRANSLATE(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "TRANSLATE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VOICE_I_D")
    def VOICE_I_D(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "VOICE_I_D"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WAF")
    def WAF(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WAF"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WAF_REGIONAL")
    def WAF_REGIONAL(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WAF_REGIONAL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WAF_V2")
    def WAF_V2(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WAF_V2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WELL_ARCHITECTED")
    def WELL_ARCHITECTED(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WELL_ARCHITECTED"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WISDOM")
    def WISDOM(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WISDOM"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WORK_DOCS")
    def WORK_DOCS(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WORK_DOCS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WORK_LINK")
    def WORK_LINK(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WORK_LINK"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WORK_MAIL")
    def WORK_MAIL(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WORK_MAIL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WORK_MAIL_MESSAGE_FLOW")
    def WORK_MAIL_MESSAGE_FLOW(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WORK_MAIL_MESSAGE_FLOW"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WORK_SPACES")
    def WORK_SPACES(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WORK_SPACES"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="WORK_SPACES_WEB")
    def WORK_SPACES_WEB(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "WORK_SPACES_WEB"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="XRAY")
    def XRAY(cls) -> "AwsService":
        return typing.cast("AwsService", jsii.sget(cls, "XRAY"))

    @builtins.property
    @jsii.member(jsii_name="javaScriptName")
    def java_script_name(self) -> builtins.str:
        '''Used for simulation of service requests using the simulated execution.'''
        return typing.cast(builtins.str, jsii.get(self, "javaScriptName"))

    @builtins.property
    @jsii.member(jsii_name="namespace")
    def namespace(self) -> builtins.str:
        '''Used for declaration in SSM Automation document.'''
        return typing.cast(builtins.str, jsii.get(self, "namespace"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.BodyOrUrlProp",
    jsii_struct_bases=[],
    name_mapping={"prop_type": "propType", "value": "value"},
)
class BodyOrUrlProp:
    def __init__(self, *, prop_type: "BodyOrUrlType", value: "IStringVariable") -> None:
        '''Allow passing in a body or URL version of the property value.

        :param prop_type: Whether the body or URL was provided.
        :param value: Body or URL string.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52eae3080469f19d19715e112b158b4013e61fc81bb9355cbfda0ef72575704a)
            check_type(argname="argument prop_type", value=prop_type, expected_type=type_hints["prop_type"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "prop_type": prop_type,
            "value": value,
        }

    @builtins.property
    def prop_type(self) -> "BodyOrUrlType":
        '''Whether the body or URL was provided.'''
        result = self._values.get("prop_type")
        assert result is not None, "Required property 'prop_type' is missing"
        return typing.cast("BodyOrUrlType", result)

    @builtins.property
    def value(self) -> "IStringVariable":
        '''Body or URL string.'''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast("IStringVariable", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BodyOrUrlProp(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="@cdklabs/cdk-ssm-documents.BodyOrUrlType")
class BodyOrUrlType(enum.Enum):
    BODY = "BODY"
    URL = "URL"


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.BooleanInputProps",
    jsii_struct_bases=[],
    name_mapping={"default_value": "defaultValue", "description": "description"},
)
class BooleanInputProps:
    def __init__(
        self,
        *,
        default_value: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34a196ac72865c8e18131056e285ff9cc58be275f7aa2bb2f64be4b75648e1dc)
            check_type(argname="argument default_value", value=default_value, expected_type=type_hints["default_value"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if default_value is not None:
            self._values["default_value"] = default_value
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def default_value(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Default value to use for this input if not specified when invoking the document.

        :default: undefined
        '''
        result = self._values.get("default_value")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) The description of the input.

        :default: name
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BooleanInputProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BranchSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.BranchSimulation",
):
    '''AutomationStep implementation of aws:branch https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-branch.html.'''

    def __init__(self, step: "BranchStep") -> None:
        '''
        :param step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89bed2b01e97b0c71e0453f0eeca326ec0f39037e9140428374eafe37f3a2e61)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        jsii.create(self.__class__, self, [step])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        _inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''noop.

        The logic performed in the branch branchStep happens in the invoke() function.

        :param _inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dce4d391481fcca3abcb3d83ce8eaa599511c5ab644062958efc6b9342c49d09)
            check_type(argname="argument _inputs", value=_inputs, expected_type=type_hints["_inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [_inputs]))

    @jsii.member(jsii_name="nextStep")
    def next_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Optional["AutomationStep"]:
        '''Overrides invoke because control flow of execution is different than standard steps.

        Will traverse the choices until one evaluated to true; will skip to that choice.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5b7d256bd86527e83318e1662b34ac11dd7bed6cd69d7836cafc7f183b66f77)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Optional["AutomationStep"], jsii.invoke(self, "nextStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


class ChangeInstanceStateSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ChangeInstanceStateSimulation",
):
    '''AutomationStep implemenation for aws:changeInstanceState https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-changestate.html.'''

    def __init__(
        self,
        step: "ChangeInstanceStateStep",
        *,
        aws_invoker: "IAwsInvoker",
    ) -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b616c6aac996eb9354487c87a9c71d3970eb946c9be7d401940fc1ca1cb303f)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = AwsInvocationSimulationProps(aws_invoker=aws_invoker)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__658e512a463cefbe43a4ef743c985822db58368e649ce9b651c01010dcaec22e)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


class Choice(metaclass=jsii.JSIIMeta, jsii_type="@cdklabs/cdk-ssm-documents.Choice"):
    '''Choices are supplied to the BranchStep to determine under which conditions to jump to which steps.'''

    def __init__(
        self,
        *,
        constant: typing.Any,
        jump_to_step_name: builtins.str,
        operation: "Operation",
        variable: typing.Union["IStringVariable", "INumberVariable", "IBooleanVariable"],
    ) -> None:
        '''
        :param constant: (Required) the constant to test against the inputToTest.
        :param jump_to_step_name: A step to jump to if this choice is evaluated to true. Must reference another step in the currently executing AutomationDocument.
        :param operation: (Required) The operation used to compare the inputToTest with the constant.
        :param variable: (Required) the input used to test using the operation with the constant.
        '''
        props = ChoiceProps(
            constant=constant,
            jump_to_step_name=jump_to_step_name,
            operation=operation,
            variable=variable,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="asSsmEntry")
    def as_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :return: an object that can be used to print this choice into yaml/json format.
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "asSsmEntry", []))

    @jsii.member(jsii_name="evaluate")
    def evaluate(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.bool:
        '''Evaluates this choice against the provided inputs.

        The value keyed on the inputToTest will be tested against the declared constant using the Operation specified.

        :param inputs: -

        :return: true if the evaluation is true. False otherwise.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d02a554c8cf0f9d1a5029ad87a4bb3d96a49b7687c81c1d40a7155bbfe9e17e9)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(builtins.bool, jsii.invoke(self, "evaluate", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="constant")
    def constant(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "constant"))

    @builtins.property
    @jsii.member(jsii_name="jumpToStepName")
    def jump_to_step_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "jumpToStepName"))

    @builtins.property
    @jsii.member(jsii_name="operation")
    def operation(self) -> "Operation":
        return typing.cast("Operation", jsii.get(self, "operation"))

    @builtins.property
    @jsii.member(jsii_name="variable")
    def variable(
        self,
    ) -> typing.Union["IStringVariable", "INumberVariable", "IBooleanVariable"]:
        return typing.cast(typing.Union["IStringVariable", "INumberVariable", "IBooleanVariable"], jsii.get(self, "variable"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ChoiceProps",
    jsii_struct_bases=[],
    name_mapping={
        "constant": "constant",
        "jump_to_step_name": "jumpToStepName",
        "operation": "operation",
        "variable": "variable",
    },
)
class ChoiceProps:
    def __init__(
        self,
        *,
        constant: typing.Any,
        jump_to_step_name: builtins.str,
        operation: "Operation",
        variable: typing.Union["IStringVariable", "INumberVariable", "IBooleanVariable"],
    ) -> None:
        '''Properties for a Choice used by the BranchStep.

        :param constant: (Required) the constant to test against the inputToTest.
        :param jump_to_step_name: A step to jump to if this choice is evaluated to true. Must reference another step in the currently executing AutomationDocument.
        :param operation: (Required) The operation used to compare the inputToTest with the constant.
        :param variable: (Required) the input used to test using the operation with the constant.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c549fa9de0e40bacd62b01d538e0d5168d84aca7f1c2c4dc6304fcecca05ea2f)
            check_type(argname="argument constant", value=constant, expected_type=type_hints["constant"])
            check_type(argname="argument jump_to_step_name", value=jump_to_step_name, expected_type=type_hints["jump_to_step_name"])
            check_type(argname="argument operation", value=operation, expected_type=type_hints["operation"])
            check_type(argname="argument variable", value=variable, expected_type=type_hints["variable"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "constant": constant,
            "jump_to_step_name": jump_to_step_name,
            "operation": operation,
            "variable": variable,
        }

    @builtins.property
    def constant(self) -> typing.Any:
        '''(Required) the constant to test against the inputToTest.'''
        result = self._values.get("constant")
        assert result is not None, "Required property 'constant' is missing"
        return typing.cast(typing.Any, result)

    @builtins.property
    def jump_to_step_name(self) -> builtins.str:
        '''A step to jump to if this choice is evaluated to true.

        Must reference another step in the currently executing AutomationDocument.
        '''
        result = self._values.get("jump_to_step_name")
        assert result is not None, "Required property 'jump_to_step_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operation(self) -> "Operation":
        '''(Required) The operation used to compare the inputToTest with the constant.'''
        result = self._values.get("operation")
        assert result is not None, "Required property 'operation' is missing"
        return typing.cast("Operation", result)

    @builtins.property
    def variable(
        self,
    ) -> typing.Union["IStringVariable", "INumberVariable", "IBooleanVariable"]:
        '''(Required) the input used to test using the operation with the constant.'''
        result = self._values.get("variable")
        assert result is not None, "Required property 'variable' is missing"
        return typing.cast(typing.Union["IStringVariable", "INumberVariable", "IBooleanVariable"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ChoiceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CommandDocumentBuilder(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CommandDocumentBuilder",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="addStep")
    def add_step(self, step: "CommandStep") -> None:
        '''
        :param step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a904ee5a98cd657e13249948cfe577d8d52d51e83a7bc912fc8a4e0c87228c8)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        return typing.cast(None, jsii.invoke(self, "addStep", [step]))

    @builtins.property
    @jsii.member(jsii_name="steps")
    def steps(self) -> typing.List["CommandStep"]:
        return typing.cast(typing.List["CommandStep"], jsii.get(self, "steps"))


class CommandSimulation(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CommandSimulation",
):
    def __init__(
        self,
        command_document: "CommandDocument",
        *,
        approve_hook: typing.Optional["IApproveHook"] = None,
        aws_invoker: typing.Optional["IAwsInvoker"] = None,
        environment: typing.Optional["IEnvironment"] = None,
        input_observer: typing.Optional["IObserver"] = None,
        output_observer: typing.Optional["IObserver"] = None,
        parameter_resolver: typing.Optional["IParameterResolver"] = None,
        pause_hook: typing.Optional["IPauseHook"] = None,
        run_command_hook: typing.Optional["IRunCommandHook"] = None,
        simulation_platform: typing.Optional["Platform"] = None,
        sleep_hook: typing.Optional["ISleepHook"] = None,
        webhook: typing.Optional["IWebhook"] = None,
    ) -> None:
        '''
        :param command_document: -
        :param approve_hook: 
        :param aws_invoker: 
        :param environment: 
        :param input_observer: 
        :param output_observer: 
        :param parameter_resolver: 
        :param pause_hook: 
        :param run_command_hook: 
        :param simulation_platform: 
        :param sleep_hook: 
        :param webhook: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5664bb6893c17edc3f3cfdb53e3cf7be0f932f267ad0319c8f53d41677942e7c)
            check_type(argname="argument command_document", value=command_document, expected_type=type_hints["command_document"])
        props = SimulationProps(
            approve_hook=approve_hook,
            aws_invoker=aws_invoker,
            environment=environment,
            input_observer=input_observer,
            output_observer=output_observer,
            parameter_resolver=parameter_resolver,
            pause_hook=pause_hook,
            run_command_hook=run_command_hook,
            simulation_platform=simulation_platform,
            sleep_hook=sleep_hook,
            webhook=webhook,
        )

        jsii.create(self.__class__, self, [command_document, props])

    @jsii.member(jsii_name="start")
    def start(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> "SimulationResult":
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1dd6e27dde321fd0a2e17516f7567c8accad2b9dbb23d0782a6f5c68f81727a8)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast("SimulationResult", jsii.invoke(self, "start", [inputs]))


class CommandSimulationBase(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.CommandSimulationBase",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="executeStep")
    @abc.abstractmethod
    def execute_step(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''
        :param inputs: -
        '''
        ...


class _CommandSimulationBaseProxy(CommandSimulationBase):
    @jsii.member(jsii_name="executeStep")
    def execute_step(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57993e4f6222ff515e8a2c0103b3fc205f9730dfa7a2e9e22f73bc463a83cd2b)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(None, jsii.invoke(self, "executeStep", [inputs]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, CommandSimulationBase).__jsii_proxy_class__ = lambda : _CommandSimulationBaseProxy


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.CommandSimulationProps",
    jsii_struct_bases=[],
    name_mapping={
        "simulation_platform": "simulationPlatform",
        "environment": "environment",
    },
)
class CommandSimulationProps:
    def __init__(
        self,
        *,
        simulation_platform: "Platform",
        environment: typing.Optional["IEnvironment"] = None,
    ) -> None:
        '''
        :param simulation_platform: The Platform used in executing the command step.
        :param environment: (Optional) Specify here the environment in which to execute the scripts. Use the DockerEnvironment to execute the commands inside the docker. You can alternatively use the LoggingEnvironment which simply logs the commands or MockEnvironment which saves them for validation. Default: LoggingEnvironment
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a7970c32a6effaacd5f081fcf30742e78761a51ca97178ae2d401b11a779f726)
            check_type(argname="argument simulation_platform", value=simulation_platform, expected_type=type_hints["simulation_platform"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "simulation_platform": simulation_platform,
        }
        if environment is not None:
            self._values["environment"] = environment

    @builtins.property
    def simulation_platform(self) -> "Platform":
        '''The Platform used in executing the command step.'''
        result = self._values.get("simulation_platform")
        assert result is not None, "Required property 'simulation_platform' is missing"
        return typing.cast("Platform", result)

    @builtins.property
    def environment(self) -> typing.Optional["IEnvironment"]:
        '''(Optional) Specify here the environment in which to execute the scripts.

        Use the DockerEnvironment to execute the commands inside the docker.
        You can alternatively use the LoggingEnvironment which simply logs the commands
        or MockEnvironment which saves them for validation.

        :default: LoggingEnvironment
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional["IEnvironment"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CommandSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CommandStepSimulation(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CommandStepSimulation",
):
    def __init__(
        self,
        step: "CommandStep",
        *,
        simulation_platform: "Platform",
        environment: typing.Optional["IEnvironment"] = None,
    ) -> None:
        '''
        :param step: -
        :param simulation_platform: The Platform used in executing the command step.
        :param environment: (Optional) Specify here the environment in which to execute the scripts. Use the DockerEnvironment to execute the commands inside the docker. You can alternatively use the LoggingEnvironment which simply logs the commands or MockEnvironment which saves them for validation. Default: LoggingEnvironment
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0e1af41db34838e50f961ac56116d8a8812d0ec050e1c402dd82961d5c1e24b)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = CommandSimulationProps(
            simulation_platform=simulation_platform, environment=environment
        )

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="invoke")
    def invoke(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> "SimulationResult":
        '''Invokes the current step on the input and will return a SimulationResult.

        :param inputs: must contain all of the inputs declared by the current step.

        :return: a SimulationResult with the step outputs in the case of success or stacktrace in the case of failure.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df1f3803c998ada8bd4d75af336574604c59e72d48899dee26d0566f60d8fd23)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast("SimulationResult", jsii.invoke(self, "invoke", [inputs]))

    @jsii.member(jsii_name="prependSelf")
    def _prepend_self(
        self,
        future_steps: typing.Sequence[builtins.str],
    ) -> typing.List[builtins.str]:
        '''Adds this step name to the list of executed steps.

        Since the steps are invoked as a chain, the current step is prepended as invocation stack is popped.

        :param future_steps: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6419b2395fc46dcbcce7fd444c413e6f312515fe48c382418bf92459b6d8986)
            check_type(argname="argument future_steps", value=future_steps, expected_type=type_hints["future_steps"])
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "prependSelf", [future_steps]))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> "RequiredCommandSimulationProps":
        return typing.cast("RequiredCommandSimulationProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="step")
    def step(self) -> "CommandStep":
        return typing.cast("CommandStep", jsii.get(self, "step"))


class CopyImageSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CopyImageSimulation",
):
    '''AutomationStep implemenation for aws:copyImage https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-copyimage.html.'''

    def __init__(self, step: "CopyImageStep", *, aws_invoker: "IAwsInvoker") -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db0ce72e063e8020406e7ced6f68ba6119dc03d32ff64b6e935b88e55ef23778)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = AwsInvocationSimulationProps(aws_invoker=aws_invoker)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe5d159a965fa3c8c617b2779191034196aa02d12c20df78e75e34a6a0735721)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


class CreateImageSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CreateImageSimulation",
):
    '''AutomationStep implemenation for aws:createImage https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-create.html.'''

    def __init__(self, step: "CreateImageStep", *, aws_invoker: "IAwsInvoker") -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51f01f033e9da3982b7e984984500fec14f6b2d7fdfb3a6bb0fdd88b83148164)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = AwsInvocationSimulationProps(aws_invoker=aws_invoker)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b7f688902e8db84288332c7e95432375ca85a3d27566d0536e8fd4aa6a2f596)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


class CreateStackSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CreateStackSimulation",
):
    '''AutomationStep implementation for aws:createStack https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-createstack.html.'''

    def __init__(
        self,
        step: "CreateStackStep",
        *,
        aws_invoker: "IAwsInvoker",
        parameter_resolver: "IParameterResolver",
        sleep_hook: "ISleepHook",
    ) -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param parameter_resolver: (Optional) Resolver for secure strings in parameters. Required to simulate if using tokens in parameters input. Default: - Treats parameters as literal
        :param sleep_hook: (Optional) Whether to really perform a pause of the runtime. To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class. Default: SleeperImpl
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__935d04fa6968a0f0e4c36e797ced6a22c0048ab1513680c0e4bcdf44f8e08e5e)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = CreateStackSimulationProps(
            aws_invoker=aws_invoker,
            parameter_resolver=parameter_resolver,
            sleep_hook=sleep_hook,
        )

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__579411a205724eedf4a47963863c7d7219789ff990c4002a389ee875132368ec)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.CreateStackSimulationProps",
    jsii_struct_bases=[],
    name_mapping={
        "aws_invoker": "awsInvoker",
        "parameter_resolver": "parameterResolver",
        "sleep_hook": "sleepHook",
    },
)
class CreateStackSimulationProps:
    def __init__(
        self,
        *,
        aws_invoker: "IAwsInvoker",
        parameter_resolver: "IParameterResolver",
        sleep_hook: "ISleepHook",
    ) -> None:
        '''Properties for CreateStackStep.

        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param parameter_resolver: (Optional) Resolver for secure strings in parameters. Required to simulate if using tokens in parameters input. Default: - Treats parameters as literal
        :param sleep_hook: (Optional) Whether to really perform a pause of the runtime. To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class. Default: SleeperImpl
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f5ba6a684b638b28689132e40fb37628bde6ba59ade54f41ae20982f58ad64a)
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument parameter_resolver", value=parameter_resolver, expected_type=type_hints["parameter_resolver"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "aws_invoker": aws_invoker,
            "parameter_resolver": parameter_resolver,
            "sleep_hook": sleep_hook,
        }

    @builtins.property
    def aws_invoker(self) -> "IAwsInvoker":
        '''(Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call).

        :default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        result = self._values.get("aws_invoker")
        assert result is not None, "Required property 'aws_invoker' is missing"
        return typing.cast("IAwsInvoker", result)

    @builtins.property
    def parameter_resolver(self) -> "IParameterResolver":
        '''(Optional) Resolver for secure strings in parameters.

        Required to simulate if using tokens in parameters input.

        :default: - Treats parameters as literal
        '''
        result = self._values.get("parameter_resolver")
        assert result is not None, "Required property 'parameter_resolver' is missing"
        return typing.cast("IParameterResolver", result)

    @builtins.property
    def sleep_hook(self) -> "ISleepHook":
        '''(Optional) Whether to really perform a pause of the runtime.

        To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class.

        :default: SleeperImpl
        '''
        result = self._values.get("sleep_hook")
        assert result is not None, "Required property 'sleep_hook' is missing"
        return typing.cast("ISleepHook", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CreateStackSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CreateTagsSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CreateTagsSimulation",
):
    '''AutomationStep implemenation for aws:createTags https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-createtag.html.'''

    def __init__(
        self,
        step: "CreateTagsStep",
        *,
        aws_invoker: "IAwsInvoker",
        sleep_hook: "ISleepHook",
    ) -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param sleep_hook: (Optional) Whether to really perform a pause of the runtime. To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class. Default: SleeperImpl
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19addadfbbfafd4c98e2535c68aad0ae0179e68fb1325f1c15dee6c7cd5c8fc0)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = CreateTagsSimulationProps(
            aws_invoker=aws_invoker, sleep_hook=sleep_hook
        )

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f184547cd3dee0f0b0f5ad975c1ee467af9cf4f97331eaea9ecc56cdd7734e0b)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.CreateTagsSimulationProps",
    jsii_struct_bases=[],
    name_mapping={"aws_invoker": "awsInvoker", "sleep_hook": "sleepHook"},
)
class CreateTagsSimulationProps:
    def __init__(self, *, aws_invoker: "IAwsInvoker", sleep_hook: "ISleepHook") -> None:
        '''Properties for CreateTagStep.

        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param sleep_hook: (Optional) Whether to really perform a pause of the runtime. To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class. Default: SleeperImpl
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71f87212e52225fdb1204c062421a3fabcac174fa933397cbb0e35733427c913)
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "aws_invoker": aws_invoker,
            "sleep_hook": sleep_hook,
        }

    @builtins.property
    def aws_invoker(self) -> "IAwsInvoker":
        '''(Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call).

        :default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        result = self._values.get("aws_invoker")
        assert result is not None, "Required property 'aws_invoker' is missing"
        return typing.cast("IAwsInvoker", result)

    @builtins.property
    def sleep_hook(self) -> "ISleepHook":
        '''(Optional) Whether to really perform a pause of the runtime.

        To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class.

        :default: SleeperImpl
        '''
        result = self._values.get("sleep_hook")
        assert result is not None, "Required property 'sleep_hook' is missing"
        return typing.cast("ISleepHook", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CreateTagsSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataType(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DataType",
):
    '''JSII does not allow functions or constants declared in an enum class directly.

    Therefore, interaction with DataTypeEnum happens through this class.
    '''

    def __init__(self, data_type_enum: "DataTypeEnum") -> None:
        '''
        :param data_type_enum: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcdc44ad44f098ff5e1363529b469642a6904200aa7e07e32f3671eeac53f460)
            check_type(argname="argument data_type_enum", value=data_type_enum, expected_type=type_hints["data_type_enum"])
        jsii.create(self.__class__, self, [data_type_enum])

    @jsii.member(jsii_name="fromDataType")
    @builtins.classmethod
    def from_data_type(cls, ssm_data_type: builtins.str) -> "DataType":
        '''
        :param ssm_data_type: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9dcc1bad3d996eb40ef32b5e39b7668dc1da50420d37770ada5ebacdfeff3ed9)
            check_type(argname="argument ssm_data_type", value=ssm_data_type, expected_type=type_hints["ssm_data_type"])
        return typing.cast("DataType", jsii.sinvoke(cls, "fromDataType", [ssm_data_type]))

    @jsii.member(jsii_name="toSsmString")
    def to_ssm_string(self) -> builtins.str:
        '''
        :return: the SSM string representation of this DataType
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "toSsmString", []))

    @jsii.member(jsii_name="validateType")
    def validate_type(self, val: typing.Any) -> builtins.bool:
        '''
        :param val: -

        :return: true if the input variable matches the associated dataTypeEnum
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c01782e64207b81c0afc65680d4e008fb5e2470716df80e3c38784091a7aff3)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        return typing.cast(builtins.bool, jsii.invoke(self, "validateType", [val]))

    @builtins.property
    @jsii.member(jsii_name="dataTypeEnum")
    def data_type_enum(self) -> "DataTypeEnum":
        return typing.cast("DataTypeEnum", jsii.get(self, "dataTypeEnum"))


@jsii.enum(jsii_type="@cdklabs/cdk-ssm-documents.DataTypeEnum")
class DataTypeEnum(enum.Enum):
    '''DataTypes as supported by SSM Documents.'''

    STRING = "STRING"
    INTEGER = "INTEGER"
    BOOLEAN = "BOOLEAN"
    STRING_LIST = "STRING_LIST"
    STRING_MAP = "STRING_MAP"
    MAP_LIST = "MAP_LIST"


class DeleteImageSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DeleteImageSimulation",
):
    '''AutomationStep implementation for aws:deleteImage https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-delete.html.'''

    def __init__(
        self,
        step: "DeleteImageStep",
        *,
        aws_invoker: typing.Optional["IAwsInvoker"] = None,
        sleep_hook: typing.Optional["ISleepHook"] = None,
    ) -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param sleep_hook: (Optional) Whether to really perform a pause of the runtime. To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class. Default: SleeperImpl
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e13a0a84207f42ec17f0f0d45449bbef1d7e01eb4028a25fe47bb77a621818f)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = DeleteImageSimulationProps(
            aws_invoker=aws_invoker, sleep_hook=sleep_hook
        )

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fafe9abace5f65ab03f3950190c2a7872a94df18aceec43dc927170c0874a55b)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.DeleteImageSimulationProps",
    jsii_struct_bases=[],
    name_mapping={"aws_invoker": "awsInvoker", "sleep_hook": "sleepHook"},
)
class DeleteImageSimulationProps:
    def __init__(
        self,
        *,
        aws_invoker: typing.Optional["IAwsInvoker"] = None,
        sleep_hook: typing.Optional["ISleepHook"] = None,
    ) -> None:
        '''Properties for DeleteImageStep.

        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param sleep_hook: (Optional) Whether to really perform a pause of the runtime. To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class. Default: SleeperImpl
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f27458eb46e47b8b0b7f23f7893c9929951350f36f1cd60009ebcf9535ff74aa)
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if aws_invoker is not None:
            self._values["aws_invoker"] = aws_invoker
        if sleep_hook is not None:
            self._values["sleep_hook"] = sleep_hook

    @builtins.property
    def aws_invoker(self) -> typing.Optional["IAwsInvoker"]:
        '''(Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call).

        :default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        result = self._values.get("aws_invoker")
        return typing.cast(typing.Optional["IAwsInvoker"], result)

    @builtins.property
    def sleep_hook(self) -> typing.Optional["ISleepHook"]:
        '''(Optional) Whether to really perform a pause of the runtime.

        To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class.

        :default: SleeperImpl
        '''
        result = self._values.get("sleep_hook")
        return typing.cast(typing.Optional["ISleepHook"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DeleteImageSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DeleteStackSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DeleteStackSimulation",
):
    '''AutomationStep implemenation for aws:deleteStack https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-deletestack.html.'''

    def __init__(self, step: "DeleteStackStep", *, aws_invoker: "IAwsInvoker") -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__556711aed5a48c0ffe5cede99a35b83ed8843473fc31824aa7874677ac8a1041)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = AwsInvocationSimulationProps(aws_invoker=aws_invoker)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5631e62e1386d58975ddfce72668883a4a1d2ba2f50ac397d404ba8d3b1a5ee9)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


@jsii.enum(jsii_type="@cdklabs/cdk-ssm-documents.DocumentFormat")
class DocumentFormat(enum.Enum):
    JSON = "JSON"
    YAML = "YAML"


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.DocumentOutput",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "output_type": "outputType"},
)
class DocumentOutput:
    def __init__(self, *, name: builtins.str, output_type: DataTypeEnum) -> None:
        '''Outputs from a document via one of the steps.

        The outputs are available for use in other documents calling this document via aws:executeAutomation.
        The outputs returned from an automation document are returned as a String list named "ouptuts".

        :param name: The step and name (in STEP.NAME format) to identify an output expected from one of the document steps. The name must therefore identify a step and an output or will fail validation.
        :param output_type: The DataType expected by this output. This will be validated in simulation mode and will also be used when printing to yaml/json.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__626d454bd9cb559c4c62c6a0c06a3cc6d5ce2c149355e72a54ecf7f4ea7b38a0)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_type", value=output_type, expected_type=type_hints["output_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "output_type": output_type,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The step and name (in STEP.NAME format) to identify an output expected from one of the document steps. The name must therefore identify a step and an output or will fail validation.

        Example::

            MyStep.MyOutput
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def output_type(self) -> DataTypeEnum:
        '''The DataType expected by this output.

        This will be validated in simulation mode and will also be used when printing to yaml/json.
        '''
        result = self._values.get("output_type")
        assert result is not None, "Required property 'output_type' is missing"
        return typing.cast(DataTypeEnum, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DocumentOutput(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DocumentSource(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.DocumentSource",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromArn")
    @builtins.classmethod
    def from_arn(cls, arn: "IStringVariable") -> "DocumentSource":
        '''
        :param arn: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__723b1c1575d3425fbda3a2c75197f206c3c0819c98e96fabc00fe4118b955b1b)
            check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
        return typing.cast("DocumentSource", jsii.sinvoke(cls, "fromArn", [arn]))

    @jsii.member(jsii_name="fromName")
    @builtins.classmethod
    def from_name(
        cls,
        name: "IStringVariable",
        version: typing.Optional["IStringVariable"] = None,
    ) -> "DocumentSource":
        '''
        :param name: -
        :param version: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eaa198d9dc39809d034dd3f9d90edfe9a48056901beddca4649be4c2648f6a66)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        return typing.cast("DocumentSource", jsii.sinvoke(cls, "fromName", [name, version]))

    @jsii.member(jsii_name="formatRequest")
    @abc.abstractmethod
    def format_request(self) -> typing.Mapping[builtins.str, typing.Any]:
        ...

    @jsii.member(jsii_name="requiredInputs")
    @abc.abstractmethod
    def required_inputs(self) -> typing.List[builtins.str]:
        ...


class _DocumentSourceProxy(DocumentSource):
    @jsii.member(jsii_name="formatRequest")
    def format_request(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatRequest", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, DocumentSource).__jsii_proxy_class__ = lambda : _DocumentSourceProxy


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.EnvironmentProps",
    jsii_struct_bases=[],
    name_mapping={"environment": "environment"},
)
class EnvironmentProps:
    def __init__(self, *, environment: "IEnvironment") -> None:
        '''
        :param environment: (Optional) Specify here the environment in which to execute the scripts. Use the DockerEnvironment to execute the commands inside the docker. You can alternatively use the LoggingEnvironment which simply logs the commands or MockEnvironment which saves them for validation. Default: LoggingEnvironment
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b992e08b58a570f6fa880e3321a36daf2b972b8ee8dedc2668069d3d7290cfc0)
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "environment": environment,
        }

    @builtins.property
    def environment(self) -> "IEnvironment":
        '''(Optional) Specify here the environment in which to execute the scripts.

        Use the DockerEnvironment to execute the commands inside the docker.
        You can alternatively use the LoggingEnvironment which simply logs the commands
        or MockEnvironment which saves them for validation.

        :default: LoggingEnvironment
        '''
        result = self._values.get("environment")
        assert result is not None, "Required property 'environment' is missing"
        return typing.cast("IEnvironment", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnvironmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ExecuteAutomationOutputs",
    jsii_struct_bases=[],
    name_mapping={
        "execution_id": "executionId",
        "status": "status",
        "output": "output",
    },
)
class ExecuteAutomationOutputs:
    def __init__(
        self,
        *,
        execution_id: builtins.str,
        status: builtins.str,
        output: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Outputs for aws:executeAutomation.

        :param execution_id: The ID of the secondary automation.
        :param status: The status of the secondary automation.
        :param output: The output generated by the secondary automation.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f689cf9b22a3f6a3d00000164e9492e78ae28cedae8482dce5929420201cad4)
            check_type(argname="argument execution_id", value=execution_id, expected_type=type_hints["execution_id"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument output", value=output, expected_type=type_hints["output"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "execution_id": execution_id,
            "status": status,
        }
        if output is not None:
            self._values["output"] = output

    @builtins.property
    def execution_id(self) -> builtins.str:
        '''The ID of the secondary automation.'''
        result = self._values.get("execution_id")
        assert result is not None, "Required property 'execution_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def status(self) -> builtins.str:
        '''The status of the secondary automation.'''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def output(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The output generated by the secondary automation.'''
        result = self._values.get("output")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExecuteAutomationOutputs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ExecuteAutomationProps",
    jsii_struct_bases=[],
    name_mapping={
        "document_name": "documentName",
        "document_version": "documentVersion",
        "max_concurrency": "maxConcurrency",
        "max_errors": "maxErrors",
        "runtime_parameters": "runtimeParameters",
        "tags": "tags",
        "target_locations": "targetLocations",
        "target_maps": "targetMaps",
        "target_parameter_name": "targetParameterName",
        "targets": "targets",
    },
)
class ExecuteAutomationProps:
    def __init__(
        self,
        *,
        document_name: builtins.str,
        document_version: typing.Optional[builtins.str] = None,
        max_concurrency: typing.Optional[builtins.str] = None,
        max_errors: typing.Optional[builtins.str] = None,
        runtime_parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        tags: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_locations: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_maps: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_parameter_name: typing.Optional[builtins.str] = None,
        targets: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Inputs for aws:executeAutomation.

        :param document_name: 
        :param document_version: 
        :param max_concurrency: 
        :param max_errors: 
        :param runtime_parameters: 
        :param tags: 
        :param target_locations: 
        :param target_maps: 
        :param target_parameter_name: 
        :param targets: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09ea8eaaa60d1be9af69af8b2d979194c3cd08714a381ba54f2d8c4e48f56e5f)
            check_type(argname="argument document_name", value=document_name, expected_type=type_hints["document_name"])
            check_type(argname="argument document_version", value=document_version, expected_type=type_hints["document_version"])
            check_type(argname="argument max_concurrency", value=max_concurrency, expected_type=type_hints["max_concurrency"])
            check_type(argname="argument max_errors", value=max_errors, expected_type=type_hints["max_errors"])
            check_type(argname="argument runtime_parameters", value=runtime_parameters, expected_type=type_hints["runtime_parameters"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument target_locations", value=target_locations, expected_type=type_hints["target_locations"])
            check_type(argname="argument target_maps", value=target_maps, expected_type=type_hints["target_maps"])
            check_type(argname="argument target_parameter_name", value=target_parameter_name, expected_type=type_hints["target_parameter_name"])
            check_type(argname="argument targets", value=targets, expected_type=type_hints["targets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "document_name": document_name,
        }
        if document_version is not None:
            self._values["document_version"] = document_version
        if max_concurrency is not None:
            self._values["max_concurrency"] = max_concurrency
        if max_errors is not None:
            self._values["max_errors"] = max_errors
        if runtime_parameters is not None:
            self._values["runtime_parameters"] = runtime_parameters
        if tags is not None:
            self._values["tags"] = tags
        if target_locations is not None:
            self._values["target_locations"] = target_locations
        if target_maps is not None:
            self._values["target_maps"] = target_maps
        if target_parameter_name is not None:
            self._values["target_parameter_name"] = target_parameter_name
        if targets is not None:
            self._values["targets"] = targets

    @builtins.property
    def document_name(self) -> builtins.str:
        result = self._values.get("document_name")
        assert result is not None, "Required property 'document_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def document_version(self) -> typing.Optional[builtins.str]:
        result = self._values.get("document_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_concurrency(self) -> typing.Optional[builtins.str]:
        result = self._values.get("max_concurrency")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_errors(self) -> typing.Optional[builtins.str]:
        result = self._values.get("max_errors")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def runtime_parameters(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        result = self._values.get("runtime_parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def tags(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]], result)

    @builtins.property
    def target_locations(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        result = self._values.get("target_locations")
        return typing.cast(typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]], result)

    @builtins.property
    def target_maps(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        result = self._values.get("target_maps")
        return typing.cast(typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]], result)

    @builtins.property
    def target_parameter_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("target_parameter_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def targets(
        self,
    ) -> typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]]:
        result = self._values.get("targets")
        return typing.cast(typing.Optional[typing.List[typing.Mapping[builtins.str, typing.Any]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExecuteAutomationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExecuteScriptSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ExecuteScriptSimulation",
):
    '''AutomationStep implementation for aws:executeScript https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-executeScript.html.'''

    def __init__(self, step: "ExecuteScriptStep") -> None:
        '''
        :param step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b112d195ddf6f45d17d6bde4f2ee396f32699bd5406884a9e6326ce0df4107ce)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        jsii.create(self.__class__, self, [step])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Runs the simulation.

        Nests returned object into a "Payload" key to mimic SSM behavior.
        Switch by language and execute code based on specified language.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c63b4a32c66b2f6e14c8e12a7d0ee0c4b7dede95e44c00e1d3b3869c23b15d40)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="executeScriptStep")
    def execute_script_step(self) -> "ExecuteScriptStep":
        return typing.cast("ExecuteScriptStep", jsii.get(self, "executeScriptStep"))


class ExecuteStateMachineSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ExecuteStateMachineSimulation",
):
    '''AutomationStep implementation of `aws:executeStateMachine <https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-executeStateMachine.html>`_.'''

    def __init__(
        self,
        step: "ExecuteStateMachineStep",
        *,
        aws_invoker: "IAwsInvoker",
    ) -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d080b39798a7db3e619a4e49f4b2c1d3d3ccaa91040638f2508bb66e582a5e78)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = AwsInvocationSimulationProps(aws_invoker=aws_invoker)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe15717eaa8f66b5aa4ca4a7c6af52ace386dc122fc83e03c63124c668bce54d)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="executeStateMachineStep")
    def execute_state_machine_step(self) -> "ExecuteStateMachineStep":
        return typing.cast("ExecuteStateMachineStep", jsii.get(self, "executeStateMachineStep"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> AwsInvocationSimulationProps:
        return typing.cast(AwsInvocationSimulationProps, jsii.get(self, "props"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.GitContentProps",
    jsii_struct_bases=[],
    name_mapping={
        "repository": "repository",
        "branch": "branch",
        "commit_id": "commitId",
        "password": "password",
        "private_ssh_key": "privateSshKey",
        "skip_host_key_checking": "skipHostKeyChecking",
        "user_name": "userName",
    },
)
class GitContentProps:
    def __init__(
        self,
        *,
        repository: "IStringVariable",
        branch: typing.Optional[builtins.str] = None,
        commit_id: typing.Optional[builtins.str] = None,
        password: typing.Optional["SecureVariable"] = None,
        private_ssh_key: typing.Optional["SecureVariable"] = None,
        skip_host_key_checking: typing.Optional["IBooleanVariable"] = None,
        user_name: typing.Optional["SecureVariable"] = None,
    ) -> None:
        '''Properties for sourceType Git.

        :param repository: The Git repository URL to the file or directory you want to download.
        :param branch: The default is master. branch parameter is required only if your SSM document is stored in a branch other than master. Supply either commitId or branch (or neither).
        :param commit_id: The default is head. To use the version of your SSM document in a commit other than the latest, specify the full commit ID. For example: "bbc1ddb94...b76d3bEXAMPLE". Supply either commitId or branch (or neither).
        :param password: The password to use when connecting to the repository you specify using HTTP.
        :param private_ssh_key: The SSH key to use when connecting to the repository you specify.
        :param skip_host_key_checking: Determines the value of the StrictHostKeyChecking option when connecting to the repository you specify. The default value is false.
        :param user_name: The username to use when connecting to the repository you specify using HTTP.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d651cd09c2787c55247c71b47250c62f142a04041f7ad36783e2dfad71f0d8e)
            check_type(argname="argument repository", value=repository, expected_type=type_hints["repository"])
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument commit_id", value=commit_id, expected_type=type_hints["commit_id"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument private_ssh_key", value=private_ssh_key, expected_type=type_hints["private_ssh_key"])
            check_type(argname="argument skip_host_key_checking", value=skip_host_key_checking, expected_type=type_hints["skip_host_key_checking"])
            check_type(argname="argument user_name", value=user_name, expected_type=type_hints["user_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "repository": repository,
        }
        if branch is not None:
            self._values["branch"] = branch
        if commit_id is not None:
            self._values["commit_id"] = commit_id
        if password is not None:
            self._values["password"] = password
        if private_ssh_key is not None:
            self._values["private_ssh_key"] = private_ssh_key
        if skip_host_key_checking is not None:
            self._values["skip_host_key_checking"] = skip_host_key_checking
        if user_name is not None:
            self._values["user_name"] = user_name

    @builtins.property
    def repository(self) -> "IStringVariable":
        '''The Git repository URL to the file or directory you want to download.'''
        result = self._values.get("repository")
        assert result is not None, "Required property 'repository' is missing"
        return typing.cast("IStringVariable", result)

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The default is master.

        branch parameter is required only if your SSM document is stored in a branch other than master.
        Supply either commitId or branch (or neither).

        Example::

            main
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def commit_id(self) -> typing.Optional[builtins.str]:
        '''The default is head.

        To use the version of your SSM document in a commit other than the latest, specify the full commit ID.
        For example: "bbc1ddb94...b76d3bEXAMPLE".
        Supply either commitId or branch (or neither).
        '''
        result = self._values.get("commit_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def password(self) -> typing.Optional["SecureVariable"]:
        '''The password to use when connecting to the repository you specify using HTTP.'''
        result = self._values.get("password")
        return typing.cast(typing.Optional["SecureVariable"], result)

    @builtins.property
    def private_ssh_key(self) -> typing.Optional["SecureVariable"]:
        '''The SSH key to use when connecting to the repository you specify.'''
        result = self._values.get("private_ssh_key")
        return typing.cast(typing.Optional["SecureVariable"], result)

    @builtins.property
    def skip_host_key_checking(self) -> typing.Optional["IBooleanVariable"]:
        '''Determines the value of the StrictHostKeyChecking option when connecting to the repository you specify.

        The default value is false.
        '''
        result = self._values.get("skip_host_key_checking")
        return typing.cast(typing.Optional["IBooleanVariable"], result)

    @builtins.property
    def user_name(self) -> typing.Optional["SecureVariable"]:
        '''The username to use when connecting to the repository you specify using HTTP.'''
        result = self._values.get("user_name")
        return typing.cast(typing.Optional["SecureVariable"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GitContentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.GitHubContentProps",
    jsii_struct_bases=[],
    name_mapping={
        "owner": "owner",
        "path": "path",
        "repository": "repository",
        "token_info": "tokenInfo",
        "branch": "branch",
        "commit_id": "commitId",
    },
)
class GitHubContentProps:
    def __init__(
        self,
        *,
        owner: "IStringVariable",
        path: "IStringVariable",
        repository: "IStringVariable",
        token_info: "SecureVariable",
        branch: typing.Optional[builtins.str] = None,
        commit_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for sourceType GitHub.

        :param owner: The repository owner.
        :param path: The path to the file or directory you want to download.
        :param repository: The name of the repository.
        :param token_info: The Systems Manager parameter (a SecureString parameter) where you store your GitHub access token information.
        :param branch: The default is master. branch parameter is required only if your SSM document is stored in a branch other than master. Supply either commitId or branch (or neither).
        :param commit_id: The default is head. To use the version of your SSM document in a commit other than the latest, specify the full commit ID. For example: "bbc1ddb94...b76d3bEXAMPLE". Supply either commitId or branch (or neither).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1346c493491376c42d9d088205e4b3fbef5ce3ebd68e9d3c4571a87b61a6776e)
            check_type(argname="argument owner", value=owner, expected_type=type_hints["owner"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument repository", value=repository, expected_type=type_hints["repository"])
            check_type(argname="argument token_info", value=token_info, expected_type=type_hints["token_info"])
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument commit_id", value=commit_id, expected_type=type_hints["commit_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "owner": owner,
            "path": path,
            "repository": repository,
            "token_info": token_info,
        }
        if branch is not None:
            self._values["branch"] = branch
        if commit_id is not None:
            self._values["commit_id"] = commit_id

    @builtins.property
    def owner(self) -> "IStringVariable":
        '''The repository owner.'''
        result = self._values.get("owner")
        assert result is not None, "Required property 'owner' is missing"
        return typing.cast("IStringVariable", result)

    @builtins.property
    def path(self) -> "IStringVariable":
        '''The path to the file or directory you want to download.'''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast("IStringVariable", result)

    @builtins.property
    def repository(self) -> "IStringVariable":
        '''The name of the repository.'''
        result = self._values.get("repository")
        assert result is not None, "Required property 'repository' is missing"
        return typing.cast("IStringVariable", result)

    @builtins.property
    def token_info(self) -> "SecureVariable":
        '''The Systems Manager parameter (a SecureString parameter) where you store your GitHub access token information.'''
        result = self._values.get("token_info")
        assert result is not None, "Required property 'token_info' is missing"
        return typing.cast("SecureVariable", result)

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''The default is master.

        branch parameter is required only if your SSM document is stored in a branch other than master.
        Supply either commitId or branch (or neither).

        Example::

            main
        '''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def commit_id(self) -> typing.Optional[builtins.str]:
        '''The default is head.

        To use the version of your SSM document in a commit other than the latest, specify the full commit ID.
        For example: "bbc1ddb94...b76d3bEXAMPLE".
        Supply either commitId or branch (or neither).
        '''
        result = self._values.get("commit_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GitHubContentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class HelloWorld(
    _aws_cdk_ceddda9d.Stack,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HelloWorld",
):
    def __init__(self, app: _constructs_77d1e7e8.Construct, id: builtins.str) -> None:
        '''
        :param app: -
        :param id: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3828217be81fdb1fab2c89e88e81e8e11044140d9d6773762589efb801bd236)
            check_type(argname="argument app", value=app, expected_type=type_hints["app"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        jsii.create(self.__class__, self, [app, id])


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.HttpContentProps",
    jsii_struct_bases=[],
    name_mapping={
        "url": "url",
        "allow_insecure_download": "allowInsecureDownload",
        "auth_method": "authMethod",
    },
)
class HttpContentProps:
    def __init__(
        self,
        *,
        url: "IStringVariable",
        allow_insecure_download: typing.Optional["IBooleanVariable"] = None,
        auth_method: typing.Optional[AuthMethod] = None,
    ) -> None:
        '''Properties for sourceType HTTP.

        :param url: The URL to the file or directory you want to download.
        :param allow_insecure_download: Determines whether a download can be performed over a connection that isn't encrypted with Secure Socket Layer (SSL) or Transport Layer Security (TLS). The default value is false. We don't recommend performing downloads without encryption. If you choose to do so, you assume all associated risks. Security is a shared responsibility between AWS and you. This is described as the shared responsibility model. To learn more, see the shared responsibility model.
        :param auth_method: Determines whether a username and password are used for authentication when connecting to the url you specify. If you specify Basic or Digest, you must provide values for the username and password parameters. To use the Digest method, SSM Agent version 3.0.1181.0 or later must be installed on your instance. The Digest method supports MD5 and SHA256 encryption.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1eed361121fb70e9242919eb1716231d1e5701c59894484b2bd71865ac94bb2c)
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument allow_insecure_download", value=allow_insecure_download, expected_type=type_hints["allow_insecure_download"])
            check_type(argname="argument auth_method", value=auth_method, expected_type=type_hints["auth_method"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "url": url,
        }
        if allow_insecure_download is not None:
            self._values["allow_insecure_download"] = allow_insecure_download
        if auth_method is not None:
            self._values["auth_method"] = auth_method

    @builtins.property
    def url(self) -> "IStringVariable":
        '''The URL to the file or directory you want to download.'''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast("IStringVariable", result)

    @builtins.property
    def allow_insecure_download(self) -> typing.Optional["IBooleanVariable"]:
        '''Determines whether a download can be performed over a connection that isn't encrypted with Secure Socket Layer (SSL) or Transport Layer Security (TLS).

        The default value is false. We don't recommend performing downloads without encryption. If you choose to do so, you assume all associated risks.
        Security is a shared responsibility between AWS and you. This is described as the shared responsibility model. To learn more, see the shared responsibility model.
        '''
        result = self._values.get("allow_insecure_download")
        return typing.cast(typing.Optional["IBooleanVariable"], result)

    @builtins.property
    def auth_method(self) -> typing.Optional[AuthMethod]:
        '''Determines whether a username and password are used for authentication when connecting to the url you specify.

        If you specify Basic or Digest, you must provide values for the username and password parameters.
        To use the Digest method, SSM Agent version 3.0.1181.0 or later must be installed on your instance. The Digest method supports MD5 and SHA256 encryption.
        '''
        result = self._values.get("auth_method")
        return typing.cast(typing.Optional[AuthMethod], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HttpContentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IApproveHook")
class IApproveHook(typing_extensions.Protocol):
    '''This can be used to provide a hook for approval implementation for ApproveStep.'''

    @jsii.member(jsii_name="ask")
    def ask(self, approver: builtins.str) -> builtins.bool:
        '''Ask for approval.

        :param approver: -
        '''
        ...


class _IApproveHookProxy:
    '''This can be used to provide a hook for approval implementation for ApproveStep.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IApproveHook"

    @jsii.member(jsii_name="ask")
    def ask(self, approver: builtins.str) -> builtins.bool:
        '''Ask for approval.

        :param approver: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ad0b0575fb772422c104eb423e9142d1b9f3057642819ccb4aef0825e96fd99)
            check_type(argname="argument approver", value=approver, expected_type=type_hints["approver"])
        return typing.cast(builtins.bool, jsii.invoke(self, "ask", [approver]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IApproveHook).__jsii_proxy_class__ = lambda : _IApproveHookProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IAutomationComponent")
class IAutomationComponent(typing_extensions.Protocol):
    @jsii.member(jsii_name="addToDocument")
    def add_to_document(self, doc: AutomationDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        ...


class _IAutomationComponentProxy:
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IAutomationComponent"

    @jsii.member(jsii_name="addToDocument")
    def add_to_document(self, doc: AutomationDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a838b27b63e38ae411c9cc8ec0709a16e39150b06608c5d3fbd015f87943486c)
            check_type(argname="argument doc", value=doc, expected_type=type_hints["doc"])
        return typing.cast(None, jsii.invoke(self, "addToDocument", [doc]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAutomationComponent).__jsii_proxy_class__ = lambda : _IAutomationComponentProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IAwsInvoker")
class IAwsInvoker(typing_extensions.Protocol):
    '''Aws invoker interface.

    This can be used to provide a hook for AWS invocation of steps so as to mock AWS behavior for simulation runs.
    '''

    @jsii.member(jsii_name="invoke")
    def invoke(
        self,
        *,
        aws_api: builtins.str,
        aws_params: typing.Mapping[builtins.str, typing.Any],
        service: AwsService,
    ) -> typing.Any:
        '''Invoke AWS with the provided invocation request.

        :param aws_api: (Required) AWS api to invoke; should be referenced using lowerCamelCase.
        :param aws_params: (Required )AWS params.
        :param service: (Required) AWS service to invoke.

        :return: the AWS response object

        :see: Invocation
        '''
        ...


class _IAwsInvokerProxy:
    '''Aws invoker interface.

    This can be used to provide a hook for AWS invocation of steps so as to mock AWS behavior for simulation runs.
    '''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IAwsInvoker"

    @jsii.member(jsii_name="invoke")
    def invoke(
        self,
        *,
        aws_api: builtins.str,
        aws_params: typing.Mapping[builtins.str, typing.Any],
        service: AwsService,
    ) -> typing.Any:
        '''Invoke AWS with the provided invocation request.

        :param aws_api: (Required) AWS api to invoke; should be referenced using lowerCamelCase.
        :param aws_params: (Required )AWS params.
        :param service: (Required) AWS service to invoke.

        :return: the AWS response object

        :see: Invocation
        '''
        invocation = Invocation(
            aws_api=aws_api, aws_params=aws_params, service=service
        )

        return typing.cast(typing.Any, jsii.invoke(self, "invoke", [invocation]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAwsInvoker).__jsii_proxy_class__ = lambda : _IAwsInvokerProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.ICommandComponent")
class ICommandComponent(typing_extensions.Protocol):
    @jsii.member(jsii_name="addToDocument")
    def add_to_document(self, doc: CommandDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        ...


class _ICommandComponentProxy:
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.ICommandComponent"

    @jsii.member(jsii_name="addToDocument")
    def add_to_document(self, doc: CommandDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c05618c97bc0055fe58b613bd37402fd6deed9bf70c65fbd5c1f5efd9e8bdabf)
            check_type(argname="argument doc", value=doc, expected_type=type_hints["doc"])
        return typing.cast(None, jsii.invoke(self, "addToDocument", [doc]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ICommandComponent).__jsii_proxy_class__ = lambda : _ICommandComponentProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IDownloadableContent")
class IDownloadableContent(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="sourceType")
    def source_type(self) -> builtins.str:
        ...

    @jsii.member(jsii_name="formatSourceInfo")
    def format_source_info(self) -> typing.Mapping[builtins.str, typing.Any]:
        ...

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        ...


class _IDownloadableContentProxy:
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IDownloadableContent"

    @builtins.property
    @jsii.member(jsii_name="sourceType")
    def source_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceType"))

    @jsii.member(jsii_name="formatSourceInfo")
    def format_source_info(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatSourceInfo", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDownloadableContent).__jsii_proxy_class__ = lambda : _IDownloadableContentProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IEnvironment")
class IEnvironment(typing_extensions.Protocol):
    '''IEnvironment is an abstraction for EC2 instances.

    The implementations of this interface provides customers with
    alternatives to test their commands rather than a real instance.
    '''

    @jsii.member(jsii_name="run")
    def run(self, command: builtins.str) -> builtins.str:
        '''
        :param command: -
        '''
        ...


class _IEnvironmentProxy:
    '''IEnvironment is an abstraction for EC2 instances.

    The implementations of this interface provides customers with
    alternatives to test their commands rather than a real instance.
    '''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IEnvironment"

    @jsii.member(jsii_name="run")
    def run(self, command: builtins.str) -> builtins.str:
        '''
        :param command: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__569c0d1fde3d02889a626a5a85d192dc7dbe99540d9c3b261f680e8ad0921bc4)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        return typing.cast(builtins.str, jsii.invoke(self, "run", [command]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IEnvironment).__jsii_proxy_class__ = lambda : _IEnvironmentProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IExecuteAutomationHook")
class IExecuteAutomationHook(typing_extensions.Protocol):
    '''Interface for simulating aws:executeAutomation.'''

    @jsii.member(jsii_name="execute")
    def execute(
        self,
        *,
        document_name: builtins.str,
        document_version: typing.Optional[builtins.str] = None,
        max_concurrency: typing.Optional[builtins.str] = None,
        max_errors: typing.Optional[builtins.str] = None,
        runtime_parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        tags: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_locations: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_maps: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_parameter_name: typing.Optional[builtins.str] = None,
        targets: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
    ) -> ExecuteAutomationOutputs:
        '''Simulate the aws:executeAutomation.

        :param document_name: 
        :param document_version: 
        :param max_concurrency: 
        :param max_errors: 
        :param runtime_parameters: 
        :param tags: 
        :param target_locations: 
        :param target_maps: 
        :param target_parameter_name: 
        :param targets: 
        '''
        ...


class _IExecuteAutomationHookProxy:
    '''Interface for simulating aws:executeAutomation.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IExecuteAutomationHook"

    @jsii.member(jsii_name="execute")
    def execute(
        self,
        *,
        document_name: builtins.str,
        document_version: typing.Optional[builtins.str] = None,
        max_concurrency: typing.Optional[builtins.str] = None,
        max_errors: typing.Optional[builtins.str] = None,
        runtime_parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        tags: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_locations: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_maps: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_parameter_name: typing.Optional[builtins.str] = None,
        targets: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
    ) -> ExecuteAutomationOutputs:
        '''Simulate the aws:executeAutomation.

        :param document_name: 
        :param document_version: 
        :param max_concurrency: 
        :param max_errors: 
        :param runtime_parameters: 
        :param tags: 
        :param target_locations: 
        :param target_maps: 
        :param target_parameter_name: 
        :param targets: 
        '''
        props = ExecuteAutomationProps(
            document_name=document_name,
            document_version=document_version,
            max_concurrency=max_concurrency,
            max_errors=max_errors,
            runtime_parameters=runtime_parameters,
            tags=tags,
            target_locations=target_locations,
            target_maps=target_maps,
            target_parameter_name=target_parameter_name,
            targets=targets,
        )

        return typing.cast(ExecuteAutomationOutputs, jsii.invoke(self, "execute", [props]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IExecuteAutomationHook).__jsii_proxy_class__ = lambda : _IExecuteAutomationHookProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IGenericVariable")
class IGenericVariable(typing_extensions.Protocol):
    '''Variables hold references to a value.

    There are two implementations: HardCodedValue and ExportedVariable.
    This interface allows you to reference variable outputs from previous steps via the exported step.variable().
    If you do not have a reference to a variable, you may generate your own variable using the ExportedVariable ctor.
    In the event that a hardcoded value is passed into a step, you can reference the value with a HardCodedValue.
    '''

    @jsii.member(jsii_name="print")
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.

        Example::

            {{ MyVariable }}
        '''
        ...

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        ...

    @jsii.member(jsii_name="resolve")
    def resolve(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        ...

    @jsii.member(jsii_name="toJSON")
    def to_json(self) -> typing.Any:
        '''JSON.stringify(variable) will implicitly invoke this variable.'''
        ...


class _IGenericVariableProxy:
    '''Variables hold references to a value.

    There are two implementations: HardCodedValue and ExportedVariable.
    This interface allows you to reference variable outputs from previous steps via the exported step.variable().
    If you do not have a reference to a variable, you may generate your own variable using the ExportedVariable ctor.
    In the event that a hardcoded value is passed into a step, you can reference the value with a HardCodedValue.
    '''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IGenericVariable"

    @jsii.member(jsii_name="print")
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.

        Example::

            {{ MyVariable }}
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "print", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="resolve")
    def resolve(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__502d23b90ffe32439213bf2b81b8538432717b84c226dfac87f19a8bf2bb1bdd)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", [inputs]))

    @jsii.member(jsii_name="toJSON")
    def to_json(self) -> typing.Any:
        '''JSON.stringify(variable) will implicitly invoke this variable.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJSON", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IGenericVariable).__jsii_proxy_class__ = lambda : _IGenericVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IMapListVariable")
class IMapListVariable(IGenericVariable, typing_extensions.Protocol):
    '''A map list variable.'''

    @jsii.member(jsii_name="resolveToMapList")
    def resolve_to_map_list(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.List[typing.Mapping[builtins.str, typing.Any]]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        ...


class _IMapListVariableProxy(
    jsii.proxy_for(IGenericVariable), # type: ignore[misc]
):
    '''A map list variable.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IMapListVariable"

    @jsii.member(jsii_name="resolveToMapList")
    def resolve_to_map_list(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.List[typing.Mapping[builtins.str, typing.Any]]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c598153ecef28cff6fe6e37cff2560ce0f9239cfc6b774f143c8164e382eabf1)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.List[typing.Mapping[builtins.str, typing.Any]], jsii.invoke(self, "resolveToMapList", [inputs]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IMapListVariable).__jsii_proxy_class__ = lambda : _IMapListVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.INumberVariable")
class INumberVariable(IGenericVariable, typing_extensions.Protocol):
    '''A number variable.'''

    @jsii.member(jsii_name="resolveToNumber")
    def resolve_to_number(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> jsii.Number:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        ...


class _INumberVariableProxy(
    jsii.proxy_for(IGenericVariable), # type: ignore[misc]
):
    '''A number variable.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.INumberVariable"

    @jsii.member(jsii_name="resolveToNumber")
    def resolve_to_number(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> jsii.Number:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb50e757d0f3a58bcf2edfae1fc0a0ab28debf69cba89d40c43d46893409f3a1)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(jsii.Number, jsii.invoke(self, "resolveToNumber", [inputs]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, INumberVariable).__jsii_proxy_class__ = lambda : _INumberVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IObserver")
class IObserver(typing_extensions.Protocol):
    @jsii.member(jsii_name="accept")
    def accept(self, value: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''
        :param value: -
        '''
        ...


class _IObserverProxy:
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IObserver"

    @jsii.member(jsii_name="accept")
    def accept(self, value: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bbf2a51a1f4947d82a1862ff5512ce628b43a025629daa944afa2ebee4800416)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "accept", [value]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IObserver).__jsii_proxy_class__ = lambda : _IObserverProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IParameterResolver")
class IParameterResolver(typing_extensions.Protocol):
    '''Resolver for secure strings in Parameters.'''

    @jsii.member(jsii_name="resolve")
    def resolve(self, input: builtins.str) -> builtins.str:
        '''Resolve the token to its value.

        :param input: -
        '''
        ...


class _IParameterResolverProxy:
    '''Resolver for secure strings in Parameters.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IParameterResolver"

    @jsii.member(jsii_name="resolve")
    def resolve(self, input: builtins.str) -> builtins.str:
        '''Resolve the token to its value.

        :param input: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5256e130b9383e31ac28de02d47fb420d7a3b511e48f9cf8255a7997b4c57ee)
            check_type(argname="argument input", value=input, expected_type=type_hints["input"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolve", [input]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IParameterResolver).__jsii_proxy_class__ = lambda : _IParameterResolverProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IPauseHook")
class IPauseHook(typing_extensions.Protocol):
    '''This can be used to provide a hook for pausing implementation for PauseStep.'''

    @jsii.member(jsii_name="pause")
    def pause(self) -> None:
        ...


class _IPauseHookProxy:
    '''This can be used to provide a hook for pausing implementation for PauseStep.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IPauseHook"

    @jsii.member(jsii_name="pause")
    def pause(self) -> None:
        return typing.cast(None, jsii.invoke(self, "pause", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPauseHook).__jsii_proxy_class__ = lambda : _IPauseHookProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IRunCommandHook")
class IRunCommandHook(typing_extensions.Protocol):
    '''Interface for simulating aws:runCommand.'''

    @jsii.member(jsii_name="execute")
    def execute(
        self,
        *,
        document_name: builtins.str,
        targets: typing.Sequence[builtins.str],
        cloud_watch_output_config: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        comment: typing.Optional[builtins.str] = None,
        document_hash: typing.Optional[builtins.str] = None,
        document_hash_type: typing.Optional[builtins.str] = None,
        max_concurrency: typing.Optional[jsii.Number] = None,
        max_errors: typing.Optional[jsii.Number] = None,
        notification_config: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        output_s3_bucket_name: typing.Optional[builtins.str] = None,
        output_s3_key_prefix: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        service_role_arn: typing.Optional[builtins.str] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> "RunCommandOutputs":
        '''Simulate the aws:runCommand.

        :param document_name: If the Command type document is owned by you or AWS, specify the name of the document. If you're using a document shared with you by a different AWS account, specify the Amazon Resource Name (ARN) of the document.
        :param targets: The instance IDs where you want the command to run. You can specify a maximum of 50 IDs. You can also use the pseudo parameter {{ RESOURCE_ID }} in place of instance IDs to run the command on all instances in the target group. For more information about pseudo parameters, see `About pseudo parameters <https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-register-tasks-parameters.html>`_. Another alternative is to send commands to a fleet of instances by using the Targets parameter. The Targets parameter accepts Amazon Elastic Compute Cloud (Amazon EC2) tags. For more information about how to use the Targets parameter, see `Using targets and rate controls to send commands to a fleet <https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html>`_.
        :param cloud_watch_output_config: (Optional) Configuration options for sending command output to Amazon CloudWatch Logs. For more information about sending command output to CloudWatch Logs, see `Configuring Amazon CloudWatch Logs for Run Command <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-rc-setting-up-cwlogs.html>`_.
        :param comment: (Optional) User-defined information about the command.
        :param document_hash: (Optional) The hash for the document.
        :param document_hash_type: (Optional) The type of the hash.
        :param max_concurrency: (Optional) The maximum concurrency.
        :param max_errors: (Optional) The maximum errors.
        :param notification_config: (Optional) The configurations for sending notifications.
        :param output_s3_bucket_name: (Optional) The name of the S3 bucket for command output responses.
        :param output_s3_key_prefix: (Optional) The prefix.
        :param parameters: (Optional) The required and optional parameters specified in the document.
        :param service_role_arn: (Optional) The ARN of the AWS Identity and Access Management (IAM) role.
        :param timeout_seconds: (Optional) The amount of time in seconds to wait for a command to deliver to the AWS Systems Manager SSM Agent on an instance. If the command isn't received by the SSM Agent on the instance before the value specified is reached, then the status of the command changes to Delivery Timed Out.
        '''
        ...


class _IRunCommandHookProxy:
    '''Interface for simulating aws:runCommand.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IRunCommandHook"

    @jsii.member(jsii_name="execute")
    def execute(
        self,
        *,
        document_name: builtins.str,
        targets: typing.Sequence[builtins.str],
        cloud_watch_output_config: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        comment: typing.Optional[builtins.str] = None,
        document_hash: typing.Optional[builtins.str] = None,
        document_hash_type: typing.Optional[builtins.str] = None,
        max_concurrency: typing.Optional[jsii.Number] = None,
        max_errors: typing.Optional[jsii.Number] = None,
        notification_config: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        output_s3_bucket_name: typing.Optional[builtins.str] = None,
        output_s3_key_prefix: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        service_role_arn: typing.Optional[builtins.str] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> "RunCommandOutputs":
        '''Simulate the aws:runCommand.

        :param document_name: If the Command type document is owned by you or AWS, specify the name of the document. If you're using a document shared with you by a different AWS account, specify the Amazon Resource Name (ARN) of the document.
        :param targets: The instance IDs where you want the command to run. You can specify a maximum of 50 IDs. You can also use the pseudo parameter {{ RESOURCE_ID }} in place of instance IDs to run the command on all instances in the target group. For more information about pseudo parameters, see `About pseudo parameters <https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-register-tasks-parameters.html>`_. Another alternative is to send commands to a fleet of instances by using the Targets parameter. The Targets parameter accepts Amazon Elastic Compute Cloud (Amazon EC2) tags. For more information about how to use the Targets parameter, see `Using targets and rate controls to send commands to a fleet <https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html>`_.
        :param cloud_watch_output_config: (Optional) Configuration options for sending command output to Amazon CloudWatch Logs. For more information about sending command output to CloudWatch Logs, see `Configuring Amazon CloudWatch Logs for Run Command <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-rc-setting-up-cwlogs.html>`_.
        :param comment: (Optional) User-defined information about the command.
        :param document_hash: (Optional) The hash for the document.
        :param document_hash_type: (Optional) The type of the hash.
        :param max_concurrency: (Optional) The maximum concurrency.
        :param max_errors: (Optional) The maximum errors.
        :param notification_config: (Optional) The configurations for sending notifications.
        :param output_s3_bucket_name: (Optional) The name of the S3 bucket for command output responses.
        :param output_s3_key_prefix: (Optional) The prefix.
        :param parameters: (Optional) The required and optional parameters specified in the document.
        :param service_role_arn: (Optional) The ARN of the AWS Identity and Access Management (IAM) role.
        :param timeout_seconds: (Optional) The amount of time in seconds to wait for a command to deliver to the AWS Systems Manager SSM Agent on an instance. If the command isn't received by the SSM Agent on the instance before the value specified is reached, then the status of the command changes to Delivery Timed Out.
        '''
        props = RunCommandProps(
            document_name=document_name,
            targets=targets,
            cloud_watch_output_config=cloud_watch_output_config,
            comment=comment,
            document_hash=document_hash,
            document_hash_type=document_hash_type,
            max_concurrency=max_concurrency,
            max_errors=max_errors,
            notification_config=notification_config,
            output_s3_bucket_name=output_s3_bucket_name,
            output_s3_key_prefix=output_s3_key_prefix,
            parameters=parameters,
            service_role_arn=service_role_arn,
            timeout_seconds=timeout_seconds,
        )

        return typing.cast("RunCommandOutputs", jsii.invoke(self, "execute", [props]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IRunCommandHook).__jsii_proxy_class__ = lambda : _IRunCommandHookProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IRunDocumentLocation")
class IRunDocumentLocation(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="location")
    def location(self) -> "IStringVariable":
        ...

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        ...


class _IRunDocumentLocationProxy:
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IRunDocumentLocation"

    @builtins.property
    @jsii.member(jsii_name="location")
    def location(self) -> "IStringVariable":
        return typing.cast("IStringVariable", jsii.get(self, "location"))

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IRunDocumentLocation).__jsii_proxy_class__ = lambda : _IRunDocumentLocationProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.ISleepHook")
class ISleepHook(typing_extensions.Protocol):
    '''This can be used to provide a hook for sleeping for SleepStep (and other places where sleep is required).'''

    @jsii.member(jsii_name="sleep")
    def sleep(self, time_millis: jsii.Number) -> None:
        '''
        :param time_millis: -
        '''
        ...


class _ISleepHookProxy:
    '''This can be used to provide a hook for sleeping for SleepStep (and other places where sleep is required).'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.ISleepHook"

    @jsii.member(jsii_name="sleep")
    def sleep(self, time_millis: jsii.Number) -> None:
        '''
        :param time_millis: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06e200bfa69c98bcf0d95c73db8d6588cf52de518d22b12d397c5e5ca5fe7353)
            check_type(argname="argument time_millis", value=time_millis, expected_type=type_hints["time_millis"])
        return typing.cast(None, jsii.invoke(self, "sleep", [time_millis]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ISleepHook).__jsii_proxy_class__ = lambda : _ISleepHookProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IStringListVariable")
class IStringListVariable(IGenericVariable, typing_extensions.Protocol):
    '''A string list variable.'''

    @jsii.member(jsii_name="resolveToStringList")
    def resolve_to_string_list(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.List[builtins.str]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        ...


class _IStringListVariableProxy(
    jsii.proxy_for(IGenericVariable), # type: ignore[misc]
):
    '''A string list variable.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IStringListVariable"

    @jsii.member(jsii_name="resolveToStringList")
    def resolve_to_string_list(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.List[builtins.str]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16d874d6c7b678c0dba3b09d0631e662834544a4400319fcfb63574e213ca643)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "resolveToStringList", [inputs]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IStringListVariable).__jsii_proxy_class__ = lambda : _IStringListVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IStringMapVariable")
class IStringMapVariable(IGenericVariable, typing_extensions.Protocol):
    '''A string map variable.'''

    @jsii.member(jsii_name="resolveToStringMap")
    def resolve_to_string_map(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        ...


class _IStringMapVariableProxy(
    jsii.proxy_for(IGenericVariable), # type: ignore[misc]
):
    '''A string map variable.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IStringMapVariable"

    @jsii.member(jsii_name="resolveToStringMap")
    def resolve_to_string_map(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41f53011d7d77f334ed91e209fc77505dee814917963112067ee5786842a7268)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "resolveToStringMap", [inputs]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IStringMapVariable).__jsii_proxy_class__ = lambda : _IStringMapVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IStringVariable")
class IStringVariable(IGenericVariable, typing_extensions.Protocol):
    '''A string variable.'''

    @jsii.member(jsii_name="resolveToString")
    def resolve_to_string(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.str:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        ...


class _IStringVariableProxy(
    jsii.proxy_for(IGenericVariable), # type: ignore[misc]
):
    '''A string variable.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IStringVariable"

    @jsii.member(jsii_name="resolveToString")
    def resolve_to_string(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.str:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e46adf9c9211384b5cea7f6e2bcdb1059bb2ec611c64830eac186ad9e52c8065)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveToString", [inputs]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IStringVariable).__jsii_proxy_class__ = lambda : _IStringVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IWebhook")
class IWebhook(typing_extensions.Protocol):
    '''Hook for simulating aws:invokeWebhook.'''

    @jsii.member(jsii_name="invoke")
    def invoke(
        self,
        *,
        integration_name: builtins.str,
        body: typing.Optional[builtins.str] = None,
    ) -> "InvokeWebhookResult":
        '''Invoke the web hook.

        :param integration_name: The name of the Automation integration. For example, exampleIntegration. The integration you specify must already exist.
        :param body: (Optional) The payload you want to send when your webhook integration is invoked.
        '''
        ...


class _IWebhookProxy:
    '''Hook for simulating aws:invokeWebhook.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IWebhook"

    @jsii.member(jsii_name="invoke")
    def invoke(
        self,
        *,
        integration_name: builtins.str,
        body: typing.Optional[builtins.str] = None,
    ) -> "InvokeWebhookResult":
        '''Invoke the web hook.

        :param integration_name: The name of the Automation integration. For example, exampleIntegration. The integration you specify must already exist.
        :param body: (Optional) The payload you want to send when your webhook integration is invoked.
        '''
        props = InvokeWebhookProps(integration_name=integration_name, body=body)

        return typing.cast("InvokeWebhookResult", jsii.invoke(self, "invoke", [props]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IWebhook).__jsii_proxy_class__ = lambda : _IWebhookProxy


class IncidentResponse(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.IncidentResponse",
):
    '''Provides L2 construct for https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssmincidents-responseplan.html#aws-resource-ssmincidents-responseplan-properties.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        actions: typing.Sequence["IncidentResponseAction"],
        incident_template: "IncidentTemplate",
        chat_channel: typing.Optional[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.ChatChannelProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]] = None,
        display_name: typing.Optional[builtins.str] = None,
        engagements: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param actions: The actions that the response plan starts at the beginning of an incident.
        :param incident_template: Details used to create an incident when using this response plan.
        :param chat_channel: The AWS Chatbot chat channel used for collaboration during an incident.
        :param display_name: The human readable name of the response plan.
        :param engagements: The contacts and escalation plans that the response plan engages during an incident.
        :param tags: An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e747470a0bce92539541fd6bc9d06686f8f11d65c073b6fccc232057db384ffd)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = IncidentResponseProps(
            actions=actions,
            incident_template=incident_template,
            chat_channel=chat_channel,
            display_name=display_name,
            engagements=engagements,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="cfnResponsePlan")
    def cfn_response_plan(self) -> _aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan:
        return typing.cast(_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan, jsii.get(self, "cfnResponsePlan"))


class IncidentResponseAction(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.IncidentResponseAction",
):
    '''The Action property type specifies the configuration to launch.

    :link: : https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssmincidents-responseplan-action.html
    '''

    def __init__(
        self,
        *,
        ssm_automation: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.SsmAutomationProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param ssm_automation: Details about the Systems Manager automation document that will be used as a runbook during an incident.
        '''
        cfn_entry = _aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.ActionProperty(
            ssm_automation=ssm_automation
        )

        jsii.create(self.__class__, self, [cfn_entry])

    @jsii.member(jsii_name="ssmAutomation")
    @builtins.classmethod
    def ssm_automation(
        cls,
        automation_document: "AutomationDocument",
        role: _aws_cdk_aws_iam_ceddda9d.Role,
        *,
        parameters: typing.Mapping[builtins.str, IGenericVariable],
        target_account: typing.Optional[builtins.str] = None,
    ) -> "IncidentResponseAction":
        '''Specify the AutomationDocument to use for the action property.

        :param automation_document: -
        :param role: -
        :param parameters: Specify either StringVariables or HardCodedValues.
        :param target_account: The account that the automation document will be run in. This can be in either the management account or an application account.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4aa62a4b1bd98cbb569d0a44becb5947615958dd6657b9ad7aa04585e1eeabec)
            check_type(argname="argument automation_document", value=automation_document, expected_type=type_hints["automation_document"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
        props = SsmAutomationProps(
            parameters=parameters, target_account=target_account
        )

        return typing.cast("IncidentResponseAction", jsii.sinvoke(cls, "ssmAutomation", [automation_document, role, props]))

    @jsii.member(jsii_name="ssmAutomationEscapeHatch")
    @builtins.classmethod
    def ssm_automation_escape_hatch(
        cls,
        *,
        document_name: builtins.str,
        role_arn: builtins.str,
        document_version: typing.Optional[builtins.str] = None,
        dynamic_parameters: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.DynamicSsmParameterProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        parameters: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.SsmParameterProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        target_account: typing.Optional[builtins.str] = None,
    ) -> "IncidentResponseAction":
        '''
        :param document_name: The automation document's name.
        :param role_arn: The Amazon Resource Name (ARN) of the role that the automation document will assume when running commands.
        :param document_version: The automation document's version to use when running.
        :param dynamic_parameters: The key-value pairs to resolve dynamic parameter values when processing a Systems Manager Automation runbook.
        :param parameters: The key-value pair parameters to use when running the automation document.
        :param target_account: The account that the automation document will be run in. This can be in either the management account or an application account.
        '''
        ssm_automation_property = _aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.SsmAutomationProperty(
            document_name=document_name,
            role_arn=role_arn,
            document_version=document_version,
            dynamic_parameters=dynamic_parameters,
            parameters=parameters,
            target_account=target_account,
        )

        return typing.cast("IncidentResponseAction", jsii.sinvoke(cls, "ssmAutomationEscapeHatch", [ssm_automation_property]))

    @builtins.property
    @jsii.member(jsii_name="cfnEntry")
    def cfn_entry(
        self,
    ) -> _aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.ActionProperty:
        return typing.cast(_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.ActionProperty, jsii.get(self, "cfnEntry"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.IncidentResponseProps",
    jsii_struct_bases=[],
    name_mapping={
        "actions": "actions",
        "incident_template": "incidentTemplate",
        "chat_channel": "chatChannel",
        "display_name": "displayName",
        "engagements": "engagements",
        "tags": "tags",
    },
)
class IncidentResponseProps:
    def __init__(
        self,
        *,
        actions: typing.Sequence[IncidentResponseAction],
        incident_template: "IncidentTemplate",
        chat_channel: typing.Optional[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.ChatChannelProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]] = None,
        display_name: typing.Optional[builtins.str] = None,
        engagements: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Provides props IncidentResponse.

        :param actions: The actions that the response plan starts at the beginning of an incident.
        :param incident_template: Details used to create an incident when using this response plan.
        :param chat_channel: The AWS Chatbot chat channel used for collaboration during an incident.
        :param display_name: The human readable name of the response plan.
        :param engagements: The contacts and escalation plans that the response plan engages during an incident.
        :param tags: An array of key-value pairs to apply to this resource. For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__baee91db5cf4ab65f4fbbc7685f1773d08e5290025e9536e877134c13ff42281)
            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
            check_type(argname="argument incident_template", value=incident_template, expected_type=type_hints["incident_template"])
            check_type(argname="argument chat_channel", value=chat_channel, expected_type=type_hints["chat_channel"])
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
            check_type(argname="argument engagements", value=engagements, expected_type=type_hints["engagements"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "actions": actions,
            "incident_template": incident_template,
        }
        if chat_channel is not None:
            self._values["chat_channel"] = chat_channel
        if display_name is not None:
            self._values["display_name"] = display_name
        if engagements is not None:
            self._values["engagements"] = engagements
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def actions(self) -> typing.List[IncidentResponseAction]:
        '''The actions that the response plan starts at the beginning of an incident.'''
        result = self._values.get("actions")
        assert result is not None, "Required property 'actions' is missing"
        return typing.cast(typing.List[IncidentResponseAction], result)

    @builtins.property
    def incident_template(self) -> "IncidentTemplate":
        '''Details used to create an incident when using this response plan.'''
        result = self._values.get("incident_template")
        assert result is not None, "Required property 'incident_template' is missing"
        return typing.cast("IncidentTemplate", result)

    @builtins.property
    def chat_channel(
        self,
    ) -> typing.Optional[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.ChatChannelProperty, _aws_cdk_ceddda9d.IResolvable]]:
        '''The AWS Chatbot chat channel used for collaboration during an incident.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssmincidents-responseplan.html#cfn-ssmincidents-responseplan-chatchannel
        '''
        result = self._values.get("chat_channel")
        return typing.cast(typing.Optional[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.ChatChannelProperty, _aws_cdk_ceddda9d.IResolvable]], result)

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        '''The human readable name of the response plan.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssmincidents-responseplan.html#cfn-ssmincidents-responseplan-displayname
        '''
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def engagements(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The contacts and escalation plans that the response plan engages during an incident.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssmincidents-responseplan.html#cfn-ssmincidents-responseplan-engagements
        '''
        result = self._values.get("engagements")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_aws_cdk_ceddda9d.CfnTag]]:
        '''An array of key-value pairs to apply to this resource.

        For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssmincidents-responseplan.html#cfn-ssmincidents-responseplan-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_ceddda9d.CfnTag]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IncidentResponseProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IncidentTemplate(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.IncidentTemplate",
):
    '''Provides L2 construct for https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssmincidents-responseplan-incidenttemplate.html.'''

    def __init__(
        self,
        impact: jsii.Number,
        title: builtins.str,
        *,
        dedupe_string: typing.Optional[builtins.str] = None,
        incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        summary: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param impact: -
        :param title: -
        :param dedupe_string: Used to create only one incident record for an incident.
        :param incident_tags: ``CfnResponsePlan.IncidentTemplateProperty.IncidentTags``.
        :param notification_targets: The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel using the SNS topics.
        :param summary: The summary describes what has happened during the incident.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d79beb8dc8bc6f8a13b2ac57bef84a3109b4c9d634b6ba3215b2a606a151583c)
            check_type(argname="argument impact", value=impact, expected_type=type_hints["impact"])
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        props = IncidentTemplateProps(
            dedupe_string=dedupe_string,
            incident_tags=incident_tags,
            notification_targets=notification_targets,
            summary=summary,
        )

        jsii.create(self.__class__, self, [impact, title, props])

    @jsii.member(jsii_name="critical")
    @builtins.classmethod
    def critical(
        cls,
        title: builtins.str,
        *,
        dedupe_string: typing.Optional[builtins.str] = None,
        incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        summary: typing.Optional[builtins.str] = None,
    ) -> "IncidentTemplate":
        '''Critical impact typically relates to full application failure that impacts many to all customers.

        :param title: -
        :param dedupe_string: Used to create only one incident record for an incident.
        :param incident_tags: ``CfnResponsePlan.IncidentTemplateProperty.IncidentTags``.
        :param notification_targets: The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel using the SNS topics.
        :param summary: The summary describes what has happened during the incident.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e47ccdc85a92d15b5171f648a62ae61977bb37d5df1554301971e99bb5d287de)
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        props = IncidentTemplateProps(
            dedupe_string=dedupe_string,
            incident_tags=incident_tags,
            notification_targets=notification_targets,
            summary=summary,
        )

        return typing.cast("IncidentTemplate", jsii.sinvoke(cls, "critical", [title, props]))

    @jsii.member(jsii_name="high")
    @builtins.classmethod
    def high(
        cls,
        title: builtins.str,
        *,
        dedupe_string: typing.Optional[builtins.str] = None,
        incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        summary: typing.Optional[builtins.str] = None,
    ) -> "IncidentTemplate":
        '''High impact denotes partial application failure with impact to many customers.

        :param title: -
        :param dedupe_string: Used to create only one incident record for an incident.
        :param incident_tags: ``CfnResponsePlan.IncidentTemplateProperty.IncidentTags``.
        :param notification_targets: The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel using the SNS topics.
        :param summary: The summary describes what has happened during the incident.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8c8c849638f074ffb0d95efb38906510d466348224adc77f369170190f7baa9)
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        props = IncidentTemplateProps(
            dedupe_string=dedupe_string,
            incident_tags=incident_tags,
            notification_targets=notification_targets,
            summary=summary,
        )

        return typing.cast("IncidentTemplate", jsii.sinvoke(cls, "high", [title, props]))

    @jsii.member(jsii_name="low")
    @builtins.classmethod
    def low(
        cls,
        title: builtins.str,
        *,
        dedupe_string: typing.Optional[builtins.str] = None,
        incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        summary: typing.Optional[builtins.str] = None,
    ) -> "IncidentTemplate":
        '''Low impact denotes that customers may not be impacted by the problem yet.

        :param title: -
        :param dedupe_string: Used to create only one incident record for an incident.
        :param incident_tags: ``CfnResponsePlan.IncidentTemplateProperty.IncidentTags``.
        :param notification_targets: The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel using the SNS topics.
        :param summary: The summary describes what has happened during the incident.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d65db946f4bf0f8e2a0b7bee2213fe34b98b90fb2beffdb5d719dd7cd607d631)
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        props = IncidentTemplateProps(
            dedupe_string=dedupe_string,
            incident_tags=incident_tags,
            notification_targets=notification_targets,
            summary=summary,
        )

        return typing.cast("IncidentTemplate", jsii.sinvoke(cls, "low", [title, props]))

    @jsii.member(jsii_name="medium")
    @builtins.classmethod
    def medium(
        cls,
        title: builtins.str,
        *,
        dedupe_string: typing.Optional[builtins.str] = None,
        incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        summary: typing.Optional[builtins.str] = None,
    ) -> "IncidentTemplate":
        '''Medium impact denotes that the application is providing reduced service to customers.

        :param title: -
        :param dedupe_string: Used to create only one incident record for an incident.
        :param incident_tags: ``CfnResponsePlan.IncidentTemplateProperty.IncidentTags``.
        :param notification_targets: The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel using the SNS topics.
        :param summary: The summary describes what has happened during the incident.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7750b29da7ed91eb5a1e7084b2c300dd368ee22c7d3881e16c12d4840148af5e)
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        props = IncidentTemplateProps(
            dedupe_string=dedupe_string,
            incident_tags=incident_tags,
            notification_targets=notification_targets,
            summary=summary,
        )

        return typing.cast("IncidentTemplate", jsii.sinvoke(cls, "medium", [title, props]))

    @jsii.member(jsii_name="noImpact")
    @builtins.classmethod
    def no_impact(
        cls,
        title: builtins.str,
        *,
        dedupe_string: typing.Optional[builtins.str] = None,
        incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        summary: typing.Optional[builtins.str] = None,
    ) -> "IncidentTemplate":
        '''No impact denotes that customers aren't currently impacted but urgent action is needed to avoid impact.

        :param title: -
        :param dedupe_string: Used to create only one incident record for an incident.
        :param incident_tags: ``CfnResponsePlan.IncidentTemplateProperty.IncidentTags``.
        :param notification_targets: The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel using the SNS topics.
        :param summary: The summary describes what has happened during the incident.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42ab88b04e48077799b9d6274881508e602db3e013865072fc22f2674708e4e6)
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        props = IncidentTemplateProps(
            dedupe_string=dedupe_string,
            incident_tags=incident_tags,
            notification_targets=notification_targets,
            summary=summary,
        )

        return typing.cast("IncidentTemplate", jsii.sinvoke(cls, "noImpact", [title, props]))

    @builtins.property
    @jsii.member(jsii_name="cfnEntry")
    def cfn_entry(
        self,
    ) -> _aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.IncidentTemplateProperty:
        return typing.cast(_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.IncidentTemplateProperty, jsii.get(self, "cfnEntry"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.IncidentTemplateProps",
    jsii_struct_bases=[],
    name_mapping={
        "dedupe_string": "dedupeString",
        "incident_tags": "incidentTags",
        "notification_targets": "notificationTargets",
        "summary": "summary",
    },
)
class IncidentTemplateProps:
    def __init__(
        self,
        *,
        dedupe_string: typing.Optional[builtins.str] = None,
        incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        summary: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Provides L2 construct for https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssmincidents-responseplan-incidenttemplate.html.

        :param dedupe_string: Used to create only one incident record for an incident.
        :param incident_tags: ``CfnResponsePlan.IncidentTemplateProperty.IncidentTags``.
        :param notification_targets: The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel using the SNS topics.
        :param summary: The summary describes what has happened during the incident.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c28b58d3612fdf482d94facd455de3bdcecda36ca7ca8492311d910ad527ebe)
            check_type(argname="argument dedupe_string", value=dedupe_string, expected_type=type_hints["dedupe_string"])
            check_type(argname="argument incident_tags", value=incident_tags, expected_type=type_hints["incident_tags"])
            check_type(argname="argument notification_targets", value=notification_targets, expected_type=type_hints["notification_targets"])
            check_type(argname="argument summary", value=summary, expected_type=type_hints["summary"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dedupe_string is not None:
            self._values["dedupe_string"] = dedupe_string
        if incident_tags is not None:
            self._values["incident_tags"] = incident_tags
        if notification_targets is not None:
            self._values["notification_targets"] = notification_targets
        if summary is not None:
            self._values["summary"] = summary

    @builtins.property
    def dedupe_string(self) -> typing.Optional[builtins.str]:
        '''Used to create only one incident record for an incident.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssmincidents-responseplan-incidenttemplate.html#cfn-ssmincidents-responseplan-incidenttemplate-dedupestring
        '''
        result = self._values.get("dedupe_string")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def incident_tags(
        self,
    ) -> typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.List[typing.Union[_aws_cdk_ceddda9d.IResolvable, _aws_cdk_ceddda9d.CfnTag]]]]:
        '''``CfnResponsePlan.IncidentTemplateProperty.IncidentTags``.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssmincidents-responseplan-incidenttemplate.html#cfn-ssmincidents-responseplan-incidenttemplate-incidenttags
        '''
        result = self._values.get("incident_tags")
        return typing.cast(typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.List[typing.Union[_aws_cdk_ceddda9d.IResolvable, _aws_cdk_ceddda9d.CfnTag]]]], result)

    @builtins.property
    def notification_targets(
        self,
    ) -> typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.List[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, _aws_cdk_ceddda9d.IResolvable]]]]:
        '''The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident.

        You can also make updates to the incident through the chat channel using the SNS topics.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssmincidents-responseplan-incidenttemplate.html#cfn-ssmincidents-responseplan-incidenttemplate-notificationtargets
        '''
        result = self._values.get("notification_targets")
        return typing.cast(typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.List[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, _aws_cdk_ceddda9d.IResolvable]]]], result)

    @builtins.property
    def summary(self) -> typing.Optional[builtins.str]:
        '''The summary describes what has happened during the incident.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssmincidents-responseplan-incidenttemplate.html#cfn-ssmincidents-responseplan-incidenttemplate-summary
        '''
        result = self._values.get("summary")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IncidentTemplateProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Input(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.Input",
):
    def __init__(
        self,
        *,
        input_type: DataTypeEnum,
        name: builtins.str,
        allowed_pattern: typing.Optional[builtins.str] = None,
        allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
        default_value: typing.Any = None,
        description: typing.Optional[builtins.str] = None,
        max_chars: typing.Optional[jsii.Number] = None,
        max_items: typing.Optional[jsii.Number] = None,
        min_chars: typing.Optional[jsii.Number] = None,
        min_items: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param input_type: (Required) The DataTypeEnum of the input.
        :param name: (Required) The name of the input by which to be referenced by steps in the document.
        :param allowed_pattern: (Optional) Pattern that this input value must match. Default: undefined
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_chars: (Optional) Maximum number of chars that this input value (string) must contain. Default: undefined
        :param max_items: (Optional) Maximum number of items that this input value (list) must contain. Default: undefined
        :param min_chars: (Optional) Minimum number of chars that this input value (string) must contain. Default: undefined
        :param min_items: (Optional) Minimum number of items that this input value (list) must contain. Default: undefined
        '''
        props = InputProps(
            input_type=input_type,
            name=name,
            allowed_pattern=allowed_pattern,
            allowed_values=allowed_values,
            default_value=default_value,
            description=description,
            max_chars=max_chars,
            max_items=max_items,
            min_chars=min_chars,
            min_items=min_items,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="ofSpecifiedType")
    @builtins.classmethod
    def of_specified_type(
        cls,
        type: DataTypeEnum,
        input_name: builtins.str,
        *,
        input_type: DataTypeEnum,
        name: builtins.str,
        allowed_pattern: typing.Optional[builtins.str] = None,
        allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
        default_value: typing.Any = None,
        description: typing.Optional[builtins.str] = None,
        max_chars: typing.Optional[jsii.Number] = None,
        max_items: typing.Optional[jsii.Number] = None,
        min_chars: typing.Optional[jsii.Number] = None,
        min_items: typing.Optional[jsii.Number] = None,
    ) -> "Input":
        '''
        :param type: -
        :param input_name: -
        :param input_type: (Required) The DataTypeEnum of the input.
        :param name: (Required) The name of the input by which to be referenced by steps in the document.
        :param allowed_pattern: (Optional) Pattern that this input value must match. Default: undefined
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_chars: (Optional) Maximum number of chars that this input value (string) must contain. Default: undefined
        :param max_items: (Optional) Maximum number of items that this input value (list) must contain. Default: undefined
        :param min_chars: (Optional) Minimum number of chars that this input value (string) must contain. Default: undefined
        :param min_items: (Optional) Minimum number of items that this input value (list) must contain. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04325df0f35fef47db79f35bedfa94f9863cf2eb2f4774af6aae7aece6b624e4)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument input_name", value=input_name, expected_type=type_hints["input_name"])
        props = InputProps(
            input_type=input_type,
            name=name,
            allowed_pattern=allowed_pattern,
            allowed_values=allowed_values,
            default_value=default_value,
            description=description,
            max_chars=max_chars,
            max_items=max_items,
            min_chars=min_chars,
            min_items=min_items,
        )

        return typing.cast("Input", jsii.sinvoke(cls, "ofSpecifiedType", [type, input_name, props]))

    @jsii.member(jsii_name="ofTypeBoolean")
    @builtins.classmethod
    def of_type_boolean(
        cls,
        name: builtins.str,
        *,
        default_value: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
    ) -> "Input":
        '''
        :param name: -
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17c27dda7d76dcd4f9cfaa70cd6c25b5edd4aec5147d98f6de40a587eaed62ee)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = BooleanInputProps(default_value=default_value, description=description)

        return typing.cast("Input", jsii.sinvoke(cls, "ofTypeBoolean", [name, props]))

    @jsii.member(jsii_name="ofTypeInteger")
    @builtins.classmethod
    def of_type_integer(
        cls,
        name: builtins.str,
        *,
        allowed_values: typing.Optional[typing.Sequence[jsii.Number]] = None,
        default_value: typing.Optional[jsii.Number] = None,
        description: typing.Optional[builtins.str] = None,
    ) -> "Input":
        '''
        :param name: -
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a67c9197cfa89f20936e6b180fa01d1701cebb4b7ce4e967ce362c8a0d21b7a1)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = IntegerInputProps(
            allowed_values=allowed_values,
            default_value=default_value,
            description=description,
        )

        return typing.cast("Input", jsii.sinvoke(cls, "ofTypeInteger", [name, props]))

    @jsii.member(jsii_name="ofTypeMapList")
    @builtins.classmethod
    def of_type_map_list(
        cls,
        name: builtins.str,
        *,
        allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
        default_value: typing.Any = None,
        description: typing.Optional[builtins.str] = None,
        max_items: typing.Optional[jsii.Number] = None,
        min_items: typing.Optional[jsii.Number] = None,
    ) -> "Input":
        '''
        :param name: -
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_items: (Optional) Maximum number of items that this input value (list) must contain. Default: undefined
        :param min_items: (Optional) Minimum number of items that this input value (list) must contain. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__172d5f9613e1469a91e47b3012d25b1b0dcacb55a5ebae58424093faca00ffb4)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = MapListInputProps(
            allowed_values=allowed_values,
            default_value=default_value,
            description=description,
            max_items=max_items,
            min_items=min_items,
        )

        return typing.cast("Input", jsii.sinvoke(cls, "ofTypeMapList", [name, props]))

    @jsii.member(jsii_name="ofTypeString")
    @builtins.classmethod
    def of_type_string(
        cls,
        name: builtins.str,
        *,
        allowed_pattern: typing.Optional[builtins.str] = None,
        allowed_values: typing.Optional[typing.Sequence[builtins.str]] = None,
        default_value: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        max_chars: typing.Optional[jsii.Number] = None,
        min_chars: typing.Optional[jsii.Number] = None,
    ) -> "Input":
        '''
        :param name: -
        :param allowed_pattern: (Optional) Pattern that this input value must match. Default: undefined
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_chars: (Optional) Maximum number of chars that this input value (string) must contain. Default: undefined
        :param min_chars: (Optional) Minimum number of chars that this input value (string) must contain. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3755c356b2124d7e9e9e51fff2220ef1c97e56d25d735d6b29b47feb9e0d491)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = StringInputProps(
            allowed_pattern=allowed_pattern,
            allowed_values=allowed_values,
            default_value=default_value,
            description=description,
            max_chars=max_chars,
            min_chars=min_chars,
        )

        return typing.cast("Input", jsii.sinvoke(cls, "ofTypeString", [name, props]))

    @jsii.member(jsii_name="ofTypeStringList")
    @builtins.classmethod
    def of_type_string_list(
        cls,
        name: builtins.str,
        *,
        allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
        default_value: typing.Any = None,
        description: typing.Optional[builtins.str] = None,
        max_items: typing.Optional[jsii.Number] = None,
        min_items: typing.Optional[jsii.Number] = None,
    ) -> "Input":
        '''
        :param name: -
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_items: (Optional) Maximum number of items that this input value (list) must contain. Default: undefined
        :param min_items: (Optional) Minimum number of items that this input value (list) must contain. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea22d2f4a329ed2941830e3cfc049e7b527140293138a3445132139e865bded5)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = StringListInputProps(
            allowed_values=allowed_values,
            default_value=default_value,
            description=description,
            max_items=max_items,
            min_items=min_items,
        )

        return typing.cast("Input", jsii.sinvoke(cls, "ofTypeStringList", [name, props]))

    @jsii.member(jsii_name="ofTypeStringMap")
    @builtins.classmethod
    def of_type_string_map(
        cls,
        name: builtins.str,
        *,
        allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
        default_value: typing.Any = None,
        description: typing.Optional[builtins.str] = None,
        max_items: typing.Optional[jsii.Number] = None,
        min_items: typing.Optional[jsii.Number] = None,
    ) -> "Input":
        '''
        :param name: -
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_items: (Optional) Maximum number of items that this input value (list) must contain. Default: undefined
        :param min_items: (Optional) Minimum number of items that this input value (list) must contain. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f915e2d7e966614be50119b8179e6f7617e32f8c7d56ac7384cd8b760b0ae6e5)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        props = StringMapInputProps(
            allowed_values=allowed_values,
            default_value=default_value,
            description=description,
            max_items=max_items,
            min_items=min_items,
        )

        return typing.cast("Input", jsii.sinvoke(cls, "ofTypeStringMap", [name, props]))

    @jsii.member(jsii_name="toSsm")
    def to_ssm(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsm", []))

    @jsii.member(jsii_name="validate")
    def validate(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__911ea151a3bb7c8e028d0f41e95ca50233b7900e54cd6eff05526cb1659b95a3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "validate", [value]))

    @builtins.property
    @jsii.member(jsii_name="inputType")
    def input_type(self) -> DataTypeEnum:
        return typing.cast(DataTypeEnum, jsii.get(self, "inputType"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="allowedPattern")
    def allowed_pattern(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "allowedPattern"))

    @builtins.property
    @jsii.member(jsii_name="allowedValues")
    def allowed_values(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowedValues"))

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @builtins.property
    @jsii.member(jsii_name="maxChars")
    def max_chars(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxChars"))

    @builtins.property
    @jsii.member(jsii_name="maxItems")
    def max_items(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxItems"))

    @builtins.property
    @jsii.member(jsii_name="minChars")
    def min_chars(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "minChars"))

    @builtins.property
    @jsii.member(jsii_name="minItems")
    def min_items(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "minItems"))

    @builtins.property
    @jsii.member(jsii_name="defaultValue")
    def default_value(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultValue"))

    @default_value.setter
    def default_value(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81e41b2bbab1149af36184269f147b903293ad635e3d9852d4cb21db0973985e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "defaultValue", value) # pyright: ignore[reportArgumentType]


class _InputProxy(Input):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Input).__jsii_proxy_class__ = lambda : _InputProxy


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.InputProps",
    jsii_struct_bases=[],
    name_mapping={
        "input_type": "inputType",
        "name": "name",
        "allowed_pattern": "allowedPattern",
        "allowed_values": "allowedValues",
        "default_value": "defaultValue",
        "description": "description",
        "max_chars": "maxChars",
        "max_items": "maxItems",
        "min_chars": "minChars",
        "min_items": "minItems",
    },
)
class InputProps:
    def __init__(
        self,
        *,
        input_type: DataTypeEnum,
        name: builtins.str,
        allowed_pattern: typing.Optional[builtins.str] = None,
        allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
        default_value: typing.Any = None,
        description: typing.Optional[builtins.str] = None,
        max_chars: typing.Optional[jsii.Number] = None,
        max_items: typing.Optional[jsii.Number] = None,
        min_chars: typing.Optional[jsii.Number] = None,
        min_items: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties of inputs supported by SSM documents.

        These are NOT used for declaring step inputs, rather only for document inputs.
        See https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-doc-syntax.html

        :param input_type: (Required) The DataTypeEnum of the input.
        :param name: (Required) The name of the input by which to be referenced by steps in the document.
        :param allowed_pattern: (Optional) Pattern that this input value must match. Default: undefined
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_chars: (Optional) Maximum number of chars that this input value (string) must contain. Default: undefined
        :param max_items: (Optional) Maximum number of items that this input value (list) must contain. Default: undefined
        :param min_chars: (Optional) Minimum number of chars that this input value (string) must contain. Default: undefined
        :param min_items: (Optional) Minimum number of items that this input value (list) must contain. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecb5fb45f58c66d3f03dff609275e48dd400888b48fde1eaab230307ea7ef85c)
            check_type(argname="argument input_type", value=input_type, expected_type=type_hints["input_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument allowed_pattern", value=allowed_pattern, expected_type=type_hints["allowed_pattern"])
            check_type(argname="argument allowed_values", value=allowed_values, expected_type=type_hints["allowed_values"])
            check_type(argname="argument default_value", value=default_value, expected_type=type_hints["default_value"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument max_chars", value=max_chars, expected_type=type_hints["max_chars"])
            check_type(argname="argument max_items", value=max_items, expected_type=type_hints["max_items"])
            check_type(argname="argument min_chars", value=min_chars, expected_type=type_hints["min_chars"])
            check_type(argname="argument min_items", value=min_items, expected_type=type_hints["min_items"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "input_type": input_type,
            "name": name,
        }
        if allowed_pattern is not None:
            self._values["allowed_pattern"] = allowed_pattern
        if allowed_values is not None:
            self._values["allowed_values"] = allowed_values
        if default_value is not None:
            self._values["default_value"] = default_value
        if description is not None:
            self._values["description"] = description
        if max_chars is not None:
            self._values["max_chars"] = max_chars
        if max_items is not None:
            self._values["max_items"] = max_items
        if min_chars is not None:
            self._values["min_chars"] = min_chars
        if min_items is not None:
            self._values["min_items"] = min_items

    @builtins.property
    def input_type(self) -> DataTypeEnum:
        '''(Required) The DataTypeEnum of the input.'''
        result = self._values.get("input_type")
        assert result is not None, "Required property 'input_type' is missing"
        return typing.cast(DataTypeEnum, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''(Required) The name of the input by which to be referenced by steps in the document.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def allowed_pattern(self) -> typing.Optional[builtins.str]:
        '''(Optional) Pattern that this input value must match.

        :default: undefined
        '''
        result = self._values.get("allowed_pattern")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def allowed_values(self) -> typing.Optional[typing.List[typing.Any]]:
        '''(Optional) List of allowed values that this input may be.

        :default: undefined
        '''
        result = self._values.get("allowed_values")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    @builtins.property
    def default_value(self) -> typing.Any:
        '''(Optional) Default value to use for this input if not specified when invoking the document.

        :default: undefined
        '''
        result = self._values.get("default_value")
        return typing.cast(typing.Any, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) The description of the input.

        :default: name
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_chars(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Maximum number of chars that this input value (string) must contain.

        :default: undefined
        '''
        result = self._values.get("max_chars")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_items(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Maximum number of items that this input value (list) must contain.

        :default: undefined
        '''
        result = self._values.get("max_items")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_chars(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Minimum number of chars that this input value (string) must contain.

        :default: undefined
        '''
        result = self._values.get("min_chars")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_items(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Minimum number of items that this input value (list) must contain.

        :default: undefined
        '''
        result = self._values.get("min_items")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InputProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.IntegerInputProps",
    jsii_struct_bases=[],
    name_mapping={
        "allowed_values": "allowedValues",
        "default_value": "defaultValue",
        "description": "description",
    },
)
class IntegerInputProps:
    def __init__(
        self,
        *,
        allowed_values: typing.Optional[typing.Sequence[jsii.Number]] = None,
        default_value: typing.Optional[jsii.Number] = None,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__973ed220eab16c66c7dad97ae328bf10d2183329d36210742ed24d969bf02bb4)
            check_type(argname="argument allowed_values", value=allowed_values, expected_type=type_hints["allowed_values"])
            check_type(argname="argument default_value", value=default_value, expected_type=type_hints["default_value"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allowed_values is not None:
            self._values["allowed_values"] = allowed_values
        if default_value is not None:
            self._values["default_value"] = default_value
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def allowed_values(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''(Optional) List of allowed values that this input may be.

        :default: undefined
        '''
        result = self._values.get("allowed_values")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def default_value(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Default value to use for this input if not specified when invoking the document.

        :default: undefined
        '''
        result = self._values.get("default_value")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) The description of the input.

        :default: name
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IntegerInputProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.Invocation",
    jsii_struct_bases=[],
    name_mapping={
        "aws_api": "awsApi",
        "aws_params": "awsParams",
        "service": "service",
    },
)
class Invocation:
    def __init__(
        self,
        *,
        aws_api: builtins.str,
        aws_params: typing.Mapping[builtins.str, typing.Any],
        service: AwsService,
    ) -> None:
        '''
        :param aws_api: (Required) AWS api to invoke; should be referenced using lowerCamelCase.
        :param aws_params: (Required )AWS params.
        :param service: (Required) AWS service to invoke.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__323390a01c89753024c2222fa8f2091572bcdbab8fbfd24e6eaa0ef37c93f532)
            check_type(argname="argument aws_api", value=aws_api, expected_type=type_hints["aws_api"])
            check_type(argname="argument aws_params", value=aws_params, expected_type=type_hints["aws_params"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "aws_api": aws_api,
            "aws_params": aws_params,
            "service": service,
        }

    @builtins.property
    def aws_api(self) -> builtins.str:
        '''(Required) AWS api to invoke;

        should be referenced using lowerCamelCase.

        Example::

            describeInstance
        '''
        result = self._values.get("aws_api")
        assert result is not None, "Required property 'aws_api' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aws_params(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''(Required )AWS params.

        Example::

            { 'Filters': [{'Name': 'instance-id', 'Values': ['{{ InstanceId }}'] }] }
        '''
        result = self._values.get("aws_params")
        assert result is not None, "Required property 'aws_params' is missing"
        return typing.cast(typing.Mapping[builtins.str, typing.Any], result)

    @builtins.property
    def service(self) -> AwsService:
        '''(Required) AWS service to invoke.

        Example::

            AwsService.EC2
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(AwsService, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Invocation(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class InvokeLambdaFunctionSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.InvokeLambdaFunctionSimulation",
):
    '''AutomationStep implemenation for aws:invokeLambdaFunction https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-lamb.html.'''

    def __init__(
        self,
        step: "InvokeLambdaFunctionStep",
        *,
        aws_invoker: IAwsInvoker,
    ) -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f47481d308f1a3b89f87fc0c406ba82f8cfb8cb6e22d75c24f6dc941487e8131)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = AwsInvocationSimulationProps(aws_invoker=aws_invoker)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73d6a7ced114ae69d19b3bdb05db9c65c7aeeaac29c30a07f7f5619d6de8a441)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.InvokeWebhookProps",
    jsii_struct_bases=[],
    name_mapping={"integration_name": "integrationName", "body": "body"},
)
class InvokeWebhookProps:
    def __init__(
        self,
        *,
        integration_name: builtins.str,
        body: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The properties for IWebhook.Invoke.

        :param integration_name: The name of the Automation integration. For example, exampleIntegration. The integration you specify must already exist.
        :param body: (Optional) The payload you want to send when your webhook integration is invoked.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e53067ee3c89c67282684267722155b543072ce0afeae1e6c17640c5b0e5cfca)
            check_type(argname="argument integration_name", value=integration_name, expected_type=type_hints["integration_name"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "integration_name": integration_name,
        }
        if body is not None:
            self._values["body"] = body

    @builtins.property
    def integration_name(self) -> builtins.str:
        '''The name of the Automation integration.

        For example, exampleIntegration. The integration you specify must already exist.
        '''
        result = self._values.get("integration_name")
        assert result is not None, "Required property 'integration_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''(Optional) The payload you want to send when your webhook integration is invoked.'''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InvokeWebhookProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.InvokeWebhookResult",
    jsii_struct_bases=[],
    name_mapping={"response": "response", "response_code": "responseCode"},
)
class InvokeWebhookResult:
    def __init__(self, *, response: builtins.str, response_code: jsii.Number) -> None:
        '''Response from IWebhook.Invoke.

        :param response: The text received from the webhook provider response.
        :param response_code: The HTTP status code received from the webhook provider response.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63e06ea67a57734415507fbd1dac7b43d5a71ae3356fc3a8e0d25ebca6d8e059)
            check_type(argname="argument response", value=response, expected_type=type_hints["response"])
            check_type(argname="argument response_code", value=response_code, expected_type=type_hints["response_code"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "response": response,
            "response_code": response_code,
        }

    @builtins.property
    def response(self) -> builtins.str:
        '''The text received from the webhook provider response.'''
        result = self._values.get("response")
        assert result is not None, "Required property 'response' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def response_code(self) -> jsii.Number:
        '''The HTTP status code received from the webhook provider response.'''
        result = self._values.get("response_code")
        assert result is not None, "Required property 'response_code' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InvokeWebhookResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class InvokeWebhookSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.InvokeWebhookSimulation",
):
    '''AutomationStep implementation for `aws:invokeWebhook <https://docs.aws.amazon.com/systems-manager/latest/userguide/invoke-webhook.html>`_.'''

    def __init__(self, step: "InvokeWebhookStep", *, webhook: IWebhook) -> None:
        '''
        :param step: -
        :param webhook: (Optional) Hook for simulating aws:invokeWebhook. Default: - Returns 204 with an empty response
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41807eb55ad8f1320d3657c53e327850403a376d21061ba592bf0ec074a450d0)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = InvokeWebhookSimulationProps(webhook=webhook)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d212a8d5c4e5315fa55a603db0ff35265941ca2c50b4a836d5d67dbb8bfdf359)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.InvokeWebhookSimulationProps",
    jsii_struct_bases=[],
    name_mapping={"webhook": "webhook"},
)
class InvokeWebhookSimulationProps:
    def __init__(self, *, webhook: IWebhook) -> None:
        '''Properties for InvokeWebhookStep.

        :param webhook: (Optional) Hook for simulating aws:invokeWebhook. Default: - Returns 204 with an empty response
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b5c75e10d138930b6c92371ee29cf6cee6302cf86c5f68c8f21e3d7a77259e8)
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "webhook": webhook,
        }

    @builtins.property
    def webhook(self) -> IWebhook:
        '''(Optional) Hook for simulating aws:invokeWebhook.

        :default: - Returns 204 with an empty response
        '''
        result = self._values.get("webhook")
        assert result is not None, "Required property 'webhook' is missing"
        return typing.cast(IWebhook, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InvokeWebhookSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IRunDocumentLocation)
class LocalRunDocument(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.LocalRunDocument",
):
    def __init__(self, document_path: IStringVariable) -> None:
        '''Specify the path to the document on the local share.

        :param document_path: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6fa55f292dcf4f64c87ab654380d7999be9e03571d07233251900f085e2fd8d)
            check_type(argname="argument document_path", value=document_path, expected_type=type_hints["document_path"])
        jsii.create(self.__class__, self, [document_path])

    @builtins.property
    @jsii.member(jsii_name="location")
    def location(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "location"))

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))


@jsii.implements(IEnvironment)
class LoggingEnvironment(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.LoggingEnvironment",
):
    '''Environment that simply logs the commands that it receives and displays them on the console.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="run")
    def run(self, command: builtins.str) -> builtins.str:
        '''
        :param command: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7f6a61531372bf0b927fd89d64e5a8fa69aaf44094ebbac52ed8b585fef2a57)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        return typing.cast(builtins.str, jsii.invoke(self, "run", [command]))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.MapListInputProps",
    jsii_struct_bases=[],
    name_mapping={
        "allowed_values": "allowedValues",
        "default_value": "defaultValue",
        "description": "description",
        "max_items": "maxItems",
        "min_items": "minItems",
    },
)
class MapListInputProps:
    def __init__(
        self,
        *,
        allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
        default_value: typing.Any = None,
        description: typing.Optional[builtins.str] = None,
        max_items: typing.Optional[jsii.Number] = None,
        min_items: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_items: (Optional) Maximum number of items that this input value (list) must contain. Default: undefined
        :param min_items: (Optional) Minimum number of items that this input value (list) must contain. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e66f60bab2520aba781d566e21e313c945431c98c8f8ba4060cb4e87eb3dcf5e)
            check_type(argname="argument allowed_values", value=allowed_values, expected_type=type_hints["allowed_values"])
            check_type(argname="argument default_value", value=default_value, expected_type=type_hints["default_value"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument max_items", value=max_items, expected_type=type_hints["max_items"])
            check_type(argname="argument min_items", value=min_items, expected_type=type_hints["min_items"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allowed_values is not None:
            self._values["allowed_values"] = allowed_values
        if default_value is not None:
            self._values["default_value"] = default_value
        if description is not None:
            self._values["description"] = description
        if max_items is not None:
            self._values["max_items"] = max_items
        if min_items is not None:
            self._values["min_items"] = min_items

    @builtins.property
    def allowed_values(self) -> typing.Optional[typing.List[typing.Any]]:
        '''(Optional) List of allowed values that this input may be.

        :default: undefined
        '''
        result = self._values.get("allowed_values")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    @builtins.property
    def default_value(self) -> typing.Any:
        '''(Optional) Default value to use for this input if not specified when invoking the document.

        :default: undefined
        '''
        result = self._values.get("default_value")
        return typing.cast(typing.Any, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) The description of the input.

        :default: name
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_items(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Maximum number of items that this input value (list) must contain.

        :default: undefined
        '''
        result = self._values.get("max_items")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_items(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Minimum number of items that this input value (list) must contain.

        :default: undefined
        '''
        result = self._values.get("min_items")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MapListInputProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IApproveHook)
class MockApprove(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.MockApprove",
):
    '''Mock implementation of IApproveHook.

    Does not simulate an approval request.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="ask")
    def ask(self, _approver: builtins.str) -> builtins.bool:
        '''Ask for approval.

        :param _approver: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce5360dd2758a5905993c34c76ab2707a6f6d8f539c153093a0c746e8d659ceb)
            check_type(argname="argument _approver", value=_approver, expected_type=type_hints["_approver"])
        return typing.cast(builtins.bool, jsii.invoke(self, "ask", [_approver]))

    @builtins.property
    @jsii.member(jsii_name="timesInvoked")
    def times_invoked(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timesInvoked"))

    @times_invoked.setter
    def times_invoked(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a42044c4a013cf1701c1d7b9a429dc75c74f020bd9906a861523654ddaf889c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "timesInvoked", value) # pyright: ignore[reportArgumentType]


@jsii.implements(IAwsInvoker)
class MockAwsInvoker(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.MockAwsInvoker",
):
    '''Mock implementation of IAwsInvoker.

    This class can be reused for testing in exported JSII languages.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="invoke")
    def invoke(
        self,
        *,
        aws_api: builtins.str,
        aws_params: typing.Mapping[builtins.str, typing.Any],
        service: AwsService,
    ) -> typing.Any:
        '''Saves the invocation to be retrieved using getInvocations().

        :param aws_api: (Required) AWS api to invoke; should be referenced using lowerCamelCase.
        :param aws_params: (Required )AWS params.
        :param service: (Required) AWS service to invoke.

        :return: the next result as set by the setReturn function
        '''
        invocation = Invocation(
            aws_api=aws_api, aws_params=aws_params, service=service
        )

        return typing.cast(typing.Any, jsii.invoke(self, "invoke", [invocation]))

    @jsii.member(jsii_name="nextReturn")
    def next_return(self, aws_result: typing.Any) -> "MockAwsInvoker":
        '''Set the next return value.

        This function can be chained to return subsequent return values.
        Values are read in order they were inserted.
        The last value is used as a default if there are no other values retrieved.
        In that way this function behaves the same way as Mockito .thenReturn(val).

        :param aws_result: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7dcaeab296c9424f796f7a2e7776544cab4f40f5a851648fc820a13023ec15d)
            check_type(argname="argument aws_result", value=aws_result, expected_type=type_hints["aws_result"])
        return typing.cast("MockAwsInvoker", jsii.invoke(self, "nextReturn", [aws_result]))

    @jsii.member(jsii_name="whenThen")
    def when_then(
        self,
        when: typing.Union[Invocation, typing.Dict[builtins.str, typing.Any]],
        then: typing.Mapping[builtins.str, typing.Any],
    ) -> None:
        '''Allows developers to mock out responses from the AwsInvoker depending on the input that it receives.

        :param when: defines the invocation to match and return the then.
        :param then: is the value that should be returned if the above when Invocation is matched.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c3e71203c242da00f0341d5abf4351a7ae698a204b0db101a531c28c7ff2f3c)
            check_type(argname="argument when", value=when, expected_type=type_hints["when"])
            check_type(argname="argument then", value=then, expected_type=type_hints["then"])
        return typing.cast(None, jsii.invoke(self, "whenThen", [when, then]))

    @builtins.property
    @jsii.member(jsii_name="previousInvocations")
    def previous_invocations(self) -> typing.List[Invocation]:
        '''All of the invocations that have been submitted to this invoker until present.'''
        return typing.cast(typing.List[Invocation], jsii.get(self, "previousInvocations"))


@jsii.implements(IEnvironment)
class MockEnvironment(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.MockEnvironment",
):
    '''Environment that simply saves commands into a previousCommands variable.

    This is useful if you want to unit test the commands that would be sent to a real environment.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="run")
    def run(self, command: builtins.str) -> builtins.str:
        '''
        :param command: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__838b47553c5d81f6ed97a4d0ed8889b1e7ad07ec2175e232340fd80d3df80453)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        return typing.cast(builtins.str, jsii.invoke(self, "run", [command]))

    @builtins.property
    @jsii.member(jsii_name="previousCommands")
    def previous_commands(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "previousCommands"))

    @previous_commands.setter
    def previous_commands(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09e0bc2e6fc9e746f7c6fe93f39190f29bb9ef596391316c23f139f2716c268b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "previousCommands", value) # pyright: ignore[reportArgumentType]


@jsii.implements(IPauseHook)
class MockPause(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.MockPause",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="pause")
    def pause(self) -> None:
        return typing.cast(None, jsii.invoke(self, "pause", []))

    @builtins.property
    @jsii.member(jsii_name="timesInvoked")
    def times_invoked(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timesInvoked"))

    @times_invoked.setter
    def times_invoked(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5780f8e67c755fc9a8f89b34e2cfd59a1473b628a787fcbaf28c5cacdaa4cd0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "timesInvoked", value) # pyright: ignore[reportArgumentType]


@jsii.implements(ISleepHook)
class MockSleep(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.MockSleep",
):
    '''Mock ISleeper implementation.

    Simply logs that it is sleeping and returns immediately.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="sleep")
    def sleep(self, time_millis: jsii.Number) -> None:
        '''
        :param time_millis: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29411d88654475bebe297204a72ca37710ea099926e29d4945ceaa0eef4d44ff)
            check_type(argname="argument time_millis", value=time_millis, expected_type=type_hints["time_millis"])
        return typing.cast(None, jsii.invoke(self, "sleep", [time_millis]))

    @builtins.property
    @jsii.member(jsii_name="sleepMilliInvocations")
    def sleep_milli_invocations(self) -> typing.List[jsii.Number]:
        return typing.cast(typing.List[jsii.Number], jsii.get(self, "sleepMilliInvocations"))


class NameDoc(
    DocumentSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.NameDoc",
):
    def __init__(
        self,
        name: IStringVariable,
        version: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''
        :param name: -
        :param version: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac38c36e15680199e6a15bd77b38f36ab40a876e7009684428a09263089721ae)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        jsii.create(self.__class__, self, [name, version])

    @jsii.member(jsii_name="formatRequest")
    def format_request(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatRequest", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="version")
    def version(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "version"))


class NoAuthMethod(
    AuthMethod,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.NoAuthMethod",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="toEntry")
    def to_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toEntry", []))


@jsii.implements(IObserver)
class NoopObserver(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.NoopObserver",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="accept")
    def accept(self, _value: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''
        :param _value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c5a7bc1b0376c7cfbadbd38e86c0549cfba1a73513f9337ce5292286e8de6ee)
            check_type(argname="argument _value", value=_value, expected_type=type_hints["_value"])
        return typing.cast(None, jsii.invoke(self, "accept", [_value]))


class OnFailure(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.OnFailure",
):
    '''Steps can specify an action to take onFailure.

    See docs here: https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#failProp
    The supported actions are abort (default), continue, or invoking a specific step.
    This behavior can be adopted by using the static methods available on OnFailure.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="abort")
    @builtins.classmethod
    def abort(cls) -> "OnCancel":
        '''To abort execution if a failure occurs during execution of the current step.

        (This is the default behavior.)
        '''
        return typing.cast("OnCancel", jsii.sinvoke(cls, "abort", []))

    @jsii.member(jsii_name="continue")
    @builtins.classmethod
    def continue_(cls) -> "OnFailure":
        '''To continue execution of the subsequent step if a failure occurs during execution of the current step.'''
        return typing.cast("OnFailure", jsii.sinvoke(cls, "continue", []))

    @jsii.member(jsii_name="invokeStep")
    @builtins.classmethod
    def invoke_step(cls, step: "AutomationStep") -> "OnCancel":
        '''Invoke a specific step.

        Provide the step object to execute for the onFailure action.
        If you don't have a handle to the step object, use the invokeStepByName function.

        :param step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f90348fe2876e5d329743a22aae7d729e736f5af082caa443097228eefee21cb)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        return typing.cast("OnCancel", jsii.sinvoke(cls, "invokeStep", [step]))

    @jsii.member(jsii_name="invokeStepByName")
    @builtins.classmethod
    def invoke_step_by_name(cls, step_name: builtins.str) -> "OnCancel":
        '''Invoke a specific step by the step name for the OnFailure action.

        :param step_name: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2b9ca4472331c9497f119c79d5e6d6e8029ac63afe349f1c9f3235d88e7ea43)
            check_type(argname="argument step_name", value=step_name, expected_type=type_hints["step_name"])
        return typing.cast("OnCancel", jsii.sinvoke(cls, "invokeStepByName", [step_name]))

    @jsii.member(jsii_name="stepToInvoke")
    @abc.abstractmethod
    def step_to_invoke(self, current_step: "AutomationStep") -> builtins.str:
        '''
        :param current_step: -
        '''
        ...

    @jsii.member(jsii_name="toSsmValue")
    @abc.abstractmethod
    def to_ssm_value(self) -> builtins.str:
        ...


class _OnFailureProxy(OnFailure):
    @jsii.member(jsii_name="stepToInvoke")
    def step_to_invoke(self, current_step: "AutomationStep") -> builtins.str:
        '''
        :param current_step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3498939b57e11b8d7024f63b453c77628f03cdab60c7bd7bf7317335e266040a)
            check_type(argname="argument current_step", value=current_step, expected_type=type_hints["current_step"])
        return typing.cast(builtins.str, jsii.invoke(self, "stepToInvoke", [current_step]))

    @jsii.member(jsii_name="toSsmValue")
    def to_ssm_value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "toSsmValue", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, OnFailure).__jsii_proxy_class__ = lambda : _OnFailureProxy


@jsii.enum(jsii_type="@cdklabs/cdk-ssm-documents.Operation")
class Operation(enum.Enum):
    '''Operation to use for comparing a Choice's or Preconditions with provided value.

    See https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-branch.html
    or https://docs.aws.amazon.com/systems-manager/latest/userguide/document-schemas-features.html
    '''

    BOOLEAN_EQUALS = "BOOLEAN_EQUALS"
    CONTAINS = "CONTAINS"
    ENDS_WITH = "ENDS_WITH"
    STARTS_WITH = "STARTS_WITH"
    STRING_EQUALS = "STRING_EQUALS"
    EQUALS_IGNORE_CASE = "EQUALS_IGNORE_CASE"
    NUMERIC_EQUALS = "NUMERIC_EQUALS"
    NUMERIC_GREATER = "NUMERIC_GREATER"
    NUMERIC_GREATER_OR_EQUALS = "NUMERIC_GREATER_OR_EQUALS"
    NUMERIC_LESSER = "NUMERIC_LESSER"
    NUMERIC_LESSER_OR_EQUALS = "NUMERIC_LESSER_OR_EQUALS"


class OperationEvaluator(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.OperationEvaluator",
):
    def __init__(self, operation: Operation) -> None:
        '''
        :param operation: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__90c36bf174dcf5dd70f82c702e08abc3147ef00e9e8c48252a965dbcf2566f82)
            check_type(argname="argument operation", value=operation, expected_type=type_hints["operation"])
        jsii.create(self.__class__, self, [operation])

    @jsii.member(jsii_name="fromOperationName")
    @builtins.classmethod
    def from_operation_name(cls, operation_name: builtins.str) -> Operation:
        '''Converts a string to OperationType.

        :param operation_name: an operation name to return its OperationType.

        :return: an OperationType

        :throws: if operationName is not supported
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a46688287e75e31dc952f4a33bdcf4e7bd4ed0768baa86a10933e2ae968d14f)
            check_type(argname="argument operation_name", value=operation_name, expected_type=type_hints["operation_name"])
        return typing.cast(Operation, jsii.sinvoke(cls, "fromOperationName", [operation_name]))

    @jsii.member(jsii_name="evaluate")
    def evaluate(self, value1: typing.Any, value2: typing.Any) -> builtins.bool:
        '''Evaluates this operation against the provided inputs.

        :param value1: -
        :param value2: -

        :return: true if the evaluation is true. False otherwise.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a37777b237e631f29895c72fd547601179c2db530e6ded7c11ed39474706f09a)
            check_type(argname="argument value1", value=value1, expected_type=type_hints["value1"])
            check_type(argname="argument value2", value=value2, expected_type=type_hints["value2"])
        return typing.cast(builtins.bool, jsii.invoke(self, "evaluate", [value1, value2]))

    @jsii.member(jsii_name="toOperationName")
    def to_operation_name(self) -> builtins.str:
        '''
        :return: the string representation used by SSM for the operation.
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "toOperationName", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="STRING_TO_OPERATION")
    def STRING_TO_OPERATION(cls) -> typing.Mapping[builtins.str, Operation]:
        return typing.cast(typing.Mapping[builtins.str, Operation], jsii.sget(cls, "STRING_TO_OPERATION"))

    @builtins.property
    @jsii.member(jsii_name="operation")
    def operation(self) -> Operation:
        return typing.cast(Operation, jsii.get(self, "operation"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.Output",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "output_type": "outputType", "selector": "selector"},
)
class Output:
    def __init__(
        self,
        *,
        name: builtins.str,
        output_type: DataTypeEnum,
        selector: builtins.str,
    ) -> None:
        '''Object used to specify step output.

        :param name: The name that can be used by subsequent steps to refernce the stored value. Note that Outputs will be PREPENDED with the step name.
        :param output_type: The DataType expected by this output. This will be validated in simulation mode and will also be used when printing to yaml/json.
        :param selector: Json selector for locating the value in the json step response.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0773784203075686ec2f2dd2513160c2d1f0bf6a149de0216f5f50e5ca1354f6)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_type", value=output_type, expected_type=type_hints["output_type"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "output_type": output_type,
            "selector": selector,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The name that can be used by subsequent steps to refernce the stored value.

        Note that Outputs will be PREPENDED with the step name.
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def output_type(self) -> DataTypeEnum:
        '''The DataType expected by this output.

        This will be validated in simulation mode and will also be used when printing to yaml/json.
        '''
        result = self._values.get("output_type")
        assert result is not None, "Required property 'output_type' is missing"
        return typing.cast(DataTypeEnum, result)

    @builtins.property
    def selector(self) -> builtins.str:
        '''Json selector for locating the value in the json step response.'''
        result = self._values.get("selector")
        assert result is not None, "Required property 'selector' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Output(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IPauseHook)
class PauseImpl(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.PauseImpl",
):
    '''This IPauseHook implementation provides a real pause and wait for user input of Enter.

    This implementation does not work well on all exported JSII languages.
    Users can provide their own impl using the IPauseHook interface.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="pause")
    def pause(self) -> None:
        return typing.cast(None, jsii.invoke(self, "pause", []))


class PauseSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.PauseSimulation",
):
    '''AutomationStep implementation for aws:pause https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-pause.html.'''

    def __init__(self, step: "PauseStep", *, pause_hook: IPauseHook) -> None:
        '''
        :param step: -
        :param pause_hook: (Optional) Pause hook to be called to pause the execution. To mock this implementation either inject an instance of IPauseHook or use the provided MockPause class. Default: PauseHook instance. PauseHook may not work in exported JSII languages. Override interface as needed.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfa24003a0a7634765a53d3de1809b9cc8fb3fbd069a951d63d214376974222b)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = PauseSimulationProps(pause_hook=pause_hook)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        _inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''May perform a real pause based on the params used during instance creation.

        :param _inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e63778de98c1074ad0817ce000bd3d4f31ad4aaced1ba30c1115a92d92fd7701)
            check_type(argname="argument _inputs", value=_inputs, expected_type=type_hints["_inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [_inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.PauseSimulationProps",
    jsii_struct_bases=[],
    name_mapping={"pause_hook": "pauseHook"},
)
class PauseSimulationProps:
    def __init__(self, *, pause_hook: IPauseHook) -> None:
        '''Properties for PauseStep.

        :param pause_hook: (Optional) Pause hook to be called to pause the execution. To mock this implementation either inject an instance of IPauseHook or use the provided MockPause class. Default: PauseHook instance. PauseHook may not work in exported JSII languages. Override interface as needed.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4c847737937c4231e03a271d3187bafa175952bd5d08cf0b2654812e38e2426)
            check_type(argname="argument pause_hook", value=pause_hook, expected_type=type_hints["pause_hook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "pause_hook": pause_hook,
        }

    @builtins.property
    def pause_hook(self) -> IPauseHook:
        '''(Optional) Pause hook to be called to pause the execution.

        To mock this implementation either inject an instance of IPauseHook or use the provided MockPause class.

        :default: PauseHook instance. PauseHook may not work in exported JSII languages. Override interface as needed.
        '''
        result = self._values.get("pause_hook")
        assert result is not None, "Required property 'pause_hook' is missing"
        return typing.cast(IPauseHook, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PauseSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="@cdklabs/cdk-ssm-documents.Platform")
class Platform(enum.Enum):
    '''Command steps are not all applicable to all platforms.

    Each command step declares which Platforms it supports.
    That allows customers to validate their CommandDocument against a given platform prior to execution.
    '''

    LINUX = "LINUX"
    WINDOWS = "WINDOWS"
    MAC_OS = "MAC_OS"


class Platforms(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.Platforms",
):
    @jsii.member(jsii_name="toPlatform")
    @builtins.classmethod
    def to_platform(cls, platform_string: builtins.str) -> Platform:
        '''Converts a string to Platform.

        :param platform_string: a platform name to return its Platform type.

        :return: a Platform

        :throws: if platofrmString is not supported
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93983b5cc3e83f684b195199bb7bb8fcbf98017894e10f55098379035c7d36e0)
            check_type(argname="argument platform_string", value=platform_string, expected_type=type_hints["platform_string"])
        return typing.cast(Platform, jsii.sinvoke(cls, "toPlatform", [platform_string]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="STRING_TO_PLATFORM")
    def STRING_TO_PLATFORM(cls) -> typing.Mapping[builtins.str, Platform]:
        return typing.cast(typing.Mapping[builtins.str, Platform], jsii.sget(cls, "STRING_TO_PLATFORM"))


class Precondition(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.Precondition",
):
    @jsii.member(jsii_name="newPlatformPrecondition")
    @builtins.classmethod
    def new_platform_precondition(cls, platform: Platform) -> "Precondition":
        '''Returns a new Precondition.

        :param platform: The platform the preconditions tests against.

        :return: new Precondition with platformType EnvironmentVariable, operation and a constant
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd89b6563970985c80a59125df55bd77fdc1e4c83cefe5635d9400a952d903d4)
            check_type(argname="argument platform", value=platform, expected_type=type_hints["platform"])
        return typing.cast("Precondition", jsii.sinvoke(cls, "newPlatformPrecondition", [platform]))

    @jsii.member(jsii_name="asSsmEntry")
    def as_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :return: an object that can be used to print this choice into yaml/json format.
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "asSsmEntry", []))

    @jsii.member(jsii_name="evaluate")
    def evaluate(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.bool:
        '''Evaluates if the precondition is met, by comparing the variable with the constant using the operator.

        :param inputs: -

        :return: true if the evaluation is true. False otherwise.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02e0e37063e7fb3bd8e5969ebe20519909807d03a59c6b014cc7c37b47edd509)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(builtins.bool, jsii.invoke(self, "evaluate", [inputs]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="INJECTED_PLAYFORM_TYPE_KEY")
    def INJECTED_PLAYFORM_TYPE_KEY(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "INJECTED_PLAYFORM_TYPE_KEY"))

    @builtins.property
    @jsii.member(jsii_name="operationType")
    def operation_type(self) -> Operation:
        return typing.cast(Operation, jsii.get(self, "operationType"))

    @builtins.property
    @jsii.member(jsii_name="variable1")
    def variable1(self) -> IGenericVariable:
        return typing.cast(IGenericVariable, jsii.get(self, "variable1"))

    @builtins.property
    @jsii.member(jsii_name="variable2")
    def variable2(self) -> IGenericVariable:
        return typing.cast(IGenericVariable, jsii.get(self, "variable2"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.PreconditionProps",
    jsii_struct_bases=[],
    name_mapping={
        "operation_type": "operationType",
        "variable1": "variable1",
        "variable2": "variable2",
    },
)
class PreconditionProps:
    def __init__(
        self,
        *,
        operation_type: Operation,
        variable1: IGenericVariable,
        variable2: IGenericVariable,
    ) -> None:
        '''The precondition parameter is used as a comparator of SSM documents inputs to determine whether a command step would be executed or not.

        See https://docs.aws.amazon.com/systems-manager/latest/userguide/document-schemas-features.html

        :param operation_type: (Required) the operation used to compare the parameter with the variable.
        :param variable1: (Required) the variable to compare against the constant.
        :param variable2: (Required) the being compared against the variable.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36b78155d9c9d6c672dea571628ffc66a8d564ef6554decf0e89ed7554f13859)
            check_type(argname="argument operation_type", value=operation_type, expected_type=type_hints["operation_type"])
            check_type(argname="argument variable1", value=variable1, expected_type=type_hints["variable1"])
            check_type(argname="argument variable2", value=variable2, expected_type=type_hints["variable2"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "operation_type": operation_type,
            "variable1": variable1,
            "variable2": variable2,
        }

    @builtins.property
    def operation_type(self) -> Operation:
        '''(Required) the operation used to compare the parameter with the variable.'''
        result = self._values.get("operation_type")
        assert result is not None, "Required property 'operation_type' is missing"
        return typing.cast(Operation, result)

    @builtins.property
    def variable1(self) -> IGenericVariable:
        '''(Required) the variable to compare against the constant.'''
        result = self._values.get("variable1")
        assert result is not None, "Required property 'variable1' is missing"
        return typing.cast(IGenericVariable, result)

    @builtins.property
    def variable2(self) -> IGenericVariable:
        '''(Required) the being compared against the variable.'''
        result = self._values.get("variable2")
        assert result is not None, "Required property 'variable2' is missing"
        return typing.cast(IGenericVariable, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PreconditionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PsModuleSimulation(
    CommandSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.PsModuleSimulation",
):
    def __init__(self, step: "PsModuleStep", *, environment: IEnvironment) -> None:
        '''
        :param step: -
        :param environment: (Optional) Specify here the environment in which to execute the scripts. Use the DockerEnvironment to execute the commands inside the docker. You can alternatively use the LoggingEnvironment which simply logs the commands or MockEnvironment which saves them for validation. Default: LoggingEnvironment
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34626c8f6bf90067210f71042273b75ff6cee6c5b3efc114e8c7a3383c00188a)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = EnvironmentProps(environment=environment)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''Installs the module specified by source then runs the specified commands.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3be0ee23c34e1614d63c3e8157920a814a819d54492f6c9237183b26f18640e)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(None, jsii.invoke(self, "executeStep", [inputs]))


@jsii.enum(jsii_type="@cdklabs/cdk-ssm-documents.PythonVersion")
class PythonVersion(enum.Enum):
    '''Python runtime to use when writing SSM Document.

    Simulation will use local python version.
    '''

    VERSION_3_7 = "VERSION_3_7"
    VERSION_3_8 = "VERSION_3_8"
    VERSION_3_9 = "VERSION_3_9"
    VERSION_3_10 = "VERSION_3_10"
    VERSION_3_11 = "VERSION_3_11"


@jsii.implements(IAwsInvoker)
class ReflectiveAwsInvoker(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ReflectiveAwsInvoker",
):
    '''Implementation of IAwsInvoker that executes the AWS api for real.

    If using this implementation, be sure that AWS credentials are available to the execution.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="invoke")
    def invoke(
        self,
        *,
        aws_api: builtins.str,
        aws_params: typing.Mapping[builtins.str, typing.Any],
        service: AwsService,
    ) -> typing.Any:
        '''Invoke AWS with the provided invocation request.

        :param aws_api: (Required) AWS api to invoke; should be referenced using lowerCamelCase.
        :param aws_params: (Required )AWS params.
        :param service: (Required) AWS service to invoke.
        '''
        invocation = Invocation(
            aws_api=aws_api, aws_params=aws_params, service=service
        )

        return typing.cast(typing.Any, jsii.invoke(self, "invoke", [invocation]))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RequiredAutomationSimulationProps",
    jsii_struct_bases=[],
    name_mapping={
        "approve_hook": "approveHook",
        "aws_invoker": "awsInvoker",
        "execute_automation_hook": "executeAutomationHook",
        "input_observer": "inputObserver",
        "output_observer": "outputObserver",
        "parameter_resolver": "parameterResolver",
        "pause_hook": "pauseHook",
        "run_command_hook": "runCommandHook",
        "sleep_hook": "sleepHook",
        "webhook": "webhook",
    },
)
class RequiredAutomationSimulationProps:
    def __init__(
        self,
        *,
        approve_hook: IApproveHook,
        aws_invoker: IAwsInvoker,
        execute_automation_hook: IExecuteAutomationHook,
        input_observer: IObserver,
        output_observer: IObserver,
        parameter_resolver: IParameterResolver,
        pause_hook: IPauseHook,
        run_command_hook: IRunCommandHook,
        sleep_hook: ISleepHook,
        webhook: IWebhook,
    ) -> None:
        '''The same interface as AutomationSimulationProps but all fields are required.

        :param approve_hook: 
        :param aws_invoker: 
        :param execute_automation_hook: 
        :param input_observer: 
        :param output_observer: 
        :param parameter_resolver: 
        :param pause_hook: 
        :param run_command_hook: 
        :param sleep_hook: 
        :param webhook: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a8640978189931df91b471ab404af74be2984d2596168e8df6a8ace6d22a7c4)
            check_type(argname="argument approve_hook", value=approve_hook, expected_type=type_hints["approve_hook"])
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument execute_automation_hook", value=execute_automation_hook, expected_type=type_hints["execute_automation_hook"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument parameter_resolver", value=parameter_resolver, expected_type=type_hints["parameter_resolver"])
            check_type(argname="argument pause_hook", value=pause_hook, expected_type=type_hints["pause_hook"])
            check_type(argname="argument run_command_hook", value=run_command_hook, expected_type=type_hints["run_command_hook"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "approve_hook": approve_hook,
            "aws_invoker": aws_invoker,
            "execute_automation_hook": execute_automation_hook,
            "input_observer": input_observer,
            "output_observer": output_observer,
            "parameter_resolver": parameter_resolver,
            "pause_hook": pause_hook,
            "run_command_hook": run_command_hook,
            "sleep_hook": sleep_hook,
            "webhook": webhook,
        }

    @builtins.property
    def approve_hook(self) -> IApproveHook:
        result = self._values.get("approve_hook")
        assert result is not None, "Required property 'approve_hook' is missing"
        return typing.cast(IApproveHook, result)

    @builtins.property
    def aws_invoker(self) -> IAwsInvoker:
        result = self._values.get("aws_invoker")
        assert result is not None, "Required property 'aws_invoker' is missing"
        return typing.cast(IAwsInvoker, result)

    @builtins.property
    def execute_automation_hook(self) -> IExecuteAutomationHook:
        result = self._values.get("execute_automation_hook")
        assert result is not None, "Required property 'execute_automation_hook' is missing"
        return typing.cast(IExecuteAutomationHook, result)

    @builtins.property
    def input_observer(self) -> IObserver:
        result = self._values.get("input_observer")
        assert result is not None, "Required property 'input_observer' is missing"
        return typing.cast(IObserver, result)

    @builtins.property
    def output_observer(self) -> IObserver:
        result = self._values.get("output_observer")
        assert result is not None, "Required property 'output_observer' is missing"
        return typing.cast(IObserver, result)

    @builtins.property
    def parameter_resolver(self) -> IParameterResolver:
        result = self._values.get("parameter_resolver")
        assert result is not None, "Required property 'parameter_resolver' is missing"
        return typing.cast(IParameterResolver, result)

    @builtins.property
    def pause_hook(self) -> IPauseHook:
        result = self._values.get("pause_hook")
        assert result is not None, "Required property 'pause_hook' is missing"
        return typing.cast(IPauseHook, result)

    @builtins.property
    def run_command_hook(self) -> IRunCommandHook:
        result = self._values.get("run_command_hook")
        assert result is not None, "Required property 'run_command_hook' is missing"
        return typing.cast(IRunCommandHook, result)

    @builtins.property
    def sleep_hook(self) -> ISleepHook:
        result = self._values.get("sleep_hook")
        assert result is not None, "Required property 'sleep_hook' is missing"
        return typing.cast(ISleepHook, result)

    @builtins.property
    def webhook(self) -> IWebhook:
        result = self._values.get("webhook")
        assert result is not None, "Required property 'webhook' is missing"
        return typing.cast(IWebhook, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RequiredAutomationSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RequiredCommandSimulationProps",
    jsii_struct_bases=[],
    name_mapping={
        "environment": "environment",
        "simulation_platform": "simulationPlatform",
    },
)
class RequiredCommandSimulationProps:
    def __init__(
        self,
        *,
        environment: IEnvironment,
        simulation_platform: Platform,
    ) -> None:
        '''The same interface as CommandSimulationProps but all fields are required.

        :param environment: 
        :param simulation_platform: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e09146e44b313a7de2f23fc73663117dead5177b084ad4b9b017ed14960e61b)
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument simulation_platform", value=simulation_platform, expected_type=type_hints["simulation_platform"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "environment": environment,
            "simulation_platform": simulation_platform,
        }

    @builtins.property
    def environment(self) -> IEnvironment:
        result = self._values.get("environment")
        assert result is not None, "Required property 'environment' is missing"
        return typing.cast(IEnvironment, result)

    @builtins.property
    def simulation_platform(self) -> Platform:
        result = self._values.get("simulation_platform")
        assert result is not None, "Required property 'simulation_platform' is missing"
        return typing.cast(Platform, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RequiredCommandSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="@cdklabs/cdk-ssm-documents.ResponseCode")
class ResponseCode(enum.Enum):
    '''Steps report their ResponseCode using this enum.

    A successful response will contain the outputs expected.
    A failed/canceled response will contain the stackTrace.
    '''

    SUCCESS = "SUCCESS"
    CANCELED = "CANCELED"
    FAILED = "FAILED"


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RunCommandOutputs",
    jsii_struct_bases=[],
    name_mapping={
        "command_id": "commandId",
        "status": "status",
        "output": "output",
        "response_code": "responseCode",
    },
)
class RunCommandOutputs:
    def __init__(
        self,
        *,
        command_id: builtins.str,
        status: builtins.str,
        output: typing.Optional[builtins.str] = None,
        response_code: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Outputs for aws:runCommand.

        :param command_id: The ID of the command.
        :param status: The status of the command.
        :param output: The output of the command.
        :param response_code: The response code of the command.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c6c598e8b8217cb314bfa396a8b231a832b30afbbac935879ef8b94a2d6fc50)
            check_type(argname="argument command_id", value=command_id, expected_type=type_hints["command_id"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument output", value=output, expected_type=type_hints["output"])
            check_type(argname="argument response_code", value=response_code, expected_type=type_hints["response_code"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "command_id": command_id,
            "status": status,
        }
        if output is not None:
            self._values["output"] = output
        if response_code is not None:
            self._values["response_code"] = response_code

    @builtins.property
    def command_id(self) -> builtins.str:
        '''The ID of the command.'''
        result = self._values.get("command_id")
        assert result is not None, "Required property 'command_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def status(self) -> builtins.str:
        '''The status of the command.'''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def output(self) -> typing.Optional[builtins.str]:
        '''The output of the command.'''
        result = self._values.get("output")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def response_code(self) -> typing.Optional[jsii.Number]:
        '''The response code of the command.'''
        result = self._values.get("response_code")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunCommandOutputs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RunCommandProps",
    jsii_struct_bases=[],
    name_mapping={
        "document_name": "documentName",
        "targets": "targets",
        "cloud_watch_output_config": "cloudWatchOutputConfig",
        "comment": "comment",
        "document_hash": "documentHash",
        "document_hash_type": "documentHashType",
        "max_concurrency": "maxConcurrency",
        "max_errors": "maxErrors",
        "notification_config": "notificationConfig",
        "output_s3_bucket_name": "outputS3BucketName",
        "output_s3_key_prefix": "outputS3KeyPrefix",
        "parameters": "parameters",
        "service_role_arn": "serviceRoleArn",
        "timeout_seconds": "timeoutSeconds",
    },
)
class RunCommandProps:
    def __init__(
        self,
        *,
        document_name: builtins.str,
        targets: typing.Sequence[builtins.str],
        cloud_watch_output_config: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        comment: typing.Optional[builtins.str] = None,
        document_hash: typing.Optional[builtins.str] = None,
        document_hash_type: typing.Optional[builtins.str] = None,
        max_concurrency: typing.Optional[jsii.Number] = None,
        max_errors: typing.Optional[jsii.Number] = None,
        notification_config: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        output_s3_bucket_name: typing.Optional[builtins.str] = None,
        output_s3_key_prefix: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        service_role_arn: typing.Optional[builtins.str] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Inputs for aws:runCommand.

        :param document_name: If the Command type document is owned by you or AWS, specify the name of the document. If you're using a document shared with you by a different AWS account, specify the Amazon Resource Name (ARN) of the document.
        :param targets: The instance IDs where you want the command to run. You can specify a maximum of 50 IDs. You can also use the pseudo parameter {{ RESOURCE_ID }} in place of instance IDs to run the command on all instances in the target group. For more information about pseudo parameters, see `About pseudo parameters <https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-register-tasks-parameters.html>`_. Another alternative is to send commands to a fleet of instances by using the Targets parameter. The Targets parameter accepts Amazon Elastic Compute Cloud (Amazon EC2) tags. For more information about how to use the Targets parameter, see `Using targets and rate controls to send commands to a fleet <https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html>`_.
        :param cloud_watch_output_config: (Optional) Configuration options for sending command output to Amazon CloudWatch Logs. For more information about sending command output to CloudWatch Logs, see `Configuring Amazon CloudWatch Logs for Run Command <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-rc-setting-up-cwlogs.html>`_.
        :param comment: (Optional) User-defined information about the command.
        :param document_hash: (Optional) The hash for the document.
        :param document_hash_type: (Optional) The type of the hash.
        :param max_concurrency: (Optional) The maximum concurrency.
        :param max_errors: (Optional) The maximum errors.
        :param notification_config: (Optional) The configurations for sending notifications.
        :param output_s3_bucket_name: (Optional) The name of the S3 bucket for command output responses.
        :param output_s3_key_prefix: (Optional) The prefix.
        :param parameters: (Optional) The required and optional parameters specified in the document.
        :param service_role_arn: (Optional) The ARN of the AWS Identity and Access Management (IAM) role.
        :param timeout_seconds: (Optional) The amount of time in seconds to wait for a command to deliver to the AWS Systems Manager SSM Agent on an instance. If the command isn't received by the SSM Agent on the instance before the value specified is reached, then the status of the command changes to Delivery Timed Out.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f24200fad9cefb9c3a495ede05b359e8b60657017fdfdaee3e733c98b119b1c)
            check_type(argname="argument document_name", value=document_name, expected_type=type_hints["document_name"])
            check_type(argname="argument targets", value=targets, expected_type=type_hints["targets"])
            check_type(argname="argument cloud_watch_output_config", value=cloud_watch_output_config, expected_type=type_hints["cloud_watch_output_config"])
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument document_hash", value=document_hash, expected_type=type_hints["document_hash"])
            check_type(argname="argument document_hash_type", value=document_hash_type, expected_type=type_hints["document_hash_type"])
            check_type(argname="argument max_concurrency", value=max_concurrency, expected_type=type_hints["max_concurrency"])
            check_type(argname="argument max_errors", value=max_errors, expected_type=type_hints["max_errors"])
            check_type(argname="argument notification_config", value=notification_config, expected_type=type_hints["notification_config"])
            check_type(argname="argument output_s3_bucket_name", value=output_s3_bucket_name, expected_type=type_hints["output_s3_bucket_name"])
            check_type(argname="argument output_s3_key_prefix", value=output_s3_key_prefix, expected_type=type_hints["output_s3_key_prefix"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument service_role_arn", value=service_role_arn, expected_type=type_hints["service_role_arn"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "document_name": document_name,
            "targets": targets,
        }
        if cloud_watch_output_config is not None:
            self._values["cloud_watch_output_config"] = cloud_watch_output_config
        if comment is not None:
            self._values["comment"] = comment
        if document_hash is not None:
            self._values["document_hash"] = document_hash
        if document_hash_type is not None:
            self._values["document_hash_type"] = document_hash_type
        if max_concurrency is not None:
            self._values["max_concurrency"] = max_concurrency
        if max_errors is not None:
            self._values["max_errors"] = max_errors
        if notification_config is not None:
            self._values["notification_config"] = notification_config
        if output_s3_bucket_name is not None:
            self._values["output_s3_bucket_name"] = output_s3_bucket_name
        if output_s3_key_prefix is not None:
            self._values["output_s3_key_prefix"] = output_s3_key_prefix
        if parameters is not None:
            self._values["parameters"] = parameters
        if service_role_arn is not None:
            self._values["service_role_arn"] = service_role_arn
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def document_name(self) -> builtins.str:
        '''If the Command type document is owned by you or AWS, specify the name of the document.

        If you're using a document shared with you by a different AWS account, specify the Amazon Resource Name (ARN) of the document.
        '''
        result = self._values.get("document_name")
        assert result is not None, "Required property 'document_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def targets(self) -> typing.List[builtins.str]:
        '''The instance IDs where you want the command to run. You can specify a maximum of 50 IDs.

        You can also use the pseudo parameter {{ RESOURCE_ID }} in place of instance IDs to run the command on all instances in the target group. For more information about pseudo parameters, see `About pseudo parameters <https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-register-tasks-parameters.html>`_.

        Another alternative is to send commands to a fleet of instances by using the Targets parameter. The Targets parameter accepts Amazon Elastic Compute Cloud (Amazon EC2) tags. For more information about how to use the Targets parameter, see `Using targets and rate controls to send commands to a fleet <https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html>`_.
        '''
        result = self._values.get("targets")
        assert result is not None, "Required property 'targets' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def cloud_watch_output_config(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(Optional) Configuration options for sending command output to Amazon CloudWatch Logs.

        For more information about sending command output to CloudWatch Logs, see `Configuring Amazon CloudWatch Logs for Run Command <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-rc-setting-up-cwlogs.html>`_.
        '''
        result = self._values.get("cloud_watch_output_config")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''(Optional) User-defined information about the command.'''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def document_hash(self) -> typing.Optional[builtins.str]:
        '''(Optional) The hash for the document.'''
        result = self._values.get("document_hash")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def document_hash_type(self) -> typing.Optional[builtins.str]:
        '''(Optional) The type of the hash.'''
        result = self._values.get("document_hash_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_concurrency(self) -> typing.Optional[jsii.Number]:
        '''(Optional) The maximum concurrency.'''
        result = self._values.get("max_concurrency")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_errors(self) -> typing.Optional[jsii.Number]:
        '''(Optional) The maximum errors.'''
        result = self._values.get("max_errors")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def notification_config(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(Optional) The configurations for sending notifications.'''
        result = self._values.get("notification_config")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def output_s3_bucket_name(self) -> typing.Optional[builtins.str]:
        '''(Optional) The name of the S3 bucket for command output responses.'''
        result = self._values.get("output_s3_bucket_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_s3_key_prefix(self) -> typing.Optional[builtins.str]:
        '''(Optional) The prefix.'''
        result = self._values.get("output_s3_key_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(Optional) The required and optional parameters specified in the document.'''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def service_role_arn(self) -> typing.Optional[builtins.str]:
        '''(Optional) The ARN of the AWS Identity and Access Management (IAM) role.'''
        result = self._values.get("service_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) The amount of time in seconds to wait for a command to deliver to the AWS Systems Manager SSM Agent on an instance.

        If the command isn't received by the SSM Agent on the instance before the value specified is reached, then the status of the command changes to Delivery Timed Out.
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunCommandProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RunCommandSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RunCommandSimulation",
):
    '''AutomationStep implementation of `aws:runCommand <https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-runcommand.html>`_.'''

    def __init__(
        self,
        step: "RunCommandStep",
        *,
        run_command_hook: IRunCommandHook,
    ) -> None:
        '''
        :param step: -
        :param run_command_hook: Hook for simulating aws:runCommand. Default: - Uses AWS API to execute the document remotely.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88afce5eb250444d9d9ff3910fde49f11e47e81e17996f50260e32bce1bfba07)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = RunCommandSimulationProps(run_command_hook=run_command_hook)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''May perform a real approval ask based on the params used during instance creation.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac151379d225837120cfb987182a1ab92c593d0ec16c674345a51e9b9f95f9fe)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RunCommandSimulationProps",
    jsii_struct_bases=[],
    name_mapping={"run_command_hook": "runCommandHook"},
)
class RunCommandSimulationProps:
    def __init__(self, *, run_command_hook: IRunCommandHook) -> None:
        '''Properties for RunCommandStep.

        :param run_command_hook: Hook for simulating aws:runCommand. Default: - Uses AWS API to execute the document remotely.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__676945251db66ccd57de288b8397fea6f4c2bf1ba78ea674a47fbd2c545aa959)
            check_type(argname="argument run_command_hook", value=run_command_hook, expected_type=type_hints["run_command_hook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "run_command_hook": run_command_hook,
        }

    @builtins.property
    def run_command_hook(self) -> IRunCommandHook:
        '''Hook for simulating aws:runCommand.

        :default: - Uses AWS API to execute the document remotely.
        '''
        result = self._values.get("run_command_hook")
        assert result is not None, "Required property 'run_command_hook' is missing"
        return typing.cast(IRunCommandHook, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunCommandSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RunInstanceSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RunInstanceSimulation",
):
    '''AutomationStep implemenation for aws:runInstance https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-runinstance.html.'''

    def __init__(self, step: "RunInstanceStep", *, aws_invoker: IAwsInvoker) -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__307b83d9860b5335fb34f0fc4cbdd980e27a29cdbc08dfd92f2a6adbcc3b404f)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = AwsInvocationSimulationProps(aws_invoker=aws_invoker)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4ec5870a0be147b7294b99ea4c5a63bf1e421828eeb5ec8efc7753cddc02a69)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


class RunPowerShellScriptSimulation(
    CommandSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RunPowerShellScriptSimulation",
):
    def __init__(
        self,
        step: "RunPowerShellScriptStep",
        *,
        environment: IEnvironment,
    ) -> None:
        '''
        :param step: -
        :param environment: (Optional) Specify here the environment in which to execute the scripts. Use the DockerEnvironment to execute the commands inside the docker. You can alternatively use the LoggingEnvironment which simply logs the commands or MockEnvironment which saves them for validation. Default: LoggingEnvironment
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8b62843905cc949080ef464eb415e5f63323d695bd6ec80e8d047007c6839c2)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = EnvironmentProps(environment=environment)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''Executes the runCommands against the environment provided in the constructor.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4716f35a1b81a1870feb5c2f9726a9cc63526839140af14818c1388332e086ff)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(None, jsii.invoke(self, "executeStep", [inputs]))


class RunShellScriptSimulation(
    CommandSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RunShellScriptSimulation",
):
    def __init__(
        self,
        step: "RunShellScriptStep",
        *,
        environment: IEnvironment,
    ) -> None:
        '''
        :param step: -
        :param environment: (Optional) Specify here the environment in which to execute the scripts. Use the DockerEnvironment to execute the commands inside the docker. You can alternatively use the LoggingEnvironment which simply logs the commands or MockEnvironment which saves them for validation. Default: LoggingEnvironment
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1a32cfebb016378e3a82a8db21a9dc007482f25263cf8d81470b20425c89b94)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = EnvironmentProps(environment=environment)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''Executes the runCommands against the environment provided in the constructor.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7489209e007758049b3778523bdee589acd00d8b3a8b3b90e7dbf7bd931fad6)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(None, jsii.invoke(self, "executeStep", [inputs]))


@jsii.implements(IDownloadableContent)
class S3Content(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.S3Content",
):
    def __init__(self, *, path: IStringVariable) -> None:
        '''
        :param path: The URL to the file or directory you want to download.
        '''
        props = S3ContentProps(path=path)

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="formatSourceInfo")
    def format_source_info(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatSourceInfo", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "path"))

    @builtins.property
    @jsii.member(jsii_name="sourceType")
    def source_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceType"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.S3ContentProps",
    jsii_struct_bases=[],
    name_mapping={"path": "path"},
)
class S3ContentProps:
    def __init__(self, *, path: IStringVariable) -> None:
        '''Properties.json for sourceType GitHub.

        :param path: The URL to the file or directory you want to download.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80e8e384e09bec652d78ad911c30fd3cd8a016229f95be6f587c1ccd94ca0b20)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
        }

    @builtins.property
    def path(self) -> IStringVariable:
        '''The URL to the file or directory you want to download.'''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(IStringVariable, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3ContentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IDownloadableContent)
class SSMDocumentContent(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.SSMDocumentContent",
):
    def __init__(self, *, document_source: DocumentSource) -> None:
        '''
        :param document_source: specify one of the following The name and version of the document in the following format: name:version. Version is optional. or The ARN for the document in the following format: arn:aws:ssm:region:account_id:document/document_name
        '''
        props = SsmDocumentContentProps(document_source=document_source)

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="formatSourceInfo")
    def format_source_info(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatSourceInfo", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @builtins.property
    @jsii.member(jsii_name="documentSource")
    def document_source(self) -> DocumentSource:
        return typing.cast(DocumentSource, jsii.get(self, "documentSource"))

    @builtins.property
    @jsii.member(jsii_name="sourceType")
    def source_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceType"))


class ScriptCode(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.ScriptCode",
):
    '''The code to run for the execution.

    See "script" parameter here:
    https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-executeScript.html
    Attachments are not yet supported.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromFile")
    @builtins.classmethod
    def from_file(cls, full_path: builtins.str) -> "FileScriptCode":
        '''Full path to the code to execute.

        File is parsed to produce yaml/json.
        Simulation will execute this file using the language specified.
        (Attachments not yet supported)

        :param full_path: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95dda5e817a56a1cb29821460ee6ed658256da8a06ae7f9d340218678c070d53)
            check_type(argname="argument full_path", value=full_path, expected_type=type_hints["full_path"])
        return typing.cast("FileScriptCode", jsii.sinvoke(cls, "fromFile", [full_path]))

    @jsii.member(jsii_name="inline")
    @builtins.classmethod
    def inline(cls, code: builtins.str) -> "InlineScriptCode":
        '''Inline code to be executed.

        String will be used to produce function in yaml/json.
        Simulation will execute the function in this string using the language specified.

        :param code: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e095e40715e1564535f481aca90d04590e67850bd1a324eb4b0b80101251b67)
            check_type(argname="argument code", value=code, expected_type=type_hints["code"])
        return typing.cast("InlineScriptCode", jsii.sinvoke(cls, "inline", [code]))

    @jsii.member(jsii_name="codeAsString")
    @abc.abstractmethod
    def code_as_string(self) -> builtins.str:
        '''
        :return: code as a string
        '''
        ...

    @jsii.member(jsii_name="createOrGetFile")
    @abc.abstractmethod
    def create_or_get_file(self, suffix: builtins.str) -> builtins.str:
        '''If there is a file for this code, return it.

        Otherwise, create a file with the specified suffix.

        :param suffix: of the file to create (such as ".py").
        '''
        ...


class _ScriptCodeProxy(ScriptCode):
    @jsii.member(jsii_name="codeAsString")
    def code_as_string(self) -> builtins.str:
        '''
        :return: code as a string
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "codeAsString", []))

    @jsii.member(jsii_name="createOrGetFile")
    def create_or_get_file(self, suffix: builtins.str) -> builtins.str:
        '''If there is a file for this code, return it.

        Otherwise, create a file with the specified suffix.

        :param suffix: of the file to create (such as ".py").
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66a0f0035a625e3974069e210c6e744a92bfa2cff73502f8ffc23aa4530c9d2a)
            check_type(argname="argument suffix", value=suffix, expected_type=type_hints["suffix"])
        return typing.cast(builtins.str, jsii.invoke(self, "createOrGetFile", [suffix]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, ScriptCode).__jsii_proxy_class__ = lambda : _ScriptCodeProxy


class ScriptLanguage(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.ScriptLanguage",
):
    '''Specifies the script language as described in the "Runtime" argument here: https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-executeScript.html.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromRuntime")
    @builtins.classmethod
    def from_runtime(
        cls,
        runtime: builtins.str,
        handler_name: typing.Optional[builtins.str] = None,
    ) -> "ScriptLanguage":
        '''Creates a ScriptLanguage based on the provided runtime.

        Prefer one of the other static constructors if possible.

        :param runtime: is the runtime name (such as "python3.11").
        :param handler_name: to be provided for python executions.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8baa658a2568618064ffee9b4c5955a049266674e024a435cd3932d4a80c6f33)
            check_type(argname="argument runtime", value=runtime, expected_type=type_hints["runtime"])
            check_type(argname="argument handler_name", value=handler_name, expected_type=type_hints["handler_name"])
        return typing.cast("ScriptLanguage", jsii.sinvoke(cls, "fromRuntime", [runtime, handler_name]))

    @jsii.member(jsii_name="python")
    @builtins.classmethod
    def python(
        cls,
        version: PythonVersion,
        handler_name: builtins.str,
    ) -> "ScriptLanguage":
        '''Create a new ScriptLanguage for python execution.

        :param version: is the pythonVersion to use when writing the document (for simulation will not matter).
        :param handler_name: is the function name in code as entry point for script handler.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c081ddabe99a9dfdd2dc3c0ce2ffcbd10c46de8e82fb6783d9fd8aafad84455d)
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            check_type(argname="argument handler_name", value=handler_name, expected_type=type_hints["handler_name"])
        return typing.cast("ScriptLanguage", jsii.sinvoke(cls, "python", [version, handler_name]))

    @jsii.member(jsii_name="fileSuffix")
    @abc.abstractmethod
    def file_suffix(self) -> builtins.str:
        '''The suffix to apply to file names of this type of execution.'''
        ...

    @jsii.member(jsii_name="runtime")
    @abc.abstractmethod
    def runtime(self) -> builtins.str:
        '''The associated runtime of this ScriptLanguage.'''
        ...

    @jsii.member(jsii_name="simulate")
    @abc.abstractmethod
    def simulate(
        self,
        code: ScriptCode,
        inputs: typing.Mapping[builtins.str, builtins.str],
    ) -> typing.Mapping[builtins.str, builtins.str]:
        '''Simulate an execution of this ScriptLanguage.

        Provide the inputs after replaced with the actual values (not variables).

        :param code: -
        :param inputs: -
        '''
        ...

    @jsii.member(jsii_name="ssmInputs")
    @abc.abstractmethod
    def ssm_inputs(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''Builds the ssm inputs.'''
        ...


class _ScriptLanguageProxy(ScriptLanguage):
    @jsii.member(jsii_name="fileSuffix")
    def file_suffix(self) -> builtins.str:
        '''The suffix to apply to file names of this type of execution.'''
        return typing.cast(builtins.str, jsii.invoke(self, "fileSuffix", []))

    @jsii.member(jsii_name="runtime")
    def runtime(self) -> builtins.str:
        '''The associated runtime of this ScriptLanguage.'''
        return typing.cast(builtins.str, jsii.invoke(self, "runtime", []))

    @jsii.member(jsii_name="simulate")
    def simulate(
        self,
        code: ScriptCode,
        inputs: typing.Mapping[builtins.str, builtins.str],
    ) -> typing.Mapping[builtins.str, builtins.str]:
        '''Simulate an execution of this ScriptLanguage.

        Provide the inputs after replaced with the actual values (not variables).

        :param code: -
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b640cde94010758da5d149620b86266e162eea51a33bccbfc0ec1fc72bfceef9)
            check_type(argname="argument code", value=code, expected_type=type_hints["code"])
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.invoke(self, "simulate", [code, inputs]))

    @jsii.member(jsii_name="ssmInputs")
    def ssm_inputs(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''Builds the ssm inputs.'''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.invoke(self, "ssmInputs", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, ScriptLanguage).__jsii_proxy_class__ = lambda : _ScriptLanguageProxy


@jsii.implements(IGenericVariable)
class SecureVariable(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.SecureVariable",
):
    '''A secure string variable.

    Only supported by Command documents (only supported in downloadContent plugin).
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="ofParameter")
    @builtins.classmethod
    def of_parameter(cls, reference: builtins.str) -> "NonSecureVariable":
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57f22996dac5468ad50f65a404c1be0a2ccb9f11053ed0ef6c9c959a593a9de6)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        return typing.cast("NonSecureVariable", jsii.sinvoke(cls, "ofParameter", [reference]))

    @jsii.member(jsii_name="ofSecureToken")
    @builtins.classmethod
    def of_secure_token(cls, secure_token: builtins.str) -> "SsmSecureVariable":
        '''
        :param secure_token: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab26926b5e1fbeeb1c5060acc57879e6ff361d9e09df2ca0000d9fdec39b50b4)
            check_type(argname="argument secure_token", value=secure_token, expected_type=type_hints["secure_token"])
        return typing.cast("SsmSecureVariable", jsii.sinvoke(cls, "ofSecureToken", [secure_token]))

    @jsii.member(jsii_name="ofValue")
    @builtins.classmethod
    def of_value(cls, value: builtins.str) -> "HardCodedSecureVariable":
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3b7f0e01c35ee4ce3153c7b939d47423de71a3ba685dea7672789c0f7ce9e80)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("HardCodedSecureVariable", jsii.sinvoke(cls, "ofValue", [value]))

    @jsii.member(jsii_name="print")
    @abc.abstractmethod
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.
        '''
        ...

    @jsii.member(jsii_name="requiredInputs")
    @abc.abstractmethod
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        ...

    @jsii.member(jsii_name="resolve")
    @abc.abstractmethod
    def resolve(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        ...

    @jsii.member(jsii_name="toJSON")
    def to_json(self) -> typing.Any:
        '''JSON.stringify(variable) will implicitly invoke this variable.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJSON", []))


class _SecureVariableProxy(SecureVariable):
    @jsii.member(jsii_name="print")
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "print", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="resolve")
    def resolve(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__705ccfa75e3f01a73af05ace9b99d5ab042c2fdc5016fcbaa45927f39b94e860)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", [inputs]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, SecureVariable).__jsii_proxy_class__ = lambda : _SecureVariableProxy


class Simulation(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.Simulation",
):
    @jsii.member(jsii_name="ofAutomation")
    @builtins.classmethod
    def of_automation(
        cls,
        document: "AutomationDocument",
        *,
        approve_hook: typing.Optional[IApproveHook] = None,
        aws_invoker: typing.Optional[IAwsInvoker] = None,
        execute_automation_hook: typing.Optional[IExecuteAutomationHook] = None,
        input_observer: typing.Optional[IObserver] = None,
        output_observer: typing.Optional[IObserver] = None,
        parameter_resolver: typing.Optional[IParameterResolver] = None,
        pause_hook: typing.Optional[IPauseHook] = None,
        run_command_hook: typing.Optional[IRunCommandHook] = None,
        sleep_hook: typing.Optional[ISleepHook] = None,
        webhook: typing.Optional[IWebhook] = None,
    ) -> "Simulation":
        '''
        :param document: -
        :param approve_hook: (Optional) Approve hook to be called to pause the execution. To mock this implementation either inject an instance of IApproveHook or use the provided MockApprove class. Default: ApproveHook instance. ApproveHook may not work in exported JSII languages. Override interface as needed.
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param execute_automation_hook: Hook for simulating aws:executeAutomation. Default: - Uses AWS API to execute the document remotely.
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param parameter_resolver: (Optional) Resolver for secure strings in parameters. Required to simulate if using tokens in parameters input. Default: - Treats parameters as literal
        :param pause_hook: (Optional) Pause hook to be called to pause the execution. To mock this implemenation either inject an instance of IPauseHook or use the provided MockPause class. Default: PauseHook instance. PauseHook may not work in exported JSII languages. Override interface as needed.
        :param run_command_hook: Hook for simulating aws:runCommand. Default: - Uses AWS API to execute the document remotely.
        :param sleep_hook: (Optional) Hook to inject alternate ISleeper (to mock the sleep between failed invocations). Default: - really perform sleep using SleeperImpl class.
        :param webhook: (Optional) Hook for simulating aws:invokeWebhook. Default: - Returns 204 with an empty response
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0057ba3e46b2c1b6b04d3fa682642b09a93f307403394adad18d2b16436a2436)
            check_type(argname="argument document", value=document, expected_type=type_hints["document"])
        props = AutomationSimulationProps(
            approve_hook=approve_hook,
            aws_invoker=aws_invoker,
            execute_automation_hook=execute_automation_hook,
            input_observer=input_observer,
            output_observer=output_observer,
            parameter_resolver=parameter_resolver,
            pause_hook=pause_hook,
            run_command_hook=run_command_hook,
            sleep_hook=sleep_hook,
            webhook=webhook,
        )

        return typing.cast("Simulation", jsii.sinvoke(cls, "ofAutomation", [document, props]))

    @jsii.member(jsii_name="ofCommand")
    @builtins.classmethod
    def of_command(
        cls,
        document: "CommandDocument",
        *,
        simulation_platform: Platform,
        environment: typing.Optional[IEnvironment] = None,
    ) -> "Simulation":
        '''
        :param document: -
        :param simulation_platform: The Platform used in executing the command step.
        :param environment: (Optional) Specify here the environment in which to execute the scripts. Use the DockerEnvironment to execute the commands inside the docker. You can alternatively use the LoggingEnvironment which simply logs the commands or MockEnvironment which saves them for validation. Default: LoggingEnvironment
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e73e5fd5e0bc4a40acc3ba0533b9bd22ac241c9ce95b4e8ff9942061a22dba20)
            check_type(argname="argument document", value=document, expected_type=type_hints["document"])
        props = CommandSimulationProps(
            simulation_platform=simulation_platform, environment=environment
        )

        return typing.cast("Simulation", jsii.sinvoke(cls, "ofCommand", [document, props]))

    @jsii.member(jsii_name="simulate")
    def simulate(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> "DocumentResult":
        '''Synthesize before calling this function! You can use this to Synthesize: SynthUtils.synthesize(stack);

        Executes the SSM Document in simulation mode.
        This method DOES NOT result in invocation of SSM APIs.
        Rather, all steps are executed locally and mimic the behavior of SSM.
        If any inputs are not provided in this function, the specified defaults for the inputs will be used.

        :param inputs: the inputs to feed into the simulated execution.

        :return: the outputs of all the executed steps.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21dc76e4551c05ec86159ee0de72ed16e421de5401ac77c2648a085ae4a1c53e)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast("DocumentResult", jsii.invoke(self, "simulate", [inputs]))

    @jsii.member(jsii_name="start")
    def _start(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> "SimulationResult":
        '''Delegates the execution of the Document to the subclass (Automation, etc).

        :param inputs: a merge of the defined inputs to the document and the default values if not supplied.

        :return: the outputs that were emitted from all of the steps.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50fbb7dfba5b336b55281684484180f15dc54d5c98aa19bf5a79e5b85d7a16a2)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast("SimulationResult", jsii.invoke(self, "start", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="document")
    def document(self) -> "SsmDocument":
        return typing.cast("SsmDocument", jsii.get(self, "document"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> "SimulationProps":
        return typing.cast("SimulationProps", jsii.get(self, "props"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.SimulationProps",
    jsii_struct_bases=[],
    name_mapping={
        "approve_hook": "approveHook",
        "aws_invoker": "awsInvoker",
        "environment": "environment",
        "input_observer": "inputObserver",
        "output_observer": "outputObserver",
        "parameter_resolver": "parameterResolver",
        "pause_hook": "pauseHook",
        "run_command_hook": "runCommandHook",
        "simulation_platform": "simulationPlatform",
        "sleep_hook": "sleepHook",
        "webhook": "webhook",
    },
)
class SimulationProps:
    def __init__(
        self,
        *,
        approve_hook: typing.Optional[IApproveHook] = None,
        aws_invoker: typing.Optional[IAwsInvoker] = None,
        environment: typing.Optional[IEnvironment] = None,
        input_observer: typing.Optional[IObserver] = None,
        output_observer: typing.Optional[IObserver] = None,
        parameter_resolver: typing.Optional[IParameterResolver] = None,
        pause_hook: typing.Optional[IPauseHook] = None,
        run_command_hook: typing.Optional[IRunCommandHook] = None,
        simulation_platform: typing.Optional[Platform] = None,
        sleep_hook: typing.Optional[ISleepHook] = None,
        webhook: typing.Optional[IWebhook] = None,
    ) -> None:
        '''Universe of Automation and Command simulation props.

        :param approve_hook: 
        :param aws_invoker: 
        :param environment: 
        :param input_observer: 
        :param output_observer: 
        :param parameter_resolver: 
        :param pause_hook: 
        :param run_command_hook: 
        :param simulation_platform: 
        :param sleep_hook: 
        :param webhook: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c459d580c024550bd368419ad91dc4d6e469c9fdcc8f0dc59c3c85583edc4c3)
            check_type(argname="argument approve_hook", value=approve_hook, expected_type=type_hints["approve_hook"])
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument parameter_resolver", value=parameter_resolver, expected_type=type_hints["parameter_resolver"])
            check_type(argname="argument pause_hook", value=pause_hook, expected_type=type_hints["pause_hook"])
            check_type(argname="argument run_command_hook", value=run_command_hook, expected_type=type_hints["run_command_hook"])
            check_type(argname="argument simulation_platform", value=simulation_platform, expected_type=type_hints["simulation_platform"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if approve_hook is not None:
            self._values["approve_hook"] = approve_hook
        if aws_invoker is not None:
            self._values["aws_invoker"] = aws_invoker
        if environment is not None:
            self._values["environment"] = environment
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if parameter_resolver is not None:
            self._values["parameter_resolver"] = parameter_resolver
        if pause_hook is not None:
            self._values["pause_hook"] = pause_hook
        if run_command_hook is not None:
            self._values["run_command_hook"] = run_command_hook
        if simulation_platform is not None:
            self._values["simulation_platform"] = simulation_platform
        if sleep_hook is not None:
            self._values["sleep_hook"] = sleep_hook
        if webhook is not None:
            self._values["webhook"] = webhook

    @builtins.property
    def approve_hook(self) -> typing.Optional[IApproveHook]:
        result = self._values.get("approve_hook")
        return typing.cast(typing.Optional[IApproveHook], result)

    @builtins.property
    def aws_invoker(self) -> typing.Optional[IAwsInvoker]:
        result = self._values.get("aws_invoker")
        return typing.cast(typing.Optional[IAwsInvoker], result)

    @builtins.property
    def environment(self) -> typing.Optional[IEnvironment]:
        result = self._values.get("environment")
        return typing.cast(typing.Optional[IEnvironment], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def parameter_resolver(self) -> typing.Optional[IParameterResolver]:
        result = self._values.get("parameter_resolver")
        return typing.cast(typing.Optional[IParameterResolver], result)

    @builtins.property
    def pause_hook(self) -> typing.Optional[IPauseHook]:
        result = self._values.get("pause_hook")
        return typing.cast(typing.Optional[IPauseHook], result)

    @builtins.property
    def run_command_hook(self) -> typing.Optional[IRunCommandHook]:
        result = self._values.get("run_command_hook")
        return typing.cast(typing.Optional[IRunCommandHook], result)

    @builtins.property
    def simulation_platform(self) -> typing.Optional[Platform]:
        result = self._values.get("simulation_platform")
        return typing.cast(typing.Optional[Platform], result)

    @builtins.property
    def sleep_hook(self) -> typing.Optional[ISleepHook]:
        result = self._values.get("sleep_hook")
        return typing.cast(typing.Optional[ISleepHook], result)

    @builtins.property
    def webhook(self) -> typing.Optional[IWebhook]:
        result = self._values.get("webhook")
        return typing.cast(typing.Optional[IWebhook], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.SimulationResult",
    jsii_struct_bases=[],
    name_mapping={
        "executed_steps": "executedSteps",
        "response_code": "responseCode",
        "outputs": "outputs",
        "stack_trace": "stackTrace",
    },
)
class SimulationResult:
    def __init__(
        self,
        *,
        executed_steps: typing.Sequence[builtins.str],
        response_code: ResponseCode,
        outputs: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        stack_trace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Response object returned from steps.

        A successful response will contain the outputs expected.
        A failed/canceled response will contain the stackTrace.
        A failure will propagate up the stack unless the step is marked to succeed on failure.

        :param executed_steps: All the steps that were executed in this Simulation.
        :param response_code: 
        :param outputs: May be empty if responseCode is FAILED/CANCELLED. There are no outputs provided for Command steps or documents.
        :param stack_trace: undefined if responseCode is SUCCESS.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0c102951a3507961d6e7970dc1e1479e3ed8ddac46ddedab05bac0254ae648a)
            check_type(argname="argument executed_steps", value=executed_steps, expected_type=type_hints["executed_steps"])
            check_type(argname="argument response_code", value=response_code, expected_type=type_hints["response_code"])
            check_type(argname="argument outputs", value=outputs, expected_type=type_hints["outputs"])
            check_type(argname="argument stack_trace", value=stack_trace, expected_type=type_hints["stack_trace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "executed_steps": executed_steps,
            "response_code": response_code,
        }
        if outputs is not None:
            self._values["outputs"] = outputs
        if stack_trace is not None:
            self._values["stack_trace"] = stack_trace

    @builtins.property
    def executed_steps(self) -> typing.List[builtins.str]:
        '''All the steps that were executed in this Simulation.'''
        result = self._values.get("executed_steps")
        assert result is not None, "Required property 'executed_steps' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def response_code(self) -> ResponseCode:
        result = self._values.get("response_code")
        assert result is not None, "Required property 'response_code' is missing"
        return typing.cast(ResponseCode, result)

    @builtins.property
    def outputs(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''May be empty if responseCode is FAILED/CANCELLED.

        There are no outputs provided for Command steps or documents.
        '''
        result = self._values.get("outputs")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def stack_trace(self) -> typing.Optional[builtins.str]:
        '''undefined if responseCode is SUCCESS.'''
        result = self._values.get("stack_trace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SimulationResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(ISleepHook)
class SleepImpl(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.SleepImpl",
):
    '''Performs a real sleep.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="sleep")
    def sleep(self, time_millis: jsii.Number) -> None:
        '''Synchronously sleeps for duration specified in millis.

        :param time_millis: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e01e1f530d0d92e24832816c862e424f4fd37a16f84302b2ed04e4b096fc90b8)
            check_type(argname="argument time_millis", value=time_millis, expected_type=type_hints["time_millis"])
        return typing.cast(None, jsii.invoke(self, "sleep", [time_millis]))


class SleepSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.SleepSimulation",
):
    '''AutomationStep implemenation for aws:sleep https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-sleep.html.'''

    def __init__(self, step: "SleepStep", *, sleep_hook: ISleepHook) -> None:
        '''
        :param step: -
        :param sleep_hook: (Optional) Whether to really perform a pause of the runtime. To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class. Default: SleeperImpl
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__223df04da6068cea9edb22daa0c13f487ec190f7318bea1f45fbd02b0443c568)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = SleepSimulationProps(sleep_hook=sleep_hook)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        _inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param _inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2998bc6e39655c561ebde8e0624fe48d8e69ca0128f2bfb3fe685f5b8526bfa5)
            check_type(argname="argument _inputs", value=_inputs, expected_type=type_hints["_inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [_inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.SleepSimulationProps",
    jsii_struct_bases=[],
    name_mapping={"sleep_hook": "sleepHook"},
)
class SleepSimulationProps:
    def __init__(self, *, sleep_hook: ISleepHook) -> None:
        '''Properties for sleep step.

        :param sleep_hook: (Optional) Whether to really perform a pause of the runtime. To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class. Default: SleeperImpl
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__642d1616655c906e054542e9bdfbea706653d7a4217be34965fce5a6dd9a0eb1)
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "sleep_hook": sleep_hook,
        }

    @builtins.property
    def sleep_hook(self) -> ISleepHook:
        '''(Optional) Whether to really perform a pause of the runtime.

        To override sleep behavior, inject an ISleepHook impl or use the provided MockSleep class.

        :default: SleeperImpl
        '''
        result = self._values.get("sleep_hook")
        assert result is not None, "Required property 'sleep_hook' is missing"
        return typing.cast(ISleepHook, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SleepSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.SsmAutomationProps",
    jsii_struct_bases=[],
    name_mapping={"parameters": "parameters", "target_account": "targetAccount"},
)
class SsmAutomationProps:
    def __init__(
        self,
        *,
        parameters: typing.Mapping[builtins.str, IGenericVariable],
        target_account: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param parameters: Specify either StringVariables or HardCodedValues.
        :param target_account: The account that the automation document will be run in. This can be in either the management account or an application account.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd6936d429de9627e458e84e2940817eb0dfadbcd69f60698b88fe214eb33074)
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument target_account", value=target_account, expected_type=type_hints["target_account"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "parameters": parameters,
        }
        if target_account is not None:
            self._values["target_account"] = target_account

    @builtins.property
    def parameters(self) -> typing.Mapping[builtins.str, IGenericVariable]:
        '''Specify either StringVariables or HardCodedValues.

        :link: : https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssmincidents-responseplan-ssmparameter.html
        '''
        result = self._values.get("parameters")
        assert result is not None, "Required property 'parameters' is missing"
        return typing.cast(typing.Mapping[builtins.str, IGenericVariable], result)

    @builtins.property
    def target_account(self) -> typing.Optional[builtins.str]:
        '''The account that the automation document will be run in.

        This can be in either the management account or an application account.

        :link: : http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssmincidents-responseplan-ssmautomation.html#cfn-ssmincidents-responseplan-ssmautomation-targetaccount
        '''
        result = self._values.get("target_account")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SsmAutomationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SsmDocument(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.SsmDocument",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        assume_role: typing.Optional[IStringVariable] = None,
        description: typing.Optional[builtins.str] = None,
        doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
        doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
        document_format: typing.Optional[DocumentFormat] = None,
        document_name: typing.Optional[builtins.str] = None,
        header: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional[builtins.str] = None,
        version_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param assume_role: (Optional) Assume role to use for this document. If provided, this value MUST be included as one of the documentInput names.
        :param description: (Optional) Description of the document. Defaults to the document name.
        :param doc_inputs: (Optional) Inputs required by the document.
        :param doc_outputs: (Optional) Outputs to be emitted from the document. The outputs are placed in a StringSet called outputs (as is done in SSM). Default: []
        :param document_format: (Optional) Specifies whether this document should be written as YAML or JSON. Default: JSON
        :param document_name: (Optional) Name of the document. Will default to the id provided for the CDK node.
        :param header: (Optional) A Header/comment to include at the start of a YAML document. JSON documents do not support headers.
        :param requires: ``AWS::SSM::Document.Requires``.
        :param tags: ``AWS::SSM::Document.Tags``.
        :param target_type: ``AWS::SSM::Document.TargetType``.
        :param update_method: If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced. ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version.
        :param version_name: ``AWS::SSM::Document.VersionName``.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55faabeee86a752a753a75f8210cffcadf87ed1a36685bb357e31a71f3760f52)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SsmDocumentProps(
            assume_role=assume_role,
            description=description,
            doc_inputs=doc_inputs,
            doc_outputs=doc_outputs,
            document_format=document_format,
            document_name=document_name,
            header=header,
            requires=requires,
            tags=tags,
            target_type=target_type,
            update_method=update_method,
            version_name=version_name,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="buildSsmDocument")
    @abc.abstractmethod
    def _build_ssm_document(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Delegates building the SSM Document to be converted to a yaml/json to the subclass (Automation etc).'''
        ...

    @jsii.member(jsii_name="documentType")
    @abc.abstractmethod
    def document_type(self) -> builtins.str:
        ...

    @jsii.member(jsii_name="formatInputs")
    def _format_inputs(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''The SSM Document inputs optionally specify a number of parameters including allowedValues, minItems etc.

        This function builds an object containing the relevant (declared) input parameters.
        The return object will be used to build the yaml/json representation of the document.
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatInputs", []))

    @jsii.member(jsii_name="print")
    def print(self) -> builtins.str:
        '''Synthesize before calling this function! You can use this to Synthesize: cdk.SynthUtils.synthesize(stack);

        Converts the objects define in the SSM Document (including all of the steps) to an SSM document string.
        The format is dependency on the documentFormat property provided to the class.
        The yaml can be used as is and will behave (or at least should behave) as was simulated in the runSimulation().

        :return: a string representation of this document as an SSM formatted yaml/json.
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "print", []))

    @builtins.property
    @jsii.member(jsii_name="cfnDocument")
    def cfn_document(self) -> _aws_cdk_aws_ssm_ceddda9d.CfnDocument:
        return typing.cast(_aws_cdk_aws_ssm_ceddda9d.CfnDocument, jsii.get(self, "cfnDocument"))

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "description"))

    @builtins.property
    @jsii.member(jsii_name="docInputs")
    def doc_inputs(self) -> typing.List[Input]:
        return typing.cast(typing.List[Input], jsii.get(self, "docInputs"))

    @builtins.property
    @jsii.member(jsii_name="docOutputs")
    def doc_outputs(self) -> typing.List[DocumentOutput]:
        return typing.cast(typing.List[DocumentOutput], jsii.get(self, "docOutputs"))

    @builtins.property
    @jsii.member(jsii_name="documentName")
    def document_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "documentName"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> "SsmDocumentProps":
        return typing.cast("SsmDocumentProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="assumeRole")
    def assume_role(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "assumeRole"))

    @builtins.property
    @jsii.member(jsii_name="header")
    def header(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "header"))


class _SsmDocumentProxy(SsmDocument):
    @jsii.member(jsii_name="buildSsmDocument")
    def _build_ssm_document(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Delegates building the SSM Document to be converted to a yaml/json to the subclass (Automation etc).'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "buildSsmDocument", []))

    @jsii.member(jsii_name="documentType")
    def document_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "documentType", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, SsmDocument).__jsii_proxy_class__ = lambda : _SsmDocumentProxy


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.SsmDocumentContentProps",
    jsii_struct_bases=[],
    name_mapping={"document_source": "documentSource"},
)
class SsmDocumentContentProps:
    def __init__(self, *, document_source: DocumentSource) -> None:
        '''Properties.json for sourceType SsmDocument.

        :param document_source: specify one of the following The name and version of the document in the following format: name:version. Version is optional. or The ARN for the document in the following format: arn:aws:ssm:region:account_id:document/document_name
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa0a79e56c9e32f2cedad09975705da52b9cc8f8e30f635544d1dabd18f52738)
            check_type(argname="argument document_source", value=document_source, expected_type=type_hints["document_source"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "document_source": document_source,
        }

    @builtins.property
    def document_source(self) -> DocumentSource:
        '''specify one of the following The name and version of the document in the following format: name:version.

        Version is optional.
        or The ARN for the document in the following format: arn:aws:ssm:region:account_id:document/document_name
        '''
        result = self._values.get("document_source")
        assert result is not None, "Required property 'document_source' is missing"
        return typing.cast(DocumentSource, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SsmDocumentContentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.SsmDocumentProps",
    jsii_struct_bases=[],
    name_mapping={
        "assume_role": "assumeRole",
        "description": "description",
        "doc_inputs": "docInputs",
        "doc_outputs": "docOutputs",
        "document_format": "documentFormat",
        "document_name": "documentName",
        "header": "header",
        "requires": "requires",
        "tags": "tags",
        "target_type": "targetType",
        "update_method": "updateMethod",
        "version_name": "versionName",
    },
)
class SsmDocumentProps:
    def __init__(
        self,
        *,
        assume_role: typing.Optional[IStringVariable] = None,
        description: typing.Optional[builtins.str] = None,
        doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
        doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
        document_format: typing.Optional[DocumentFormat] = None,
        document_name: typing.Optional[builtins.str] = None,
        header: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional[builtins.str] = None,
        version_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param assume_role: (Optional) Assume role to use for this document. If provided, this value MUST be included as one of the documentInput names.
        :param description: (Optional) Description of the document. Defaults to the document name.
        :param doc_inputs: (Optional) Inputs required by the document.
        :param doc_outputs: (Optional) Outputs to be emitted from the document. The outputs are placed in a StringSet called outputs (as is done in SSM). Default: []
        :param document_format: (Optional) Specifies whether this document should be written as YAML or JSON. Default: JSON
        :param document_name: (Optional) Name of the document. Will default to the id provided for the CDK node.
        :param header: (Optional) A Header/comment to include at the start of a YAML document. JSON documents do not support headers.
        :param requires: ``AWS::SSM::Document.Requires``.
        :param tags: ``AWS::SSM::Document.Tags``.
        :param target_type: ``AWS::SSM::Document.TargetType``.
        :param update_method: If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced. ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version.
        :param version_name: ``AWS::SSM::Document.VersionName``.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__540429ca2b86f7d178406b3dc0aa91c8e421a233d6b4fb5a9eb61af08995eb36)
            check_type(argname="argument assume_role", value=assume_role, expected_type=type_hints["assume_role"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument doc_inputs", value=doc_inputs, expected_type=type_hints["doc_inputs"])
            check_type(argname="argument doc_outputs", value=doc_outputs, expected_type=type_hints["doc_outputs"])
            check_type(argname="argument document_format", value=document_format, expected_type=type_hints["document_format"])
            check_type(argname="argument document_name", value=document_name, expected_type=type_hints["document_name"])
            check_type(argname="argument header", value=header, expected_type=type_hints["header"])
            check_type(argname="argument requires", value=requires, expected_type=type_hints["requires"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument target_type", value=target_type, expected_type=type_hints["target_type"])
            check_type(argname="argument update_method", value=update_method, expected_type=type_hints["update_method"])
            check_type(argname="argument version_name", value=version_name, expected_type=type_hints["version_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assume_role is not None:
            self._values["assume_role"] = assume_role
        if description is not None:
            self._values["description"] = description
        if doc_inputs is not None:
            self._values["doc_inputs"] = doc_inputs
        if doc_outputs is not None:
            self._values["doc_outputs"] = doc_outputs
        if document_format is not None:
            self._values["document_format"] = document_format
        if document_name is not None:
            self._values["document_name"] = document_name
        if header is not None:
            self._values["header"] = header
        if requires is not None:
            self._values["requires"] = requires
        if tags is not None:
            self._values["tags"] = tags
        if target_type is not None:
            self._values["target_type"] = target_type
        if update_method is not None:
            self._values["update_method"] = update_method
        if version_name is not None:
            self._values["version_name"] = version_name

    @builtins.property
    def assume_role(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Assume role to use for this document.

        If provided, this value MUST be included as one of the documentInput names.
        '''
        result = self._values.get("assume_role")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) Description of the document.

        Defaults to the document name.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def doc_inputs(self) -> typing.Optional[typing.List[Input]]:
        '''(Optional) Inputs required by the document.'''
        result = self._values.get("doc_inputs")
        return typing.cast(typing.Optional[typing.List[Input]], result)

    @builtins.property
    def doc_outputs(self) -> typing.Optional[typing.List[DocumentOutput]]:
        '''(Optional) Outputs to be emitted from the document.

        The outputs are placed in a StringSet called outputs (as is done in SSM).

        :default: []
        '''
        result = self._values.get("doc_outputs")
        return typing.cast(typing.Optional[typing.List[DocumentOutput]], result)

    @builtins.property
    def document_format(self) -> typing.Optional[DocumentFormat]:
        '''(Optional) Specifies whether this document should be written as YAML or JSON.

        :default: JSON
        '''
        result = self._values.get("document_format")
        return typing.cast(typing.Optional[DocumentFormat], result)

    @builtins.property
    def document_name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the document.

        Will default to the id provided for the CDK node.
        '''
        result = self._values.get("document_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def header(self) -> typing.Optional[builtins.str]:
        '''(Optional) A Header/comment to include at the start of a YAML document.

        JSON documents do not support headers.
        '''
        result = self._values.get("header")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def requires(
        self,
    ) -> typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.List[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, _aws_cdk_ceddda9d.IResolvable]]]]:
        '''``AWS::SSM::Document.Requires``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-requires
        '''
        result = self._values.get("requires")
        return typing.cast(typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.List[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, _aws_cdk_ceddda9d.IResolvable]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_aws_cdk_ceddda9d.CfnTag]]:
        '''``AWS::SSM::Document.Tags``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_ceddda9d.CfnTag]], result)

    @builtins.property
    def target_type(self) -> typing.Optional[builtins.str]:
        '''``AWS::SSM::Document.TargetType``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-targettype
        '''
        result = self._values.get("target_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update_method(self) -> typing.Optional[builtins.str]:
        '''If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced.

        ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-updatemethod
        '''
        result = self._values.get("update_method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version_name(self) -> typing.Optional[builtins.str]:
        '''``AWS::SSM::Document.VersionName``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-versionname
        '''
        result = self._values.get("version_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SsmDocumentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IRunDocumentLocation)
class SsmRunDocument(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.SsmRunDocument",
):
    def __init__(self, document_name: IStringVariable) -> None:
        '''specify the name of the document.

        :param document_name: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2350a191f371fb089711a9b543e216792db74a4f294bf2275deb45c7e746979)
            check_type(argname="argument document_name", value=document_name, expected_type=type_hints["document_name"])
        jsii.create(self.__class__, self, [document_name])

    @builtins.property
    @jsii.member(jsii_name="location")
    def location(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "location"))

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))


class SsmSecureVariable(
    SecureVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.SsmSecureVariable",
):
    def __init__(self, secure_token: builtins.str) -> None:
        '''
        :param secure_token: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__350b2a7331c989f3b90326eb2a0f6d01e85502573a25c0722dfc9d42c6423174)
            check_type(argname="argument secure_token", value=secure_token, expected_type=type_hints["secure_token"])
        jsii.create(self.__class__, self, [secure_token])

    @jsii.member(jsii_name="print")
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "print", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="resolve")
    def resolve(self, _inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param _inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b5ed4a1e3571ea96c70ed9fe7af3a422f1b5510fac0f5e34714d3d54e02342c)
            check_type(argname="argument _inputs", value=_inputs, expected_type=type_hints["_inputs"])
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", [_inputs]))

    @builtins.property
    @jsii.member(jsii_name="secureToken")
    def secure_token(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "secureToken"))


class Step(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.Step",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__623c83a1748fc8526811375d2a3cd6f277db599fde7fcf886ecb56351ce23dc4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = StepProps(
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    @abc.abstractmethod
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        ...

    @jsii.member(jsii_name="listOutputs")
    @abc.abstractmethod
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        ...

    @jsii.member(jsii_name="toSsmEntry")
    @abc.abstractmethod
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        ...

    @builtins.property
    @jsii.member(jsii_name="action")
    @abc.abstractmethod
    def action(self) -> builtins.str:
        ...

    @builtins.property
    @jsii.member(jsii_name="inputObserver")
    def input_observer(self) -> IObserver:
        return typing.cast(IObserver, jsii.get(self, "inputObserver"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="outputObserver")
    def output_observer(self) -> IObserver:
        return typing.cast(IObserver, jsii.get(self, "outputObserver"))

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))


class _StepProxy(Step):
    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Step).__jsii_proxy_class__ = lambda : _StepProxy


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.StepProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
    },
)
class StepProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d65213af8dedc01ba2d1fa8bc2fbf1fe219c3c2d293e348014f3f7d4564a99d5)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StepRef(metaclass=jsii.JSIIMeta, jsii_type="@cdklabs/cdk-ssm-documents.StepRef"):
    '''Class to reference AutomationSteps.

    The class allows steps to be referenced by the Step object or by the step name.
    '''

    def __init__(self, step_name: builtins.str) -> None:
        '''
        :param step_name: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__479fe23be47f96ab416c7ae3db640997dc2bd4b8f9f8767be0ae7846c16f72a1)
            check_type(argname="argument step_name", value=step_name, expected_type=type_hints["step_name"])
        jsii.create(self.__class__, self, [step_name])

    @jsii.member(jsii_name="fromName")
    @builtins.classmethod
    def from_name(cls, step_name: builtins.str) -> "StepRef":
        '''Static constructor for creating a reference to a step from a step name.

        :param step_name: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c4ccb5cca9a0fae89e1d565e570f2bfd5784af28d6778f7a4d802e0b7602ec3)
            check_type(argname="argument step_name", value=step_name, expected_type=type_hints["step_name"])
        return typing.cast("StepRef", jsii.sinvoke(cls, "fromName", [step_name]))

    @jsii.member(jsii_name="fromObject")
    @builtins.classmethod
    def from_object(cls, step: "AutomationStep") -> "StepRef":
        '''Static constructor for creating a reference to a step from an AutomationStep object.

        :param step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__119283c0cb6af10a44f3d76dbb5e8c81758e0a397e799ae20d903ea837f850bf)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        return typing.cast("StepRef", jsii.sinvoke(cls, "fromObject", [step]))

    @jsii.member(jsii_name="resolve")
    def resolve(
        self,
        all_steps_in_execution: typing.Sequence["AutomationStep"],
    ) -> "AutomationStep":
        '''Resolve to an AutomationStep object.

        Provide all the steps in the execution to find the associated step.

        :param all_steps_in_execution: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__499e8d737216aa2e3ce772e20f71b31a7306ecdb1100e4ffd8326ab9ee7cecb5)
            check_type(argname="argument all_steps_in_execution", value=all_steps_in_execution, expected_type=type_hints["all_steps_in_execution"])
        return typing.cast("AutomationStep", jsii.invoke(self, "resolve", [all_steps_in_execution]))

    @builtins.property
    @jsii.member(jsii_name="stepName")
    def step_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "stepName"))


class StringDocument(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.StringDocument",
):
    '''This AutomationDocument supports declaring your document from an existing document (JSON/YAML String/File).

    Importing an existing file allows for benefiting from the simulated execution.
    The simulated execution will run locally in the same fashion that SSM Execution would run the document.
    You can supply mocks to the simulator and validate the calls and the flow of the document without running via SSM execution.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromFile")
    @builtins.classmethod
    def from_file(
        cls,
        stack: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        document_file_path: builtins.str,
    ) -> "AutomationDocument":
        '''Create an AutomationDocument from an existing AutomationDocument yaml or json file.

        Note: This function will deduce whether the file is written in yaml or json based on whether it has a .yaml or .yml extention.
        You can use the returned AutomationDocument to run simulations as you would other documents created using this library.

        :param stack: -
        :param id: -
        :param document_file_path: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__608ac5c214a9f40a1a8db40859dccd45e6b332042c0445dc5cc9377aaaedafeb)
            check_type(argname="argument stack", value=stack, expected_type=type_hints["stack"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument document_file_path", value=document_file_path, expected_type=type_hints["document_file_path"])
        return typing.cast("AutomationDocument", jsii.sinvoke(cls, "fromFile", [stack, id, document_file_path]))

    @jsii.member(jsii_name="fromJson")
    @builtins.classmethod
    def from_json(
        cls,
        stack: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        document_json: builtins.str,
    ) -> "AutomationDocument":
        '''Create an AutomationDocument from an existing json string.

        You can use the returned AutomationDocument to run simulations as you would other documents created using this library.

        :param stack: -
        :param id: -
        :param document_json: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e791bb2e5fb72b9b8c5bb4b2df8433afcc36544fa4e6929c5a70775c15f3189b)
            check_type(argname="argument stack", value=stack, expected_type=type_hints["stack"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument document_json", value=document_json, expected_type=type_hints["document_json"])
        return typing.cast("AutomationDocument", jsii.sinvoke(cls, "fromJson", [stack, id, document_json]))

    @jsii.member(jsii_name="fromYaml")
    @builtins.classmethod
    def from_yaml(
        cls,
        stack: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        document_yaml: builtins.str,
    ) -> "AutomationDocument":
        '''Create an AutomationDocument from an existing yaml string.

        You can use the returned AutomationDocument to run simulations as you would other documents created using this library.

        :param stack: -
        :param id: -
        :param document_yaml: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ec9a2e49b1db561eb9765c6c2cc4f7da0b1a54f7a60bf2988d109c2526c5800)
            check_type(argname="argument stack", value=stack, expected_type=type_hints["stack"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument document_yaml", value=document_yaml, expected_type=type_hints["document_yaml"])
        return typing.cast("AutomationDocument", jsii.sinvoke(cls, "fromYaml", [stack, id, document_yaml]))


@jsii.implements(IStringVariable)
class StringFormat(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.StringFormat",
):
    '''Replacement for strings using Java String format style "%s" replacements.

    Example: new StringFormat("This %s a replacement: %s", [new HardCodedValue("is"), new ExportedVariable("myInput")]);
    The supported variable strings are either:

    1. Implicit indices: "%s" where the first occurrence will match the first variable, the next will match the second...
    2. Explicit indices: Example: "%1$s"; where "%1$s" matches the first variable and "%1$s" matches the second.
       Do not combine usage of implicit and explicit indices. Choose one per StringFormat instance.
    '''

    def __init__(
        self,
        format: builtins.str,
        variables: typing.Optional[typing.Sequence[IGenericVariable]] = None,
    ) -> None:
        '''
        :param format: -
        :param variables: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3b5f835194f1408feefd3eae90c01389e256dd19967e855b30d2f84d42dec22)
            check_type(argname="argument format", value=format, expected_type=type_hints["format"])
            check_type(argname="argument variables", value=variables, expected_type=type_hints["variables"])
        jsii.create(self.__class__, self, [format, variables])

    @jsii.member(jsii_name="print")
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "print", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="resolve")
    def resolve(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80417c00e6968ee7242ba99b34f2aa9e33e5eacc036305b9cb84e4d818e387dc)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", [inputs]))

    @jsii.member(jsii_name="resolveToString")
    def resolve_to_string(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.str:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d054c7bd32ab1de4b03c81a8555fe552a04d6434e6a2dbd86c87f57900f69a18)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveToString", [inputs]))

    @jsii.member(jsii_name="toJSON")
    def to_json(self) -> typing.Any:
        '''JSON.stringify(variable) will implicitly invoke this variable.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJSON", []))

    @builtins.property
    @jsii.member(jsii_name="format")
    def format(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "format"))

    @builtins.property
    @jsii.member(jsii_name="variables")
    def variables(self) -> typing.List[IGenericVariable]:
        return typing.cast(typing.List[IGenericVariable], jsii.get(self, "variables"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.StringInputProps",
    jsii_struct_bases=[],
    name_mapping={
        "allowed_pattern": "allowedPattern",
        "allowed_values": "allowedValues",
        "default_value": "defaultValue",
        "description": "description",
        "max_chars": "maxChars",
        "min_chars": "minChars",
    },
)
class StringInputProps:
    def __init__(
        self,
        *,
        allowed_pattern: typing.Optional[builtins.str] = None,
        allowed_values: typing.Optional[typing.Sequence[builtins.str]] = None,
        default_value: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        max_chars: typing.Optional[jsii.Number] = None,
        min_chars: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param allowed_pattern: (Optional) Pattern that this input value must match. Default: undefined
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_chars: (Optional) Maximum number of chars that this input value (string) must contain. Default: undefined
        :param min_chars: (Optional) Minimum number of chars that this input value (string) must contain. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__efb571e0a13d562546616b357c579bfbf498f1305753c2a8b27e36aaa20f5f3e)
            check_type(argname="argument allowed_pattern", value=allowed_pattern, expected_type=type_hints["allowed_pattern"])
            check_type(argname="argument allowed_values", value=allowed_values, expected_type=type_hints["allowed_values"])
            check_type(argname="argument default_value", value=default_value, expected_type=type_hints["default_value"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument max_chars", value=max_chars, expected_type=type_hints["max_chars"])
            check_type(argname="argument min_chars", value=min_chars, expected_type=type_hints["min_chars"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allowed_pattern is not None:
            self._values["allowed_pattern"] = allowed_pattern
        if allowed_values is not None:
            self._values["allowed_values"] = allowed_values
        if default_value is not None:
            self._values["default_value"] = default_value
        if description is not None:
            self._values["description"] = description
        if max_chars is not None:
            self._values["max_chars"] = max_chars
        if min_chars is not None:
            self._values["min_chars"] = min_chars

    @builtins.property
    def allowed_pattern(self) -> typing.Optional[builtins.str]:
        '''(Optional) Pattern that this input value must match.

        :default: undefined
        '''
        result = self._values.get("allowed_pattern")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def allowed_values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(Optional) List of allowed values that this input may be.

        :default: undefined
        '''
        result = self._values.get("allowed_values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def default_value(self) -> typing.Optional[builtins.str]:
        '''(Optional) Default value to use for this input if not specified when invoking the document.

        :default: undefined
        '''
        result = self._values.get("default_value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) The description of the input.

        :default: name
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_chars(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Maximum number of chars that this input value (string) must contain.

        :default: undefined
        '''
        result = self._values.get("max_chars")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_chars(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Minimum number of chars that this input value (string) must contain.

        :default: undefined
        '''
        result = self._values.get("min_chars")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StringInputProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.StringListInputProps",
    jsii_struct_bases=[],
    name_mapping={
        "allowed_values": "allowedValues",
        "default_value": "defaultValue",
        "description": "description",
        "max_items": "maxItems",
        "min_items": "minItems",
    },
)
class StringListInputProps:
    def __init__(
        self,
        *,
        allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
        default_value: typing.Any = None,
        description: typing.Optional[builtins.str] = None,
        max_items: typing.Optional[jsii.Number] = None,
        min_items: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_items: (Optional) Maximum number of items that this input value (list) must contain. Default: undefined
        :param min_items: (Optional) Minimum number of items that this input value (list) must contain. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__10de2b64b8adea4fbcc0ed15beac86e16c86333ffb64461ab90e7ce474419321)
            check_type(argname="argument allowed_values", value=allowed_values, expected_type=type_hints["allowed_values"])
            check_type(argname="argument default_value", value=default_value, expected_type=type_hints["default_value"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument max_items", value=max_items, expected_type=type_hints["max_items"])
            check_type(argname="argument min_items", value=min_items, expected_type=type_hints["min_items"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allowed_values is not None:
            self._values["allowed_values"] = allowed_values
        if default_value is not None:
            self._values["default_value"] = default_value
        if description is not None:
            self._values["description"] = description
        if max_items is not None:
            self._values["max_items"] = max_items
        if min_items is not None:
            self._values["min_items"] = min_items

    @builtins.property
    def allowed_values(self) -> typing.Optional[typing.List[typing.Any]]:
        '''(Optional) List of allowed values that this input may be.

        :default: undefined
        '''
        result = self._values.get("allowed_values")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    @builtins.property
    def default_value(self) -> typing.Any:
        '''(Optional) Default value to use for this input if not specified when invoking the document.

        :default: undefined
        '''
        result = self._values.get("default_value")
        return typing.cast(typing.Any, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) The description of the input.

        :default: name
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_items(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Maximum number of items that this input value (list) must contain.

        :default: undefined
        '''
        result = self._values.get("max_items")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_items(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Minimum number of items that this input value (list) must contain.

        :default: undefined
        '''
        result = self._values.get("min_items")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StringListInputProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.StringMapInputProps",
    jsii_struct_bases=[],
    name_mapping={
        "allowed_values": "allowedValues",
        "default_value": "defaultValue",
        "description": "description",
        "max_items": "maxItems",
        "min_items": "minItems",
    },
)
class StringMapInputProps:
    def __init__(
        self,
        *,
        allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
        default_value: typing.Any = None,
        description: typing.Optional[builtins.str] = None,
        max_items: typing.Optional[jsii.Number] = None,
        min_items: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param allowed_values: (Optional) List of allowed values that this input may be. Default: undefined
        :param default_value: (Optional) Default value to use for this input if not specified when invoking the document. Default: undefined
        :param description: (Optional) The description of the input. Default: name
        :param max_items: (Optional) Maximum number of items that this input value (list) must contain. Default: undefined
        :param min_items: (Optional) Minimum number of items that this input value (list) must contain. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c65a8ad77940a99976eb5d4bd4674ec6de0e377571dcdd7b546eda0d22b33ab3)
            check_type(argname="argument allowed_values", value=allowed_values, expected_type=type_hints["allowed_values"])
            check_type(argname="argument default_value", value=default_value, expected_type=type_hints["default_value"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument max_items", value=max_items, expected_type=type_hints["max_items"])
            check_type(argname="argument min_items", value=min_items, expected_type=type_hints["min_items"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allowed_values is not None:
            self._values["allowed_values"] = allowed_values
        if default_value is not None:
            self._values["default_value"] = default_value
        if description is not None:
            self._values["description"] = description
        if max_items is not None:
            self._values["max_items"] = max_items
        if min_items is not None:
            self._values["min_items"] = min_items

    @builtins.property
    def allowed_values(self) -> typing.Optional[typing.List[typing.Any]]:
        '''(Optional) List of allowed values that this input may be.

        :default: undefined
        '''
        result = self._values.get("allowed_values")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    @builtins.property
    def default_value(self) -> typing.Any:
        '''(Optional) Default value to use for this input if not specified when invoking the document.

        :default: undefined
        '''
        result = self._values.get("default_value")
        return typing.cast(typing.Any, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) The description of the input.

        :default: name
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_items(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Maximum number of items that this input value (list) must contain.

        :default: undefined
        '''
        result = self._values.get("max_items")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_items(self) -> typing.Optional[jsii.Number]:
        '''(Optional) Minimum number of items that this input value (list) must contain.

        :default: undefined
        '''
        result = self._values.get("min_items")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StringMapInputProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SynthUtils(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.SynthUtils",
):
    '''Wraps SynthUtils from @aws-cdk/assert because that package is not exported via JSII.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="synthesize")
    @builtins.classmethod
    def synthesize(
        cls,
        stack: _aws_cdk_ceddda9d.Stack,
    ) -> typing.Optional[_aws_cdk_cx_api_ceddda9d.CloudAssembly]:
        '''Wraps @aws-cdk/assert SynthUtils.synthesize(stack). Synthesizes the stack provided.

        :param stack: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f158db782493e58133e3ece33de629cea9cbd043f4a9e4a90ce551a56cb21d83)
            check_type(argname="argument stack", value=stack, expected_type=type_hints["stack"])
        return typing.cast(typing.Optional[_aws_cdk_cx_api_ceddda9d.CloudAssembly], jsii.sinvoke(cls, "synthesize", [stack]))


class UpdateVariableSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.UpdateVariableSimulation",
):
    '''AutomationStep implementation for aws:update-variable https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-update-variable.html.'''

    def __init__(self, step: "UpdateVariableStep") -> None:
        '''
        :param step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5dc5c6bb01e8e8f849db9e6989504d408cc6163e26309e0c1cfa1aeb14ed919a)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        jsii.create(self.__class__, self, [step])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        _inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param _inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1050c9a8bedf68882bba979a587ef94f110da77f0fcfeebbb32be3852f9d1918)
            check_type(argname="argument _inputs", value=_inputs, expected_type=type_hints["_inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [_inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="updateVariableStep")
    def update_variable_step(self) -> "UpdateVariableStep":
        return typing.cast("UpdateVariableStep", jsii.get(self, "updateVariableStep"))


class UsernamePasswordAuthMethod(
    AuthMethod,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.UsernamePasswordAuthMethod",
):
    def __init__(
        self,
        auth_method: builtins.str,
        user_name: SecureVariable,
        password: SecureVariable,
    ) -> None:
        '''
        :param auth_method: -
        :param user_name: -
        :param password: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e3b092fb25532e77bea8a1e1d45cb166256fb632f6e62311bf1e0f3581e136a)
            check_type(argname="argument auth_method", value=auth_method, expected_type=type_hints["auth_method"])
            check_type(argname="argument user_name", value=user_name, expected_type=type_hints["user_name"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
        jsii.create(self.__class__, self, [auth_method, user_name, password])

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="toEntry")
    def to_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toEntry", []))

    @builtins.property
    @jsii.member(jsii_name="authMethod")
    def auth_method(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "authMethod"))

    @builtins.property
    @jsii.member(jsii_name="password")
    def password(self) -> SecureVariable:
        return typing.cast(SecureVariable, jsii.get(self, "password"))

    @builtins.property
    @jsii.member(jsii_name="userName")
    def user_name(self) -> SecureVariable:
        return typing.cast(SecureVariable, jsii.get(self, "userName"))


class WaitForResourceSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.WaitForResourceSimulation",
):
    '''AutomationStep impl for aws:waitForAwsResourceProperty https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-waitForAwsResourceProperty.html.'''

    def __init__(
        self,
        step: "WaitForResourceStep",
        *,
        aws_invoker: IAwsInvoker,
        sleep_hook: ISleepHook,
    ) -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param sleep_hook: (Optional) Hook to inject alternate ISleeper (to mock the sleep between failed invocations). Default: - really perform sleep using SleeperImpl class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d558cb7f377a935a3620d2a6388f163549a56e1425668f9fd6d44e07ff4cca2f)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = WaitForResourceSimulationProps(
            aws_invoker=aws_invoker, sleep_hook=sleep_hook
        )

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''As is the case in an SSM Automation execution, this will continue to sleep/execute until desired value is found.

        This function will throw if the timeoutSeconds is exceeded and the desired value is still not received from AWS.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c46a03c61daf2fa8851ae0804f6d60ae75361ef8e123fb7f520ec138cc5eee6c)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.WaitForResourceSimulationProps",
    jsii_struct_bases=[],
    name_mapping={"aws_invoker": "awsInvoker", "sleep_hook": "sleepHook"},
)
class WaitForResourceSimulationProps:
    def __init__(self, *, aws_invoker: IAwsInvoker, sleep_hook: ISleepHook) -> None:
        '''
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        :param sleep_hook: (Optional) Hook to inject alternate ISleeper (to mock the sleep between failed invocations). Default: - really perform sleep using SleeperImpl class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45c7781236915e1f455e27c84baabf1e8b1769307a38531bcc2407d544e884b1)
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "aws_invoker": aws_invoker,
            "sleep_hook": sleep_hook,
        }

    @builtins.property
    def aws_invoker(self) -> IAwsInvoker:
        '''(Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call).

        :default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        result = self._values.get("aws_invoker")
        assert result is not None, "Required property 'aws_invoker' is missing"
        return typing.cast(IAwsInvoker, result)

    @builtins.property
    def sleep_hook(self) -> ISleepHook:
        '''(Optional) Hook to inject alternate ISleeper (to mock the sleep between failed invocations).

        :default: - really perform sleep using SleeperImpl class.
        '''
        result = self._values.get("sleep_hook")
        assert result is not None, "Required property 'sleep_hook' is missing"
        return typing.cast(ISleepHook, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WaitForResourceSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IWebhook)
class WebhookImpl(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.WebhookImpl",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="invoke")
    def invoke(
        self,
        *,
        integration_name: builtins.str,
        body: typing.Optional[builtins.str] = None,
    ) -> InvokeWebhookResult:
        '''Invoke the web hook.

        :param integration_name: The name of the Automation integration. For example, exampleIntegration. The integration you specify must already exist.
        :param body: (Optional) The payload you want to send when your webhook integration is invoked.
        '''
        _props = InvokeWebhookProps(integration_name=integration_name, body=body)

        return typing.cast(InvokeWebhookResult, jsii.invoke(self, "invoke", [_props]))


@jsii.implements(IExecuteAutomationHook)
class ApiExecuteAutomationHook(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ApiExecuteAutomationHook",
):
    '''ExecuteAutomation implementation using AWS API.'''

    def __init__(self, aws_invoker: IAwsInvoker, sleep_hook: ISleepHook) -> None:
        '''
        :param aws_invoker: -
        :param sleep_hook: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2ad6f11a7ff0a5695c8baab676ffdc34ac6ce2c7217de38d3e2097e1c0be1c9)
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
        jsii.create(self.__class__, self, [aws_invoker, sleep_hook])

    @jsii.member(jsii_name="execute")
    def execute(
        self,
        *,
        document_name: builtins.str,
        document_version: typing.Optional[builtins.str] = None,
        max_concurrency: typing.Optional[builtins.str] = None,
        max_errors: typing.Optional[builtins.str] = None,
        runtime_parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        tags: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_locations: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_maps: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
        target_parameter_name: typing.Optional[builtins.str] = None,
        targets: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
    ) -> ExecuteAutomationOutputs:
        '''Simulate the aws:executeAutomation.

        :param document_name: 
        :param document_version: 
        :param max_concurrency: 
        :param max_errors: 
        :param runtime_parameters: 
        :param tags: 
        :param target_locations: 
        :param target_maps: 
        :param target_parameter_name: 
        :param targets: 
        '''
        props = ExecuteAutomationProps(
            document_name=document_name,
            document_version=document_version,
            max_concurrency=max_concurrency,
            max_errors=max_errors,
            runtime_parameters=runtime_parameters,
            tags=tags,
            target_locations=target_locations,
            target_maps=target_maps,
            target_parameter_name=target_parameter_name,
            targets=targets,
        )

        return typing.cast(ExecuteAutomationOutputs, jsii.invoke(self, "execute", [props]))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> ApiExecuteAutomationProps:
        return typing.cast(ApiExecuteAutomationProps, jsii.get(self, "props"))


@jsii.implements(IRunCommandHook)
class ApiRunCommandHook(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ApiRunCommandHook",
):
    '''RunCommand implementation using AWS API.'''

    def __init__(self, aws_invoker: IAwsInvoker, sleep_hook: ISleepHook) -> None:
        '''
        :param aws_invoker: -
        :param sleep_hook: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__17e0001210b642eccd4650a137389225f10889a096480b9b8337af2cf0bb6a9e)
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
            check_type(argname="argument sleep_hook", value=sleep_hook, expected_type=type_hints["sleep_hook"])
        jsii.create(self.__class__, self, [aws_invoker, sleep_hook])

    @jsii.member(jsii_name="execute")
    def execute(
        self,
        *,
        document_name: builtins.str,
        targets: typing.Sequence[builtins.str],
        cloud_watch_output_config: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        comment: typing.Optional[builtins.str] = None,
        document_hash: typing.Optional[builtins.str] = None,
        document_hash_type: typing.Optional[builtins.str] = None,
        max_concurrency: typing.Optional[jsii.Number] = None,
        max_errors: typing.Optional[jsii.Number] = None,
        notification_config: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        output_s3_bucket_name: typing.Optional[builtins.str] = None,
        output_s3_key_prefix: typing.Optional[builtins.str] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        service_role_arn: typing.Optional[builtins.str] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> RunCommandOutputs:
        '''Simulate the aws:runCommand.

        :param document_name: If the Command type document is owned by you or AWS, specify the name of the document. If you're using a document shared with you by a different AWS account, specify the Amazon Resource Name (ARN) of the document.
        :param targets: The instance IDs where you want the command to run. You can specify a maximum of 50 IDs. You can also use the pseudo parameter {{ RESOURCE_ID }} in place of instance IDs to run the command on all instances in the target group. For more information about pseudo parameters, see `About pseudo parameters <https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-register-tasks-parameters.html>`_. Another alternative is to send commands to a fleet of instances by using the Targets parameter. The Targets parameter accepts Amazon Elastic Compute Cloud (Amazon EC2) tags. For more information about how to use the Targets parameter, see `Using targets and rate controls to send commands to a fleet <https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html>`_.
        :param cloud_watch_output_config: (Optional) Configuration options for sending command output to Amazon CloudWatch Logs. For more information about sending command output to CloudWatch Logs, see `Configuring Amazon CloudWatch Logs for Run Command <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-rc-setting-up-cwlogs.html>`_.
        :param comment: (Optional) User-defined information about the command.
        :param document_hash: (Optional) The hash for the document.
        :param document_hash_type: (Optional) The type of the hash.
        :param max_concurrency: (Optional) The maximum concurrency.
        :param max_errors: (Optional) The maximum errors.
        :param notification_config: (Optional) The configurations for sending notifications.
        :param output_s3_bucket_name: (Optional) The name of the S3 bucket for command output responses.
        :param output_s3_key_prefix: (Optional) The prefix.
        :param parameters: (Optional) The required and optional parameters specified in the document.
        :param service_role_arn: (Optional) The ARN of the AWS Identity and Access Management (IAM) role.
        :param timeout_seconds: (Optional) The amount of time in seconds to wait for a command to deliver to the AWS Systems Manager SSM Agent on an instance. If the command isn't received by the SSM Agent on the instance before the value specified is reached, then the status of the command changes to Delivery Timed Out.
        '''
        props = RunCommandProps(
            document_name=document_name,
            targets=targets,
            cloud_watch_output_config=cloud_watch_output_config,
            comment=comment,
            document_hash=document_hash,
            document_hash_type=document_hash_type,
            max_concurrency=max_concurrency,
            max_errors=max_errors,
            notification_config=notification_config,
            output_s3_bucket_name=output_s3_bucket_name,
            output_s3_key_prefix=output_s3_key_prefix,
            parameters=parameters,
            service_role_arn=service_role_arn,
            timeout_seconds=timeout_seconds,
        )

        return typing.cast(RunCommandOutputs, jsii.invoke(self, "execute", [props]))

    @builtins.property
    @jsii.member(jsii_name="awsInvoker")
    def aws_invoker(self) -> IAwsInvoker:
        return typing.cast(IAwsInvoker, jsii.get(self, "awsInvoker"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> ApiRunCommandProps:
        return typing.cast(ApiRunCommandProps, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="sleepHook")
    def sleep_hook(self) -> ISleepHook:
        return typing.cast(ISleepHook, jsii.get(self, "sleepHook"))


@jsii.implements(IApproveHook)
class ApproveImpl(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ApproveImpl",
):
    '''This IApproveHook implementation provides a real ask and waits for user input of Enter.

    This implementation does not work well on all exported JSII languages.
    Users can provide their own impl using the IAskHook interface.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="ask")
    def ask(self, approver: builtins.str) -> builtins.bool:
        '''Ask for approval.

        :param approver: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ccc19f2076c9ed681b6f44118e1aae7bfeb23cc58cae727a58878d215383d600)
            check_type(argname="argument approver", value=approver, expected_type=type_hints["approver"])
        return typing.cast(builtins.bool, jsii.invoke(self, "ask", [approver]))


class ApproveSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ApproveSimulation",
):
    '''AutomationStep implementation for aws:approve https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-approve.html.'''

    def __init__(self, step: "ApproveStep", *, approve_hook: IApproveHook) -> None:
        '''
        :param step: -
        :param approve_hook: (Optional) Approve hook to be called to pause the execution. To mock this implementation either inject an instance of IApproveHook or use the provided MockApprove class. Default: ApproveHook instance. ApproveHook may not work in exported JSII languages. Override interface as needed.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61def220db667a6b02cf63197776e934be316a12a70027d3965a5b81aff560db)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = ApproveSimulationProps(approve_hook=approve_hook)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''May perform a real approval ask based on the params used during instance creation.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c76072a3c8733f65e9cb260a6043f1092ceaeaf106390e5439ca0ee999be0eee)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @jsii.member(jsii_name="provideDate")
    def _provide_date(self) -> datetime.datetime:
        '''Override to mock the date the reviewer approved.'''
        return typing.cast(datetime.datetime, jsii.invoke(self, "provideDate", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="approveHook")
    def approve_hook(self) -> IApproveHook:
        return typing.cast(IApproveHook, jsii.get(self, "approveHook"))


class ArnDoc(
    DocumentSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ArnDoc",
):
    def __init__(self, arn: IStringVariable) -> None:
        '''
        :param arn: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd9a7c65c28695b830d2c6a018a40e9110af0a013cdeea3017f42f33487d1a24)
            check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
        jsii.create(self.__class__, self, [arn])

    @jsii.member(jsii_name="formatRequest")
    def format_request(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatRequest", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @builtins.property
    @jsii.member(jsii_name="arn")
    def arn(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "arn"))


class AssertAwsResourceSimulation(
    AutomationSimulationBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.AssertAwsResourceSimulation",
):
    '''AutomationStep implementation of aws:assertAwsResourceProperty.

    https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-assertAwsResourceProperty.html
    '''

    def __init__(
        self,
        step: "AssertAwsResourceStep",
        *,
        aws_invoker: IAwsInvoker,
    ) -> None:
        '''
        :param step: -
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b3c34686aa212fb340ce10adbf4828b114136d187bd6483502b73bbd254f3f8)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        props = AwsInvocationSimulationProps(aws_invoker=aws_invoker)

        jsii.create(self.__class__, self, [step, props])

    @jsii.member(jsii_name="executeStep")
    def execute_step(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''If the value found matches one of the desiredValues, then this function returns.

        Otherwise it throws.

        :param inputs: -

        :return: empty object if value matches desiredValues.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4a39dceadf79847081ba4db9f4718e48f2fda36cf13b91ec3f8c93dd61b6ee6)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "executeStep", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


class AutomationDocument(
    SsmDocument,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.AutomationDocument",
):
    '''The AutomationDocument used to both build the SSM Automation yaml/json and to use in simulation.

    The AutomationDocument will delegate execution responsibility to the AutomationSteps that it receives.
    The SsmDocument parent class contains methods to runSimulation() as well as print().
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        doc_variables: typing.Optional[typing.Sequence[Input]] = None,
        assume_role: typing.Optional[IStringVariable] = None,
        description: typing.Optional[builtins.str] = None,
        doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
        doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
        document_format: typing.Optional[DocumentFormat] = None,
        document_name: typing.Optional[builtins.str] = None,
        header: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional[builtins.str] = None,
        version_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param doc_variables: (Optional) Custom document variables.
        :param assume_role: (Optional) Assume role to use for this document. If provided, this value MUST be included as one of the documentInput names.
        :param description: (Optional) Description of the document. Defaults to the document name.
        :param doc_inputs: (Optional) Inputs required by the document.
        :param doc_outputs: (Optional) Outputs to be emitted from the document. The outputs are placed in a StringSet called outputs (as is done in SSM). Default: []
        :param document_format: (Optional) Specifies whether this document should be written as YAML or JSON. Default: JSON
        :param document_name: (Optional) Name of the document. Will default to the id provided for the CDK node.
        :param header: (Optional) A Header/comment to include at the start of a YAML document. JSON documents do not support headers.
        :param requires: ``AWS::SSM::Document.Requires``.
        :param tags: ``AWS::SSM::Document.Tags``.
        :param target_type: ``AWS::SSM::Document.TargetType``.
        :param update_method: If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced. ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version.
        :param version_name: ``AWS::SSM::Document.VersionName``.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6cb9b5a3ede1755146d415188d9d8eaa9a844c066e6c0eb1c8b4ca1dc781f4a2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AutomationDocumentProps(
            doc_variables=doc_variables,
            assume_role=assume_role,
            description=description,
            doc_inputs=doc_inputs,
            doc_outputs=doc_outputs,
            document_format=document_format,
            document_name=document_name,
            header=header,
            requires=requires,
            tags=tags,
            target_type=target_type,
            update_method=update_method,
            version_name=version_name,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addStep")
    def add_step(self, component: IAutomationComponent) -> None:
        '''
        :param component: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee93f037f1dbb7b8807c3c4a9cd849d3a977bd210f755747a8380695423a400b)
            check_type(argname="argument component", value=component, expected_type=type_hints["component"])
        return typing.cast(None, jsii.invoke(self, "addStep", [component]))

    @jsii.member(jsii_name="buildSsmDocument")
    def _build_ssm_document(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Delegates building the SSM Document to be converted to a yaml/json to the subclass (Automation etc).

        :return: an object that can be used to build the json/yaml string representation of this document.
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "buildSsmDocument", []))

    @jsii.member(jsii_name="collectedSteps")
    def collected_steps(self) -> typing.List["AutomationStep"]:
        return typing.cast(typing.List["AutomationStep"], jsii.invoke(self, "collectedSteps", []))

    @jsii.member(jsii_name="documentType")
    def document_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "documentType", []))

    @jsii.member(jsii_name="formatVariables")
    def _format_variables(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatVariables", []))

    @builtins.property
    @jsii.member(jsii_name="builder")
    def builder(self) -> AutomationDocumentBuilder:
        return typing.cast(AutomationDocumentBuilder, jsii.get(self, "builder"))

    @builtins.property
    @jsii.member(jsii_name="docVariables")
    def doc_variables(self) -> typing.Optional[typing.List[Input]]:
        return typing.cast(typing.Optional[typing.List[Input]], jsii.get(self, "docVariables"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.AutomationDocumentProps",
    jsii_struct_bases=[SsmDocumentProps],
    name_mapping={
        "assume_role": "assumeRole",
        "description": "description",
        "doc_inputs": "docInputs",
        "doc_outputs": "docOutputs",
        "document_format": "documentFormat",
        "document_name": "documentName",
        "header": "header",
        "requires": "requires",
        "tags": "tags",
        "target_type": "targetType",
        "update_method": "updateMethod",
        "version_name": "versionName",
        "doc_variables": "docVariables",
    },
)
class AutomationDocumentProps(SsmDocumentProps):
    def __init__(
        self,
        *,
        assume_role: typing.Optional[IStringVariable] = None,
        description: typing.Optional[builtins.str] = None,
        doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
        doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
        document_format: typing.Optional[DocumentFormat] = None,
        document_name: typing.Optional[builtins.str] = None,
        header: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional[builtins.str] = None,
        version_name: typing.Optional[builtins.str] = None,
        doc_variables: typing.Optional[typing.Sequence[Input]] = None,
    ) -> None:
        '''Options for AutomationDocument.

        :param assume_role: (Optional) Assume role to use for this document. If provided, this value MUST be included as one of the documentInput names.
        :param description: (Optional) Description of the document. Defaults to the document name.
        :param doc_inputs: (Optional) Inputs required by the document.
        :param doc_outputs: (Optional) Outputs to be emitted from the document. The outputs are placed in a StringSet called outputs (as is done in SSM). Default: []
        :param document_format: (Optional) Specifies whether this document should be written as YAML or JSON. Default: JSON
        :param document_name: (Optional) Name of the document. Will default to the id provided for the CDK node.
        :param header: (Optional) A Header/comment to include at the start of a YAML document. JSON documents do not support headers.
        :param requires: ``AWS::SSM::Document.Requires``.
        :param tags: ``AWS::SSM::Document.Tags``.
        :param target_type: ``AWS::SSM::Document.TargetType``.
        :param update_method: If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced. ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version.
        :param version_name: ``AWS::SSM::Document.VersionName``.
        :param doc_variables: (Optional) Custom document variables.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46391b4c7e27df83d7bec77d20338301f2d0d0b6eb89143ce3049ba678676848)
            check_type(argname="argument assume_role", value=assume_role, expected_type=type_hints["assume_role"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument doc_inputs", value=doc_inputs, expected_type=type_hints["doc_inputs"])
            check_type(argname="argument doc_outputs", value=doc_outputs, expected_type=type_hints["doc_outputs"])
            check_type(argname="argument document_format", value=document_format, expected_type=type_hints["document_format"])
            check_type(argname="argument document_name", value=document_name, expected_type=type_hints["document_name"])
            check_type(argname="argument header", value=header, expected_type=type_hints["header"])
            check_type(argname="argument requires", value=requires, expected_type=type_hints["requires"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument target_type", value=target_type, expected_type=type_hints["target_type"])
            check_type(argname="argument update_method", value=update_method, expected_type=type_hints["update_method"])
            check_type(argname="argument version_name", value=version_name, expected_type=type_hints["version_name"])
            check_type(argname="argument doc_variables", value=doc_variables, expected_type=type_hints["doc_variables"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assume_role is not None:
            self._values["assume_role"] = assume_role
        if description is not None:
            self._values["description"] = description
        if doc_inputs is not None:
            self._values["doc_inputs"] = doc_inputs
        if doc_outputs is not None:
            self._values["doc_outputs"] = doc_outputs
        if document_format is not None:
            self._values["document_format"] = document_format
        if document_name is not None:
            self._values["document_name"] = document_name
        if header is not None:
            self._values["header"] = header
        if requires is not None:
            self._values["requires"] = requires
        if tags is not None:
            self._values["tags"] = tags
        if target_type is not None:
            self._values["target_type"] = target_type
        if update_method is not None:
            self._values["update_method"] = update_method
        if version_name is not None:
            self._values["version_name"] = version_name
        if doc_variables is not None:
            self._values["doc_variables"] = doc_variables

    @builtins.property
    def assume_role(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Assume role to use for this document.

        If provided, this value MUST be included as one of the documentInput names.
        '''
        result = self._values.get("assume_role")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) Description of the document.

        Defaults to the document name.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def doc_inputs(self) -> typing.Optional[typing.List[Input]]:
        '''(Optional) Inputs required by the document.'''
        result = self._values.get("doc_inputs")
        return typing.cast(typing.Optional[typing.List[Input]], result)

    @builtins.property
    def doc_outputs(self) -> typing.Optional[typing.List[DocumentOutput]]:
        '''(Optional) Outputs to be emitted from the document.

        The outputs are placed in a StringSet called outputs (as is done in SSM).

        :default: []
        '''
        result = self._values.get("doc_outputs")
        return typing.cast(typing.Optional[typing.List[DocumentOutput]], result)

    @builtins.property
    def document_format(self) -> typing.Optional[DocumentFormat]:
        '''(Optional) Specifies whether this document should be written as YAML or JSON.

        :default: JSON
        '''
        result = self._values.get("document_format")
        return typing.cast(typing.Optional[DocumentFormat], result)

    @builtins.property
    def document_name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the document.

        Will default to the id provided for the CDK node.
        '''
        result = self._values.get("document_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def header(self) -> typing.Optional[builtins.str]:
        '''(Optional) A Header/comment to include at the start of a YAML document.

        JSON documents do not support headers.
        '''
        result = self._values.get("header")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def requires(
        self,
    ) -> typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.List[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, _aws_cdk_ceddda9d.IResolvable]]]]:
        '''``AWS::SSM::Document.Requires``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-requires
        '''
        result = self._values.get("requires")
        return typing.cast(typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.List[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, _aws_cdk_ceddda9d.IResolvable]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_aws_cdk_ceddda9d.CfnTag]]:
        '''``AWS::SSM::Document.Tags``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_ceddda9d.CfnTag]], result)

    @builtins.property
    def target_type(self) -> typing.Optional[builtins.str]:
        '''``AWS::SSM::Document.TargetType``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-targettype
        '''
        result = self._values.get("target_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update_method(self) -> typing.Optional[builtins.str]:
        '''If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced.

        ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-updatemethod
        '''
        result = self._values.get("update_method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version_name(self) -> typing.Optional[builtins.str]:
        '''``AWS::SSM::Document.VersionName``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-versionname
        '''
        result = self._values.get("version_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def doc_variables(self) -> typing.Optional[typing.List[Input]]:
        '''(Optional) Custom document variables.'''
        result = self._values.get("doc_variables")
        return typing.cast(typing.Optional[typing.List[Input]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutomationDocumentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IAutomationComponent)
class AutomationStep(
    Step,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.AutomationStep",
):
    '''Parent class for AutomationSteps.

    These steps are using in an AutomationDocument.
    You can instantiate steps using the AutomationBuilder for convenience.
    You can use these steps to simulate their execution (mimics the SSM run) AND to build their yaml/json declaration.
    Control flow of the subsequent step is determined by the currently executing step.
    The flow of the execution therefore follows a chain-of-responsibility pattern.
    The inputs received into a step AND the outputs of previous steps are merged to form inputs of subsequent steps.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7992865847ac10ea71c720c2fc326ee0a6cafee2e57562ea13b167fc4d7f9685)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AutomationStepProps(
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addToDocument")
    def add_to_document(self, doc: AutomationDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d639efe1227fc4fb94130fa7ec73aa07f4046d03c8c6a8abfcbd07a5ccf9803c)
            check_type(argname="argument doc", value=doc, expected_type=type_hints["doc"])
        return typing.cast(None, jsii.invoke(self, "addToDocument", [doc]))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="listUserOutputs")
    def list_user_outputs(self) -> typing.List[Output]:
        '''Lists the outputs defined by the user for this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listUserOutputs", []))

    @jsii.member(jsii_name="prepareSsmEntry")
    def _prepare_ssm_entry(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c25be20b59ce5714aa8bb145b6ad6ed0325a709c02e045748a809c54e924da86)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "prepareSsmEntry", [inputs]))

    @jsii.member(jsii_name="variables")
    def variables(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "variables", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DEFAULT_MAX_ATTEMPTS")
    def DEFAULT_MAX_ATTEMPTS(cls) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.sget(cls, "DEFAULT_MAX_ATTEMPTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DEFAULT_TIMEOUT")
    def DEFAULT_TIMEOUT(cls) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.sget(cls, "DEFAULT_TIMEOUT"))

    @builtins.property
    @jsii.member(jsii_name="isEnd")
    def is_end(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "isEnd"))

    @builtins.property
    @jsii.member(jsii_name="maxAttempts")
    def max_attempts(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxAttempts"))

    @builtins.property
    @jsii.member(jsii_name="onCancel")
    def on_cancel(self) -> "OnCancel":
        return typing.cast("OnCancel", jsii.get(self, "onCancel"))

    @builtins.property
    @jsii.member(jsii_name="onFailure")
    def on_failure(self) -> OnFailure:
        return typing.cast(OnFailure, jsii.get(self, "onFailure"))

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "timeoutSeconds"))

    @builtins.property
    @jsii.member(jsii_name="explicitNextStep")
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        return typing.cast(typing.Optional[StepRef], jsii.get(self, "explicitNextStep"))

    @builtins.property
    @jsii.member(jsii_name="userOutputs")
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        return typing.cast(typing.Optional[typing.List[Output]], jsii.get(self, "userOutputs"))

    @builtins.property
    @jsii.member(jsii_name="allStepsInExecution")
    def all_steps_in_execution(self) -> typing.Optional[typing.List["AutomationStep"]]:
        return typing.cast(typing.Optional[typing.List["AutomationStep"]], jsii.get(self, "allStepsInExecution"))

    @all_steps_in_execution.setter
    def all_steps_in_execution(
        self,
        value: typing.Optional[typing.List["AutomationStep"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f14ae60dc0fc969e7920bf4663b059d5edad49ff0423d1e35ab3b0094b787aff)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allStepsInExecution", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nextStep")
    def next_step(self) -> typing.Optional["AutomationStep"]:
        return typing.cast(typing.Optional["AutomationStep"], jsii.get(self, "nextStep"))

    @next_step.setter
    def next_step(self, value: typing.Optional["AutomationStep"]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54e821c195133416e2803d57302081e8ce7fc9454719c8f08d552ed027111f2e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nextStep", value) # pyright: ignore[reportArgumentType]


class _AutomationStepProxy(
    AutomationStep,
    jsii.proxy_for(Step), # type: ignore[misc]
):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, AutomationStep).__jsii_proxy_class__ = lambda : _AutomationStepProxy


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.AutomationStepProps",
    jsii_struct_bases=[StepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
    },
)
class AutomationStepProps(StepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd5ae5e2ad458039f35c558280700e56831a3904f574b77a7ee64f6eab6dbd2e)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutomationStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AwsApiStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.AwsApiStep",
):
    '''AutomationStep implementation of aws:executeAwsApi.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        outputs: typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]],
        api_params: typing.Mapping[builtins.str, typing.Any],
        pascal_case_api: builtins.str,
        service: AwsService,
        java_script_api: typing.Optional[builtins.str] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param outputs: (Required) specify the outputs to extract from the JavaScript JSON response.
        :param api_params: (Required) API Params to submit with the request to the api. You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}
        :param pascal_case_api: (Required) The AWS api represented in PascalCase. This value is used as-is in the SSM yaml/json. This is used as the default for javaScriptApi (see that param).
        :param service: (Required) The AWS service to be invoked.
        :param java_script_api: (Optional) The api as represented the AWS JavaScript API. This is usually lowerCamelCase. This is used in the simulation run to execute the AWS API against the JavaScript SDK. Default: - will use the camelCaseApi param and substitute the first character for lowercase by default.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a85a8981fa1aadf64f69dcb32c6a32470424d51d10842ed1935b17032897fbaa)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AwsApiStepProps(
            outputs=outputs,
            api_params=api_params,
            pascal_case_api=pascal_case_api,
            service=service,
            java_script_api=java_script_api,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Derives the inputs by parsing the apiParams to find matches for inputs in double circle braces ("{{ INPUT }}").

        :return: list of required inputs.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listUserOutputs")
    def list_user_outputs(self) -> typing.List[Output]:
        '''Lists the outputs defined by the user for this step.

        :return: Outputs as specified in params
        '''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listUserOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="apiParams")
    def api_params(self) -> "DictFormat":
        return typing.cast("DictFormat", jsii.get(self, "apiParams"))

    @builtins.property
    @jsii.member(jsii_name="javaScriptApi")
    def java_script_api(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "javaScriptApi"))

    @builtins.property
    @jsii.member(jsii_name="outputs")
    def outputs(self) -> typing.List[Output]:
        return typing.cast(typing.List[Output], jsii.get(self, "outputs"))

    @builtins.property
    @jsii.member(jsii_name="pascalCaseApi")
    def pascal_case_api(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "pascalCaseApi"))

    @builtins.property
    @jsii.member(jsii_name="service")
    def service(self) -> AwsService:
        return typing.cast(AwsService, jsii.get(self, "service"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.AwsInvocationProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "api_params": "apiParams",
        "pascal_case_api": "pascalCaseApi",
        "service": "service",
        "java_script_api": "javaScriptApi",
    },
)
class AwsInvocationProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        api_params: typing.Mapping[builtins.str, typing.Any],
        pascal_case_api: builtins.str,
        service: AwsService,
        java_script_api: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param api_params: (Required) API Params to submit with the request to the api. You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}
        :param pascal_case_api: (Required) The AWS api represented in PascalCase. This value is used as-is in the SSM yaml/json. This is used as the default for javaScriptApi (see that param).
        :param service: (Required) The AWS service to be invoked.
        :param java_script_api: (Optional) The api as represented the AWS JavaScript API. This is usually lowerCamelCase. This is used in the simulation run to execute the AWS API against the JavaScript SDK. Default: - will use the camelCaseApi param and substitute the first character for lowercase by default.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b925c698875296ff2de682c5a20f4da7714a6bda6e5e46e1ae9c5021c998304)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument api_params", value=api_params, expected_type=type_hints["api_params"])
            check_type(argname="argument pascal_case_api", value=pascal_case_api, expected_type=type_hints["pascal_case_api"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument java_script_api", value=java_script_api, expected_type=type_hints["java_script_api"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_params": api_params,
            "pascal_case_api": pascal_case_api,
            "service": service,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if java_script_api is not None:
            self._values["java_script_api"] = java_script_api

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def api_params(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''(Required) API Params to submit with the request to the api.

        You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}

        Example::

            { 'VolumeIds': ['{{ EbsDescribeInstance.VolumeId }}'] }
        '''
        result = self._values.get("api_params")
        assert result is not None, "Required property 'api_params' is missing"
        return typing.cast(typing.Mapping[builtins.str, typing.Any], result)

    @builtins.property
    def pascal_case_api(self) -> builtins.str:
        '''(Required) The AWS api represented in PascalCase.

        This value is used as-is in the SSM yaml/json.
        This is used as the default for javaScriptApi (see that param).

        Example::

            DescribeInstances
        '''
        result = self._values.get("pascal_case_api")
        assert result is not None, "Required property 'pascal_case_api' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> AwsService:
        '''(Required) The AWS service to be invoked.

        Example::

            AwsService.S3
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(AwsService, result)

    @builtins.property
    def java_script_api(self) -> typing.Optional[builtins.str]:
        '''(Optional) The api as represented the AWS JavaScript API.

        This is usually lowerCamelCase.
        This is used in the simulation run to execute the AWS API against the JavaScript SDK.

        :default: - will use the camelCaseApi param and substitute the first character for lowercase by default.

        Example::

            describeInstances
        '''
        result = self._values.get("java_script_api")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AwsInvocationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BranchStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.BranchStep",
):
    '''AutomationStep implementation of aws:branch https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-branch.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        choices: typing.Sequence[Choice],
        default_step_name: typing.Optional[builtins.str] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param choices: (Required) list of choices. The first matched choice will be used to jump to the step specified in the choice.
        :param default_step_name: (Optional) default step in all of the choices evaluate to false. Default: undefined - the next step in the chain will be invoked. See AWS Documentation for branch below.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30592f3faa79304516d2422e0c68eacaaf835b91e7fc299e54aaf274c49665c5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = BranchStepProps(
            choices=choices,
            default_step_name=default_step_name,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.

        :return: all of the inputsToTest from the choices provided to the constructor
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''There is no output from branch steps.

        :return: empty list
        '''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="choices")
    def choices(self) -> typing.List[Choice]:
        return typing.cast(typing.List[Choice], jsii.get(self, "choices"))

    @builtins.property
    @jsii.member(jsii_name="defaultStepName")
    def default_step_name(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultStepName"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.BranchStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "choices": "choices",
        "default_step_name": "defaultStepName",
    },
)
class BranchStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        choices: typing.Sequence[Choice],
        default_step_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param choices: (Required) list of choices. The first matched choice will be used to jump to the step specified in the choice.
        :param default_step_name: (Optional) default step in all of the choices evaluate to false. Default: undefined - the next step in the chain will be invoked. See AWS Documentation for branch below.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4e1a9a60f92e4305ce1ded21b258e57a4445102c1f64e061854ed26f7a3c233)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument choices", value=choices, expected_type=type_hints["choices"])
            check_type(argname="argument default_step_name", value=default_step_name, expected_type=type_hints["default_step_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "choices": choices,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if default_step_name is not None:
            self._values["default_step_name"] = default_step_name

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def choices(self) -> typing.List[Choice]:
        '''(Required) list of choices.

        The first matched choice will be used to jump to the step specified in the choice.
        '''
        result = self._values.get("choices")
        assert result is not None, "Required property 'choices' is missing"
        return typing.cast(typing.List[Choice], result)

    @builtins.property
    def default_step_name(self) -> typing.Optional[builtins.str]:
        '''(Optional) default step in all of the choices evaluate to false.

        :default: undefined - the next step in the chain will be invoked. See AWS Documentation for branch below.
        '''
        result = self._values.get("default_step_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BranchStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ChangeInstanceStateSimulationProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "aws_invoker": "awsInvoker",
    },
)
class ChangeInstanceStateSimulationProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        aws_invoker: IAwsInvoker,
    ) -> None:
        '''Properties for ChangeInstanceStateStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param aws_invoker: (Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call). Default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b3007f7f72116e2c901ec5d8aa91c9c0a821ce711f8a35a3336a98a946c18c4)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument aws_invoker", value=aws_invoker, expected_type=type_hints["aws_invoker"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "aws_invoker": aws_invoker,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def aws_invoker(self) -> IAwsInvoker:
        '''(Optional) Use this as a hook to inject an alternate IAwsInvoker (for mocking the AWS API call).

        :default: - will perform a real invocation of the JavaScript AWS SDK using ReflectiveAwsInvoker class.
        '''
        result = self._values.get("aws_invoker")
        assert result is not None, "Required property 'aws_invoker' is missing"
        return typing.cast(IAwsInvoker, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ChangeInstanceStateSimulationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ChangeInstanceStateStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ChangeInstanceStateStep",
):
    '''AutomationStep implemenation for aws:changeInstanceState https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-changestate.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        desired_state: "IDesiredStateVariable",
        instance_ids: IStringListVariable,
        additional_info: typing.Optional[IStringVariable] = None,
        check_state_only: typing.Optional["IBooleanVariable"] = None,
        force: typing.Optional["IBooleanVariable"] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param desired_state: The desired state. When set to running, this action waits for the Amazon EC2 state to be Running, the Instance Status to be OK, and the System Status to be OK before completing.
        :param instance_ids: The IDs of the instances.
        :param additional_info: (Optional) Reserved.
        :param check_state_only: (Optional) If false, sets the instance state to the desired state. If true, asserts the desired state using polling. Default: false
        :param force: (Optional) If set, forces the instances to stop. The instances don't have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures. This option isn't recommended for EC2 instances for Windows Server.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad87032e9de062f3fe2f0b0fb7c54a88461d6e8a3b81871059d03c607682b531)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ChangeInstanceStateStepProps(
            desired_state=desired_state,
            instance_ids=instance_ids,
            additional_info=additional_info,
            check_state_only=check_state_only,
            force=force,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''This step has no outputs.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="desiredState")
    def desired_state(self) -> "IDesiredStateVariable":
        return typing.cast("IDesiredStateVariable", jsii.get(self, "desiredState"))

    @builtins.property
    @jsii.member(jsii_name="instanceIds")
    def instance_ids(self) -> IStringListVariable:
        return typing.cast(IStringListVariable, jsii.get(self, "instanceIds"))

    @builtins.property
    @jsii.member(jsii_name="additionalInfo")
    def additional_info(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "additionalInfo"))

    @builtins.property
    @jsii.member(jsii_name="checkStateOnly")
    def check_state_only(self) -> typing.Optional["IBooleanVariable"]:
        return typing.cast(typing.Optional["IBooleanVariable"], jsii.get(self, "checkStateOnly"))

    @builtins.property
    @jsii.member(jsii_name="force")
    def force(self) -> typing.Optional["IBooleanVariable"]:
        return typing.cast(typing.Optional["IBooleanVariable"], jsii.get(self, "force"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ChangeInstanceStateStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "desired_state": "desiredState",
        "instance_ids": "instanceIds",
        "additional_info": "additionalInfo",
        "check_state_only": "checkStateOnly",
        "force": "force",
    },
)
class ChangeInstanceStateStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        desired_state: "IDesiredStateVariable",
        instance_ids: IStringListVariable,
        additional_info: typing.Optional[IStringVariable] = None,
        check_state_only: typing.Optional["IBooleanVariable"] = None,
        force: typing.Optional["IBooleanVariable"] = None,
    ) -> None:
        '''Properties for ChangeInstanceStateStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param desired_state: The desired state. When set to running, this action waits for the Amazon EC2 state to be Running, the Instance Status to be OK, and the System Status to be OK before completing.
        :param instance_ids: The IDs of the instances.
        :param additional_info: (Optional) Reserved.
        :param check_state_only: (Optional) If false, sets the instance state to the desired state. If true, asserts the desired state using polling. Default: false
        :param force: (Optional) If set, forces the instances to stop. The instances don't have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures. This option isn't recommended for EC2 instances for Windows Server.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27f8f7a0ec98801b1a6e982daaaed58e732dcd75e694cafb2ec751d4d5cf06f4)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument desired_state", value=desired_state, expected_type=type_hints["desired_state"])
            check_type(argname="argument instance_ids", value=instance_ids, expected_type=type_hints["instance_ids"])
            check_type(argname="argument additional_info", value=additional_info, expected_type=type_hints["additional_info"])
            check_type(argname="argument check_state_only", value=check_state_only, expected_type=type_hints["check_state_only"])
            check_type(argname="argument force", value=force, expected_type=type_hints["force"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "desired_state": desired_state,
            "instance_ids": instance_ids,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if additional_info is not None:
            self._values["additional_info"] = additional_info
        if check_state_only is not None:
            self._values["check_state_only"] = check_state_only
        if force is not None:
            self._values["force"] = force

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def desired_state(self) -> "IDesiredStateVariable":
        '''The desired state.

        When set to running, this action waits for the Amazon EC2 state to be Running, the Instance Status to be OK,
        and the System Status to be OK before completing.
        '''
        result = self._values.get("desired_state")
        assert result is not None, "Required property 'desired_state' is missing"
        return typing.cast("IDesiredStateVariable", result)

    @builtins.property
    def instance_ids(self) -> IStringListVariable:
        '''The IDs of the instances.'''
        result = self._values.get("instance_ids")
        assert result is not None, "Required property 'instance_ids' is missing"
        return typing.cast(IStringListVariable, result)

    @builtins.property
    def additional_info(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Reserved.'''
        result = self._values.get("additional_info")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def check_state_only(self) -> typing.Optional["IBooleanVariable"]:
        '''(Optional) If false, sets the instance state to the desired state.

        If true, asserts the desired state using polling.

        :default: false
        '''
        result = self._values.get("check_state_only")
        return typing.cast(typing.Optional["IBooleanVariable"], result)

    @builtins.property
    def force(self) -> typing.Optional["IBooleanVariable"]:
        '''(Optional) If set, forces the instances to stop.

        The instances don't have an opportunity to flush file system caches or file system metadata.
        If you use this option, you must perform file system check and repair procedures.
        This option isn't recommended for EC2 instances for Windows Server.
        '''
        result = self._values.get("force")
        return typing.cast(typing.Optional["IBooleanVariable"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ChangeInstanceStateStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CommandDocument(
    SsmDocument,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CommandDocument",
):
    '''https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html The CommandDocument will delegate execution responsibility to the CammandSteps that it receives. The SsmDocument parent class contains methods to runSimulation() as well as print().'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        assume_role: typing.Optional[IStringVariable] = None,
        description: typing.Optional[builtins.str] = None,
        doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
        doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
        document_format: typing.Optional[DocumentFormat] = None,
        document_name: typing.Optional[builtins.str] = None,
        header: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional[builtins.str] = None,
        version_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param assume_role: (Optional) Assume role to use for this document. If provided, this value MUST be included as one of the documentInput names.
        :param description: (Optional) Description of the document. Defaults to the document name.
        :param doc_inputs: (Optional) Inputs required by the document.
        :param doc_outputs: (Optional) Outputs to be emitted from the document. The outputs are placed in a StringSet called outputs (as is done in SSM). Default: []
        :param document_format: (Optional) Specifies whether this document should be written as YAML or JSON. Default: JSON
        :param document_name: (Optional) Name of the document. Will default to the id provided for the CDK node.
        :param header: (Optional) A Header/comment to include at the start of a YAML document. JSON documents do not support headers.
        :param requires: ``AWS::SSM::Document.Requires``.
        :param tags: ``AWS::SSM::Document.Tags``.
        :param target_type: ``AWS::SSM::Document.TargetType``.
        :param update_method: If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced. ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version.
        :param version_name: ``AWS::SSM::Document.VersionName``.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a7b11d6e831c32a664c6bf82ac018aeb7cebd4549cb77841c58186c6ea8a730a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CommandDocumentProps(
            assume_role=assume_role,
            description=description,
            doc_inputs=doc_inputs,
            doc_outputs=doc_outputs,
            document_format=document_format,
            document_name=document_name,
            header=header,
            requires=requires,
            tags=tags,
            target_type=target_type,
            update_method=update_method,
            version_name=version_name,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addStep")
    def add_step(self, component: ICommandComponent) -> None:
        '''
        :param component: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b2eb45f67ce9c873fc8ab6f172036c146cef2cf9a0243d36126cfed4578991e)
            check_type(argname="argument component", value=component, expected_type=type_hints["component"])
        return typing.cast(None, jsii.invoke(self, "addStep", [component]))

    @jsii.member(jsii_name="buildSsmDocument")
    def _build_ssm_document(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Delegates building the SSM Document to be converted to a yaml/json to the subclass (Automation etc).'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "buildSsmDocument", []))

    @jsii.member(jsii_name="collectedSteps")
    def collected_steps(self) -> typing.List["CommandStep"]:
        return typing.cast(typing.List["CommandStep"], jsii.invoke(self, "collectedSteps", []))

    @jsii.member(jsii_name="documentType")
    def document_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "documentType", []))

    @builtins.property
    @jsii.member(jsii_name="builder")
    def builder(self) -> CommandDocumentBuilder:
        return typing.cast(CommandDocumentBuilder, jsii.get(self, "builder"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.CommandDocumentProps",
    jsii_struct_bases=[SsmDocumentProps],
    name_mapping={
        "assume_role": "assumeRole",
        "description": "description",
        "doc_inputs": "docInputs",
        "doc_outputs": "docOutputs",
        "document_format": "documentFormat",
        "document_name": "documentName",
        "header": "header",
        "requires": "requires",
        "tags": "tags",
        "target_type": "targetType",
        "update_method": "updateMethod",
        "version_name": "versionName",
    },
)
class CommandDocumentProps(SsmDocumentProps):
    def __init__(
        self,
        *,
        assume_role: typing.Optional[IStringVariable] = None,
        description: typing.Optional[builtins.str] = None,
        doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
        doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
        document_format: typing.Optional[DocumentFormat] = None,
        document_name: typing.Optional[builtins.str] = None,
        header: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional[builtins.str] = None,
        version_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param assume_role: (Optional) Assume role to use for this document. If provided, this value MUST be included as one of the documentInput names.
        :param description: (Optional) Description of the document. Defaults to the document name.
        :param doc_inputs: (Optional) Inputs required by the document.
        :param doc_outputs: (Optional) Outputs to be emitted from the document. The outputs are placed in a StringSet called outputs (as is done in SSM). Default: []
        :param document_format: (Optional) Specifies whether this document should be written as YAML or JSON. Default: JSON
        :param document_name: (Optional) Name of the document. Will default to the id provided for the CDK node.
        :param header: (Optional) A Header/comment to include at the start of a YAML document. JSON documents do not support headers.
        :param requires: ``AWS::SSM::Document.Requires``.
        :param tags: ``AWS::SSM::Document.Tags``.
        :param target_type: ``AWS::SSM::Document.TargetType``.
        :param update_method: If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced. ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version.
        :param version_name: ``AWS::SSM::Document.VersionName``.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f9235ffee63f7b4ee7b3d360942c6e683e349a4f2e4702da8886a65978cec8e)
            check_type(argname="argument assume_role", value=assume_role, expected_type=type_hints["assume_role"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument doc_inputs", value=doc_inputs, expected_type=type_hints["doc_inputs"])
            check_type(argname="argument doc_outputs", value=doc_outputs, expected_type=type_hints["doc_outputs"])
            check_type(argname="argument document_format", value=document_format, expected_type=type_hints["document_format"])
            check_type(argname="argument document_name", value=document_name, expected_type=type_hints["document_name"])
            check_type(argname="argument header", value=header, expected_type=type_hints["header"])
            check_type(argname="argument requires", value=requires, expected_type=type_hints["requires"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument target_type", value=target_type, expected_type=type_hints["target_type"])
            check_type(argname="argument update_method", value=update_method, expected_type=type_hints["update_method"])
            check_type(argname="argument version_name", value=version_name, expected_type=type_hints["version_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assume_role is not None:
            self._values["assume_role"] = assume_role
        if description is not None:
            self._values["description"] = description
        if doc_inputs is not None:
            self._values["doc_inputs"] = doc_inputs
        if doc_outputs is not None:
            self._values["doc_outputs"] = doc_outputs
        if document_format is not None:
            self._values["document_format"] = document_format
        if document_name is not None:
            self._values["document_name"] = document_name
        if header is not None:
            self._values["header"] = header
        if requires is not None:
            self._values["requires"] = requires
        if tags is not None:
            self._values["tags"] = tags
        if target_type is not None:
            self._values["target_type"] = target_type
        if update_method is not None:
            self._values["update_method"] = update_method
        if version_name is not None:
            self._values["version_name"] = version_name

    @builtins.property
    def assume_role(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Assume role to use for this document.

        If provided, this value MUST be included as one of the documentInput names.
        '''
        result = self._values.get("assume_role")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) Description of the document.

        Defaults to the document name.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def doc_inputs(self) -> typing.Optional[typing.List[Input]]:
        '''(Optional) Inputs required by the document.'''
        result = self._values.get("doc_inputs")
        return typing.cast(typing.Optional[typing.List[Input]], result)

    @builtins.property
    def doc_outputs(self) -> typing.Optional[typing.List[DocumentOutput]]:
        '''(Optional) Outputs to be emitted from the document.

        The outputs are placed in a StringSet called outputs (as is done in SSM).

        :default: []
        '''
        result = self._values.get("doc_outputs")
        return typing.cast(typing.Optional[typing.List[DocumentOutput]], result)

    @builtins.property
    def document_format(self) -> typing.Optional[DocumentFormat]:
        '''(Optional) Specifies whether this document should be written as YAML or JSON.

        :default: JSON
        '''
        result = self._values.get("document_format")
        return typing.cast(typing.Optional[DocumentFormat], result)

    @builtins.property
    def document_name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the document.

        Will default to the id provided for the CDK node.
        '''
        result = self._values.get("document_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def header(self) -> typing.Optional[builtins.str]:
        '''(Optional) A Header/comment to include at the start of a YAML document.

        JSON documents do not support headers.
        '''
        result = self._values.get("header")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def requires(
        self,
    ) -> typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.List[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, _aws_cdk_ceddda9d.IResolvable]]]]:
        '''``AWS::SSM::Document.Requires``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-requires
        '''
        result = self._values.get("requires")
        return typing.cast(typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.List[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, _aws_cdk_ceddda9d.IResolvable]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_aws_cdk_ceddda9d.CfnTag]]:
        '''``AWS::SSM::Document.Tags``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_ceddda9d.CfnTag]], result)

    @builtins.property
    def target_type(self) -> typing.Optional[builtins.str]:
        '''``AWS::SSM::Document.TargetType``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-targettype
        '''
        result = self._values.get("target_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update_method(self) -> typing.Optional[builtins.str]:
        '''If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced.

        ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-updatemethod
        '''
        result = self._values.get("update_method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version_name(self) -> typing.Optional[builtins.str]:
        '''``AWS::SSM::Document.VersionName``.

        :external: true
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html#cfn-ssm-document-versionname
        '''
        result = self._values.get("version_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CommandDocumentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(ICommandComponent)
class CommandStep(
    Step,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.CommandStep",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23a8a2cc71aa02166e1aa70e9556b2637410af278733c3c498122e6a3d3f47b4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CommandStepProps(
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addToDocument")
    def add_to_document(self, doc: CommandDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b114a3810c0d8a38abfa9510436e3b1a2611af4b75df371b6c43507c9c61a8c)
            check_type(argname="argument doc", value=doc, expected_type=type_hints["doc"])
        return typing.cast(None, jsii.invoke(self, "addToDocument", [doc]))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''RunCommand Steps do not have outputs.

        :return: []
        '''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="prepareSsmEntry")
    def _prepare_ssm_entry(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfbd788e4adc67c6675b4da341b20a0323921aa2fe290ca934519e7ec965444a)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "prepareSsmEntry", [inputs]))

    @jsii.member(jsii_name="variables")
    def variables(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "variables", []))

    @builtins.property
    @jsii.member(jsii_name="exitOnFailure")
    def exit_on_failure(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "exitOnFailure"))

    @builtins.property
    @jsii.member(jsii_name="exitOnSuccess")
    def exit_on_success(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "exitOnSuccess"))

    @builtins.property
    @jsii.member(jsii_name="finallyStep")
    def finally_step(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "finallyStep"))

    @builtins.property
    @jsii.member(jsii_name="markSuccessAndExitOnFailure")
    def mark_success_and_exit_on_failure(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "markSuccessAndExitOnFailure"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    @abc.abstractmethod
    def platforms(self) -> typing.List[Platform]:
        ...

    @builtins.property
    @jsii.member(jsii_name="precondition")
    def precondition(self) -> typing.Optional[Precondition]:
        return typing.cast(typing.Optional[Precondition], jsii.get(self, "precondition"))

    @builtins.property
    @jsii.member(jsii_name="allStepsInExecution")
    def all_steps_in_execution(self) -> typing.Optional[typing.List["CommandStep"]]:
        return typing.cast(typing.Optional[typing.List["CommandStep"]], jsii.get(self, "allStepsInExecution"))

    @all_steps_in_execution.setter
    def all_steps_in_execution(
        self,
        value: typing.Optional[typing.List["CommandStep"]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89ae80bbdd8175616876b46c91577850d2e6d0e540b94738974d399146222dd4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "allStepsInExecution", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="nextStep")
    def next_step(self) -> typing.Optional["CommandStep"]:
        return typing.cast(typing.Optional["CommandStep"], jsii.get(self, "nextStep"))

    @next_step.setter
    def next_step(self, value: typing.Optional["CommandStep"]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a08a6fa8fad98b5461b43d5c0a9284960480b03ebec5bf86017a631e0fa462c7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "nextStep", value) # pyright: ignore[reportArgumentType]


class _CommandStepProxy(
    CommandStep,
    jsii.proxy_for(Step), # type: ignore[misc]
):
    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, CommandStep).__jsii_proxy_class__ = lambda : _CommandStepProxy


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.CommandStepProps",
    jsii_struct_bases=[StepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
    },
)
class CommandStepProps(StepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
    ) -> None:
        '''
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0fad36300f8370653d919e8469301c36c61a6575dc07745260cc1819cbf434f)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CommandStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IAutomationComponent)
class CompositeAutomationStep(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.CompositeAutomationStep",
):
    def __init__(self, scope: _constructs_77d1e7e8.Construct, id: builtins.str) -> None:
        '''
        :param scope: -
        :param id: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c888f774487adb962b675782ec8e9968e62b25e66451c9a3939104746b84f98)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        jsii.create(self.__class__, self, [scope, id])

    @jsii.member(jsii_name="addToDocument")
    @abc.abstractmethod
    def add_to_document(self, doc: AutomationDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        ...


class _CompositeAutomationStepProxy(CompositeAutomationStep):
    @jsii.member(jsii_name="addToDocument")
    def add_to_document(self, doc: AutomationDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52206c901f0b19df1344121d460384f28bfd0569fb8c729103803b924d9f51cf)
            check_type(argname="argument doc", value=doc, expected_type=type_hints["doc"])
        return typing.cast(None, jsii.invoke(self, "addToDocument", [doc]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, CompositeAutomationStep).__jsii_proxy_class__ = lambda : _CompositeAutomationStepProxy


@jsii.implements(ICommandComponent)
class CompositeCommandStep(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.CompositeCommandStep",
):
    def __init__(self, scope: _constructs_77d1e7e8.Construct, id: builtins.str) -> None:
        '''
        :param scope: -
        :param id: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22ccf13ab7a7e56952367399a9b44feea5832519610172abe1036e1e078c2e7a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        jsii.create(self.__class__, self, [scope, id])

    @jsii.member(jsii_name="addToDocument")
    @abc.abstractmethod
    def add_to_document(self, doc: CommandDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        ...


class _CompositeCommandStepProxy(CompositeCommandStep):
    @jsii.member(jsii_name="addToDocument")
    def add_to_document(self, doc: CommandDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e329deb689b679c55bcafd49df4329152480c442e2d51836c571f3e296d195a)
            check_type(argname="argument doc", value=doc, expected_type=type_hints["doc"])
        return typing.cast(None, jsii.invoke(self, "addToDocument", [doc]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, CompositeCommandStep).__jsii_proxy_class__ = lambda : _CompositeCommandStepProxy


class ConfigureDockerStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ConfigureDockerStep",
):
    '''AutomationStep implemenation for aws:UpdateAgent https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-configuredocker.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        action: "IActionVariable",
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param action: The type of action to perform. True correlates to "Install" false correlates to "Uninstall"
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e73df770d7e83302d8c2cee40111719342403375f32807782449b7e7c60f7220)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ConfigureDockerStepProps(
            action=action,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Inputs required for this command include agentName allowDowngrade source and targetVersion if version other than latest is desired.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="installAction")
    def install_action(self) -> "IActionVariable":
        return typing.cast("IActionVariable", jsii.get(self, "installAction"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ConfigureDockerStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "action": "action",
    },
)
class ConfigureDockerStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        action: "IActionVariable",
    ) -> None:
        '''Properties for ConfigureDocker step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param action: The type of action to perform. True correlates to "Install" false correlates to "Uninstall"
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61c175d2bd563b3d76a69396e8002b2c736b68c33796ee1bcf4e9f034a80cfef)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "action": action,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def action(self) -> "IActionVariable":
        '''The type of action to perform.

        True correlates to "Install" false correlates to "Uninstall"
        '''
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast("IActionVariable", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConfigureDockerStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ConfigurePackageStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ConfigurePackageStep",
):
    '''CommandStep implemenation for aws:configurePackage https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-configurepackage.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        package_action: "IActionVariable",
        package_name: "IPackageNameVariable",
        additional_arguments: typing.Optional[IStringMapVariable] = None,
        installation_type: typing.Optional["IInstallationTypeVariable"] = None,
        version: typing.Optional[IStringVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param package_action: Install or uninstall a package.
        :param package_name: The name of the AWS package to install or uninstall.
        :param additional_arguments: The additional parameters to provide to your install, uninstall, or update scripts. Each parameter must be prefixed with SSM_. You can reference a Parameter Store parameter in your additional arguments by using the convention {{ ssm:parameter-name }}. To use the additional parameter in your install, uninstall, or update script, you must reference the parameter as an environment variable using the syntax appropriate for the operating system. For example, in PowerShell, you reference the SSM_arg argument as $Env:SSM_arg. There is no limit to the number of arguments you define, but the additional argument input has a 4096 character limit. This limit includes all of the keys and values you define.
        :param installation_type: The type of installation to perform. If you specify Uninstall and reinstall, the package is completely uninstalled, and then reinstalled. The application is unavailable until the reinstallation is complete. If you specify In-place update, only new or changed files are added to the existing installation according you instructions you provide in an update script. The application remains available throughout the update process. The In-place update option isn't supported for AWS-published packages. Uninstall and reinstall is the default value.
        :param version: A specific version of the package to install or uninstall. If installing, the system installs the latest published version, by default. If uninstalling, the system uninstalls the currently installed version, by default. If no installed version is found, the latest published version is downloaded, and the uninstall action is run.
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa06bf91636e796eabf1604178523146f002b607ea03b36505ffda008602e29e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ConfigurePackageStepProps(
            package_action=package_action,
            package_name=package_name,
            additional_arguments=additional_arguments,
            installation_type=installation_type,
            version=version,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Inputs required for this command include ...'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="packageAction")
    def package_action(self) -> "IActionVariable":
        return typing.cast("IActionVariable", jsii.get(self, "packageAction"))

    @builtins.property
    @jsii.member(jsii_name="packageName")
    def package_name(self) -> "IPackageNameVariable":
        return typing.cast("IPackageNameVariable", jsii.get(self, "packageName"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="additionalArguments")
    def additional_arguments(self) -> typing.Optional[IStringMapVariable]:
        return typing.cast(typing.Optional[IStringMapVariable], jsii.get(self, "additionalArguments"))

    @builtins.property
    @jsii.member(jsii_name="installationType")
    def installation_type(self) -> typing.Optional["IInstallationTypeVariable"]:
        return typing.cast(typing.Optional["IInstallationTypeVariable"], jsii.get(self, "installationType"))

    @builtins.property
    @jsii.member(jsii_name="version")
    def version(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "version"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ConfigurePackageStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "package_action": "packageAction",
        "package_name": "packageName",
        "additional_arguments": "additionalArguments",
        "installation_type": "installationType",
        "version": "version",
    },
)
class ConfigurePackageStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        package_action: "IActionVariable",
        package_name: "IPackageNameVariable",
        additional_arguments: typing.Optional[IStringMapVariable] = None,
        installation_type: typing.Optional["IInstallationTypeVariable"] = None,
        version: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties ConfigurePackage step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param package_action: Install or uninstall a package.
        :param package_name: The name of the AWS package to install or uninstall.
        :param additional_arguments: The additional parameters to provide to your install, uninstall, or update scripts. Each parameter must be prefixed with SSM_. You can reference a Parameter Store parameter in your additional arguments by using the convention {{ ssm:parameter-name }}. To use the additional parameter in your install, uninstall, or update script, you must reference the parameter as an environment variable using the syntax appropriate for the operating system. For example, in PowerShell, you reference the SSM_arg argument as $Env:SSM_arg. There is no limit to the number of arguments you define, but the additional argument input has a 4096 character limit. This limit includes all of the keys and values you define.
        :param installation_type: The type of installation to perform. If you specify Uninstall and reinstall, the package is completely uninstalled, and then reinstalled. The application is unavailable until the reinstallation is complete. If you specify In-place update, only new or changed files are added to the existing installation according you instructions you provide in an update script. The application remains available throughout the update process. The In-place update option isn't supported for AWS-published packages. Uninstall and reinstall is the default value.
        :param version: A specific version of the package to install or uninstall. If installing, the system installs the latest published version, by default. If uninstalling, the system uninstalls the currently installed version, by default. If no installed version is found, the latest published version is downloaded, and the uninstall action is run.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__950d968d50e894ec93a3e6e22cd9c390c7d4a6057d6206c31a096e9d0b336cb0)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument package_action", value=package_action, expected_type=type_hints["package_action"])
            check_type(argname="argument package_name", value=package_name, expected_type=type_hints["package_name"])
            check_type(argname="argument additional_arguments", value=additional_arguments, expected_type=type_hints["additional_arguments"])
            check_type(argname="argument installation_type", value=installation_type, expected_type=type_hints["installation_type"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "package_action": package_action,
            "package_name": package_name,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if additional_arguments is not None:
            self._values["additional_arguments"] = additional_arguments
        if installation_type is not None:
            self._values["installation_type"] = installation_type
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def package_action(self) -> "IActionVariable":
        '''Install or uninstall a package.'''
        result = self._values.get("package_action")
        assert result is not None, "Required property 'package_action' is missing"
        return typing.cast("IActionVariable", result)

    @builtins.property
    def package_name(self) -> "IPackageNameVariable":
        '''The name of the AWS package to install or uninstall.'''
        result = self._values.get("package_name")
        assert result is not None, "Required property 'package_name' is missing"
        return typing.cast("IPackageNameVariable", result)

    @builtins.property
    def additional_arguments(self) -> typing.Optional[IStringMapVariable]:
        '''The additional parameters to provide to your install, uninstall, or update scripts.

        Each parameter must be prefixed with SSM_.
        You can reference a Parameter Store parameter in your additional arguments by using the convention {{ ssm:parameter-name }}.
        To use the additional parameter in your install, uninstall, or update script,
        you must reference the parameter as an environment variable using the syntax appropriate for the operating system.
        For example, in PowerShell, you reference the SSM_arg argument as $Env:SSM_arg.
        There is no limit to the number of arguments you define, but the additional argument input has a 4096 character limit.
        This limit includes all of the keys and values you define.
        '''
        result = self._values.get("additional_arguments")
        return typing.cast(typing.Optional[IStringMapVariable], result)

    @builtins.property
    def installation_type(self) -> typing.Optional["IInstallationTypeVariable"]:
        '''The type of installation to perform.

        If you specify Uninstall and reinstall, the package is completely uninstalled, and then reinstalled.
        The application is unavailable until the reinstallation is complete.
        If you specify In-place update, only new or changed files are added to the existing installation according you instructions you provide in an update script.
        The application remains available throughout the update process.
        The In-place update option isn't supported for AWS-published packages. Uninstall and reinstall is the default value.
        '''
        result = self._values.get("installation_type")
        return typing.cast(typing.Optional["IInstallationTypeVariable"], result)

    @builtins.property
    def version(self) -> typing.Optional[IStringVariable]:
        '''A specific version of the package to install or uninstall.

        If installing, the system installs the latest published version, by default.
        If uninstalling, the system uninstalls the currently installed version, by default.
        If no installed version is found, the latest published version is downloaded, and the uninstall action is run.
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConfigurePackageStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Continue(
    OnFailure,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.Continue",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="stepToInvoke")
    def step_to_invoke(self, current_step: AutomationStep) -> builtins.str:
        '''
        :param current_step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__542505bfe46ad08a63e60a06c7b1cc819951f96bfa85edd760a824569ac928a4)
            check_type(argname="argument current_step", value=current_step, expected_type=type_hints["current_step"])
        return typing.cast(builtins.str, jsii.invoke(self, "stepToInvoke", [current_step]))

    @jsii.member(jsii_name="toSsmValue")
    def to_ssm_value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "toSsmValue", []))


class CopyImageStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CopyImageStep",
):
    '''AutomationStep implemenation for aws:copyImage https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-copyimage.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        image_name: IStringVariable,
        source_image_id: IStringVariable,
        source_region: IStringVariable,
        client_token: typing.Optional[IStringVariable] = None,
        encrypted: typing.Optional["IBooleanVariable"] = None,
        image_description: typing.Optional[IStringVariable] = None,
        kms_key_id: typing.Optional[IStringVariable] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param image_name: The name for the image.
        :param source_image_id: The AMI ID to copy from the source Region.
        :param source_region: The region where the source AMI exists.
        :param client_token: (Optional) A unique, case-sensitive identifier that you provide to ensure request idempotency.
        :param encrypted: (Optional) Encrypt the target AMI.
        :param image_description: (Optional) A description of the image.
        :param kms_key_id: (Optional) The full Amazon Resource Name (ARN) of the AWS KMS key to use when encrypting the snapshots of an image during a copy operation.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__727d7c37ddd5f32706b7034ca362350f2da0a049084b10379133053117bacdbb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CopyImageStepProps(
            image_name=image_name,
            source_image_id=source_image_id,
            source_region=source_region,
            client_token=client_token,
            encrypted=encrypted,
            image_description=image_description,
            kms_key_id=kms_key_id,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="imageName")
    def image_name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "imageName"))

    @builtins.property
    @jsii.member(jsii_name="sourceImageId")
    def source_image_id(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "sourceImageId"))

    @builtins.property
    @jsii.member(jsii_name="sourceRegion")
    def source_region(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "sourceRegion"))

    @builtins.property
    @jsii.member(jsii_name="clientToken")
    def client_token(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "clientToken"))

    @builtins.property
    @jsii.member(jsii_name="encrypted")
    def encrypted(self) -> typing.Optional["IBooleanVariable"]:
        return typing.cast(typing.Optional["IBooleanVariable"], jsii.get(self, "encrypted"))

    @builtins.property
    @jsii.member(jsii_name="imageDescription")
    def image_description(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "imageDescription"))

    @builtins.property
    @jsii.member(jsii_name="kmsKeyId")
    def kms_key_id(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "kmsKeyId"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.CopyImageStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "image_name": "imageName",
        "source_image_id": "sourceImageId",
        "source_region": "sourceRegion",
        "client_token": "clientToken",
        "encrypted": "encrypted",
        "image_description": "imageDescription",
        "kms_key_id": "kmsKeyId",
    },
)
class CopyImageStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        image_name: IStringVariable,
        source_image_id: IStringVariable,
        source_region: IStringVariable,
        client_token: typing.Optional[IStringVariable] = None,
        encrypted: typing.Optional["IBooleanVariable"] = None,
        image_description: typing.Optional[IStringVariable] = None,
        kms_key_id: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties for CopyImageStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param image_name: The name for the image.
        :param source_image_id: The AMI ID to copy from the source Region.
        :param source_region: The region where the source AMI exists.
        :param client_token: (Optional) A unique, case-sensitive identifier that you provide to ensure request idempotency.
        :param encrypted: (Optional) Encrypt the target AMI.
        :param image_description: (Optional) A description of the image.
        :param kms_key_id: (Optional) The full Amazon Resource Name (ARN) of the AWS KMS key to use when encrypting the snapshots of an image during a copy operation.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__daed2d5b951de8a8f14e12921272a7b3bccc46876753cf68921d0b884b1acebe)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument image_name", value=image_name, expected_type=type_hints["image_name"])
            check_type(argname="argument source_image_id", value=source_image_id, expected_type=type_hints["source_image_id"])
            check_type(argname="argument source_region", value=source_region, expected_type=type_hints["source_region"])
            check_type(argname="argument client_token", value=client_token, expected_type=type_hints["client_token"])
            check_type(argname="argument encrypted", value=encrypted, expected_type=type_hints["encrypted"])
            check_type(argname="argument image_description", value=image_description, expected_type=type_hints["image_description"])
            check_type(argname="argument kms_key_id", value=kms_key_id, expected_type=type_hints["kms_key_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "image_name": image_name,
            "source_image_id": source_image_id,
            "source_region": source_region,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if client_token is not None:
            self._values["client_token"] = client_token
        if encrypted is not None:
            self._values["encrypted"] = encrypted
        if image_description is not None:
            self._values["image_description"] = image_description
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def image_name(self) -> IStringVariable:
        '''The name for the image.'''
        result = self._values.get("image_name")
        assert result is not None, "Required property 'image_name' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def source_image_id(self) -> IStringVariable:
        '''The AMI ID to copy from the source Region.'''
        result = self._values.get("source_image_id")
        assert result is not None, "Required property 'source_image_id' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def source_region(self) -> IStringVariable:
        '''The region where the source AMI exists.'''
        result = self._values.get("source_region")
        assert result is not None, "Required property 'source_region' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def client_token(self) -> typing.Optional[IStringVariable]:
        '''(Optional) A unique, case-sensitive identifier that you provide to ensure request idempotency.'''
        result = self._values.get("client_token")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def encrypted(self) -> typing.Optional["IBooleanVariable"]:
        '''(Optional) Encrypt the target AMI.'''
        result = self._values.get("encrypted")
        return typing.cast(typing.Optional["IBooleanVariable"], result)

    @builtins.property
    def image_description(self) -> typing.Optional[IStringVariable]:
        '''(Optional) A description of the image.'''
        result = self._values.get("image_description")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def kms_key_id(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The full Amazon Resource Name (ARN) of the AWS KMS key to use when encrypting the snapshots of an image during a copy operation.'''
        result = self._values.get("kms_key_id")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CopyImageStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CreateImageStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CreateImageStep",
):
    '''AutomationStep implemenation for aws:createImage https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-create.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        image_name: IStringVariable,
        instance_id: IStringVariable,
        block_device_mappings: typing.Optional[IStringMapVariable] = None,
        image_description: typing.Optional[IStringVariable] = None,
        no_reboot: typing.Optional["IBooleanVariable"] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param image_name: The name for the image.
        :param instance_id: The ID of the instance.
        :param block_device_mappings: (Optional) The block devices for the instance.
        :param image_description: (Optional) A description of the image.
        :param no_reboot: (Optional) By default, Amazon Elastic Compute Cloud (Amazon EC2) attempts to shut down and reboot the instance before creating the image. If the No Reboot option is set to true, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed. If you don't want the instance to run after you create an AMI from it, first use the aws:changeInstanceState  Change or assert instance state action to stop the instance, and then use this aws:createImage action with the NoReboot option set to true.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__614d8c3cb4e9c27a19d53a452d37d9841431902a11b9d5f2d1b9306b0b29053c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CreateImageStepProps(
            image_name=image_name,
            instance_id=instance_id,
            block_device_mappings=block_device_mappings,
            image_description=image_description,
            no_reboot=no_reboot,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="imageName")
    def image_name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "imageName"))

    @builtins.property
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "instanceId"))

    @builtins.property
    @jsii.member(jsii_name="blockDeviceMappings")
    def block_device_mappings(self) -> typing.Optional[IStringMapVariable]:
        return typing.cast(typing.Optional[IStringMapVariable], jsii.get(self, "blockDeviceMappings"))

    @builtins.property
    @jsii.member(jsii_name="imageDescription")
    def image_description(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "imageDescription"))

    @builtins.property
    @jsii.member(jsii_name="noReboot")
    def no_reboot(self) -> typing.Optional["IBooleanVariable"]:
        return typing.cast(typing.Optional["IBooleanVariable"], jsii.get(self, "noReboot"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.CreateImageStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "image_name": "imageName",
        "instance_id": "instanceId",
        "block_device_mappings": "blockDeviceMappings",
        "image_description": "imageDescription",
        "no_reboot": "noReboot",
    },
)
class CreateImageStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        image_name: IStringVariable,
        instance_id: IStringVariable,
        block_device_mappings: typing.Optional[IStringMapVariable] = None,
        image_description: typing.Optional[IStringVariable] = None,
        no_reboot: typing.Optional["IBooleanVariable"] = None,
    ) -> None:
        '''Properties for CreateImageStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param image_name: The name for the image.
        :param instance_id: The ID of the instance.
        :param block_device_mappings: (Optional) The block devices for the instance.
        :param image_description: (Optional) A description of the image.
        :param no_reboot: (Optional) By default, Amazon Elastic Compute Cloud (Amazon EC2) attempts to shut down and reboot the instance before creating the image. If the No Reboot option is set to true, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed. If you don't want the instance to run after you create an AMI from it, first use the aws:changeInstanceState  Change or assert instance state action to stop the instance, and then use this aws:createImage action with the NoReboot option set to true.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__257966723c4cacb3b5de02e730f4b6f45ef1124974014cf414c53ff40ea20840)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument image_name", value=image_name, expected_type=type_hints["image_name"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
            check_type(argname="argument block_device_mappings", value=block_device_mappings, expected_type=type_hints["block_device_mappings"])
            check_type(argname="argument image_description", value=image_description, expected_type=type_hints["image_description"])
            check_type(argname="argument no_reboot", value=no_reboot, expected_type=type_hints["no_reboot"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "image_name": image_name,
            "instance_id": instance_id,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if block_device_mappings is not None:
            self._values["block_device_mappings"] = block_device_mappings
        if image_description is not None:
            self._values["image_description"] = image_description
        if no_reboot is not None:
            self._values["no_reboot"] = no_reboot

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def image_name(self) -> IStringVariable:
        '''The name for the image.'''
        result = self._values.get("image_name")
        assert result is not None, "Required property 'image_name' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def instance_id(self) -> IStringVariable:
        '''The ID of the instance.'''
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def block_device_mappings(self) -> typing.Optional[IStringMapVariable]:
        '''(Optional) The block devices for the instance.'''
        result = self._values.get("block_device_mappings")
        return typing.cast(typing.Optional[IStringMapVariable], result)

    @builtins.property
    def image_description(self) -> typing.Optional[IStringVariable]:
        '''(Optional) A description of the image.'''
        result = self._values.get("image_description")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def no_reboot(self) -> typing.Optional["IBooleanVariable"]:
        '''(Optional) By default, Amazon Elastic Compute Cloud (Amazon EC2) attempts to shut down and reboot the instance before creating the image.

        If the No Reboot option is set to true, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed.
        If you don't want the instance to run after you create an AMI from it, first use the aws:changeInstanceState  Change or assert instance state action to stop the instance, and then use this aws:createImage action with the NoReboot option set to true.
        '''
        result = self._values.get("no_reboot")
        return typing.cast(typing.Optional["IBooleanVariable"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CreateImageStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CreateStackStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CreateStackStep",
):
    '''AutomationStep implementation for aws:createStack https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-createstack.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        stack_name: IStringVariable,
        template: typing.Union[BodyOrUrlProp, typing.Dict[builtins.str, typing.Any]],
        capabilities: typing.Optional[IStringListVariable] = None,
        client_request_token: typing.Optional[IStringVariable] = None,
        notification_ar_ns: typing.Optional[IStringListVariable] = None,
        on_stack_failure: typing.Optional["IOnFailureVariable"] = None,
        parameters: typing.Optional[IMapListVariable] = None,
        resource_types: typing.Optional[IStringListVariable] = None,
        role_arn: typing.Optional[IStringVariable] = None,
        stack_policy: typing.Optional[typing.Union[BodyOrUrlProp, typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[IMapListVariable] = None,
        timeout_in_minutes: typing.Optional[INumberVariable] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param stack_name: The name that is associated with the stack. The name must be unique in the Region in which you're creating the stack.
        :param template: Template body or URL. For more information, see `Template Anatomy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html>`_.
        :param capabilities: (Optional) A list of values that you specify before CloudFormation can create certain stacks. Some stack templates include resources that can affect permissions in your AWS account. For example, creating new AWS Identity and Access Management (IAM) users can affect permissions in your account. For those stacks, you must explicitly acknowledge their capabilities by specifying this parameter. Valid values include CAPABILITY_IAM, CAPABILITY_NAMED_IAM, and CAPABILITY_AUTO_EXPAND.
        :param client_request_token: (Optional) A unique identifier for this CreateStack request. Specify this token if you set maxAttempts in this step to a value greater than 1. By specifying this token, CloudFormation knows that you aren't attempting to create a new stack with the same name.
        :param notification_ar_ns: (Optional) The Amazon Simple Notification Service (Amazon SNS) topic ARNs for publishing stack-related events.
        :param on_stack_failure: (Optional) Determines the action to take if stack creation failed. Default: - Rollback on failure
        :param parameters: (Optional) A list of Parameter structures that specify input parameters for the stack. For more information, see the `Parameter <https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_Parameter.html>`_ data type.
        :param resource_types: (Optional) The template resource types that you have permissions to work with for this create stack action. For example: AWS::EC2::Instance, AWS::EC2::*, or Custom::MyCustomInstance.
        :param role_arn: (Optional) The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that CloudFormation assumes to create the stack. CloudFormation uses the role's credentials to make calls on your behalf. CloudFormation always uses this role for all future operations on the stack. As long as users have permission to operate on the stack, CloudFormation uses this role even if the users don't have permission to pass it. Ensure that the role grants the least amount of privileges. If you don't specify a value, CloudFormation uses the role that was previously associated with the stack. If no role is available, CloudFormation uses a temporary session that is generated from your user credentials.
        :param stack_policy: (Optional) Stack policy body or URL. For more information, see `Prevent Updates to Stack Resources <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html>`_.
        :param tags: (Optional) Key-value pairs to associate with this stack. CloudFormation also propagates these tags to the resources created in the stack. You can specify a maximum number of 10 tags.
        :param timeout_in_minutes: (Optional) The amount of time that can pass before the stack status becomes CREATE_FAILED. If DisableRollback isn't set or is set to false, the stack will be rolled back.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6dbbc7397597fc834f7db22620a8be37e4c590ce192423159bf101d96b4726b8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CreateStackStepProps(
            stack_name=stack_name,
            template=template,
            capabilities=capabilities,
            client_request_token=client_request_token,
            notification_ar_ns=notification_ar_ns,
            on_stack_failure=on_stack_failure,
            parameters=parameters,
            resource_types=resource_types,
            role_arn=role_arn,
            stack_policy=stack_policy,
            tags=tags,
            timeout_in_minutes=timeout_in_minutes,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="stackName")
    def stack_name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "stackName"))

    @builtins.property
    @jsii.member(jsii_name="capabilities")
    def capabilities(self) -> typing.Optional[IStringListVariable]:
        return typing.cast(typing.Optional[IStringListVariable], jsii.get(self, "capabilities"))

    @builtins.property
    @jsii.member(jsii_name="clientRequestToken")
    def client_request_token(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "clientRequestToken"))

    @builtins.property
    @jsii.member(jsii_name="notificationARNs")
    def notification_ar_ns(self) -> typing.Optional[IStringListVariable]:
        return typing.cast(typing.Optional[IStringListVariable], jsii.get(self, "notificationARNs"))

    @builtins.property
    @jsii.member(jsii_name="onStackFailure")
    def on_stack_failure(self) -> typing.Optional["IOnFailureVariable"]:
        return typing.cast(typing.Optional["IOnFailureVariable"], jsii.get(self, "onStackFailure"))

    @builtins.property
    @jsii.member(jsii_name="parameters")
    def parameters(self) -> typing.Optional[IMapListVariable]:
        return typing.cast(typing.Optional[IMapListVariable], jsii.get(self, "parameters"))

    @builtins.property
    @jsii.member(jsii_name="resourceTypes")
    def resource_types(self) -> typing.Optional[IStringListVariable]:
        return typing.cast(typing.Optional[IStringListVariable], jsii.get(self, "resourceTypes"))

    @builtins.property
    @jsii.member(jsii_name="roleArn")
    def role_arn(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "roleArn"))

    @builtins.property
    @jsii.member(jsii_name="stackPolicyBody")
    def stack_policy_body(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "stackPolicyBody"))

    @builtins.property
    @jsii.member(jsii_name="stackPolicyUrl")
    def stack_policy_url(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "stackPolicyUrl"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[IMapListVariable]:
        return typing.cast(typing.Optional[IMapListVariable], jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="templateBody")
    def template_body(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "templateBody"))

    @builtins.property
    @jsii.member(jsii_name="templateUrl")
    def template_url(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "templateUrl"))

    @builtins.property
    @jsii.member(jsii_name="timeoutInMinutes")
    def timeout_in_minutes(self) -> typing.Optional[INumberVariable]:
        return typing.cast(typing.Optional[INumberVariable], jsii.get(self, "timeoutInMinutes"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.CreateStackStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "stack_name": "stackName",
        "template": "template",
        "capabilities": "capabilities",
        "client_request_token": "clientRequestToken",
        "notification_ar_ns": "notificationARNs",
        "on_stack_failure": "onStackFailure",
        "parameters": "parameters",
        "resource_types": "resourceTypes",
        "role_arn": "roleArn",
        "stack_policy": "stackPolicy",
        "tags": "tags",
        "timeout_in_minutes": "timeoutInMinutes",
    },
)
class CreateStackStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        stack_name: IStringVariable,
        template: typing.Union[BodyOrUrlProp, typing.Dict[builtins.str, typing.Any]],
        capabilities: typing.Optional[IStringListVariable] = None,
        client_request_token: typing.Optional[IStringVariable] = None,
        notification_ar_ns: typing.Optional[IStringListVariable] = None,
        on_stack_failure: typing.Optional["IOnFailureVariable"] = None,
        parameters: typing.Optional[IMapListVariable] = None,
        resource_types: typing.Optional[IStringListVariable] = None,
        role_arn: typing.Optional[IStringVariable] = None,
        stack_policy: typing.Optional[typing.Union[BodyOrUrlProp, typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[IMapListVariable] = None,
        timeout_in_minutes: typing.Optional[INumberVariable] = None,
    ) -> None:
        '''Properties for CreateStackStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param stack_name: The name that is associated with the stack. The name must be unique in the Region in which you're creating the stack.
        :param template: Template body or URL. For more information, see `Template Anatomy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html>`_.
        :param capabilities: (Optional) A list of values that you specify before CloudFormation can create certain stacks. Some stack templates include resources that can affect permissions in your AWS account. For example, creating new AWS Identity and Access Management (IAM) users can affect permissions in your account. For those stacks, you must explicitly acknowledge their capabilities by specifying this parameter. Valid values include CAPABILITY_IAM, CAPABILITY_NAMED_IAM, and CAPABILITY_AUTO_EXPAND.
        :param client_request_token: (Optional) A unique identifier for this CreateStack request. Specify this token if you set maxAttempts in this step to a value greater than 1. By specifying this token, CloudFormation knows that you aren't attempting to create a new stack with the same name.
        :param notification_ar_ns: (Optional) The Amazon Simple Notification Service (Amazon SNS) topic ARNs for publishing stack-related events.
        :param on_stack_failure: (Optional) Determines the action to take if stack creation failed. Default: - Rollback on failure
        :param parameters: (Optional) A list of Parameter structures that specify input parameters for the stack. For more information, see the `Parameter <https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_Parameter.html>`_ data type.
        :param resource_types: (Optional) The template resource types that you have permissions to work with for this create stack action. For example: AWS::EC2::Instance, AWS::EC2::*, or Custom::MyCustomInstance.
        :param role_arn: (Optional) The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that CloudFormation assumes to create the stack. CloudFormation uses the role's credentials to make calls on your behalf. CloudFormation always uses this role for all future operations on the stack. As long as users have permission to operate on the stack, CloudFormation uses this role even if the users don't have permission to pass it. Ensure that the role grants the least amount of privileges. If you don't specify a value, CloudFormation uses the role that was previously associated with the stack. If no role is available, CloudFormation uses a temporary session that is generated from your user credentials.
        :param stack_policy: (Optional) Stack policy body or URL. For more information, see `Prevent Updates to Stack Resources <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html>`_.
        :param tags: (Optional) Key-value pairs to associate with this stack. CloudFormation also propagates these tags to the resources created in the stack. You can specify a maximum number of 10 tags.
        :param timeout_in_minutes: (Optional) The amount of time that can pass before the stack status becomes CREATE_FAILED. If DisableRollback isn't set or is set to false, the stack will be rolled back.
        '''
        if isinstance(template, dict):
            template = BodyOrUrlProp(**template)
        if isinstance(stack_policy, dict):
            stack_policy = BodyOrUrlProp(**stack_policy)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb3eac84ba274be348d8088d3de8bcf6df1324114fce807eeb1806e3dbec8f20)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument stack_name", value=stack_name, expected_type=type_hints["stack_name"])
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
            check_type(argname="argument capabilities", value=capabilities, expected_type=type_hints["capabilities"])
            check_type(argname="argument client_request_token", value=client_request_token, expected_type=type_hints["client_request_token"])
            check_type(argname="argument notification_ar_ns", value=notification_ar_ns, expected_type=type_hints["notification_ar_ns"])
            check_type(argname="argument on_stack_failure", value=on_stack_failure, expected_type=type_hints["on_stack_failure"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument resource_types", value=resource_types, expected_type=type_hints["resource_types"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            check_type(argname="argument stack_policy", value=stack_policy, expected_type=type_hints["stack_policy"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument timeout_in_minutes", value=timeout_in_minutes, expected_type=type_hints["timeout_in_minutes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "stack_name": stack_name,
            "template": template,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if capabilities is not None:
            self._values["capabilities"] = capabilities
        if client_request_token is not None:
            self._values["client_request_token"] = client_request_token
        if notification_ar_ns is not None:
            self._values["notification_ar_ns"] = notification_ar_ns
        if on_stack_failure is not None:
            self._values["on_stack_failure"] = on_stack_failure
        if parameters is not None:
            self._values["parameters"] = parameters
        if resource_types is not None:
            self._values["resource_types"] = resource_types
        if role_arn is not None:
            self._values["role_arn"] = role_arn
        if stack_policy is not None:
            self._values["stack_policy"] = stack_policy
        if tags is not None:
            self._values["tags"] = tags
        if timeout_in_minutes is not None:
            self._values["timeout_in_minutes"] = timeout_in_minutes

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def stack_name(self) -> IStringVariable:
        '''The name that is associated with the stack.

        The name must be unique in the Region in which you're creating the stack.
        '''
        result = self._values.get("stack_name")
        assert result is not None, "Required property 'stack_name' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def template(self) -> BodyOrUrlProp:
        '''Template body or URL.

        For more information, see `Template Anatomy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-anatomy.html>`_.
        '''
        result = self._values.get("template")
        assert result is not None, "Required property 'template' is missing"
        return typing.cast(BodyOrUrlProp, result)

    @builtins.property
    def capabilities(self) -> typing.Optional[IStringListVariable]:
        '''(Optional) A list of values that you specify before CloudFormation can create certain stacks.

        Some stack templates include resources that can affect permissions in your AWS account.
        For example, creating new AWS Identity and Access Management (IAM) users can affect permissions in your account.
        For those stacks, you must explicitly acknowledge their capabilities by specifying this parameter.

        Valid values include CAPABILITY_IAM, CAPABILITY_NAMED_IAM, and CAPABILITY_AUTO_EXPAND.
        '''
        result = self._values.get("capabilities")
        return typing.cast(typing.Optional[IStringListVariable], result)

    @builtins.property
    def client_request_token(self) -> typing.Optional[IStringVariable]:
        '''(Optional) A unique identifier for this CreateStack request.

        Specify this token if you set maxAttempts in this step to a value greater than 1.
        By specifying this token, CloudFormation knows that you aren't attempting to create a new stack with the same name.
        '''
        result = self._values.get("client_request_token")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def notification_ar_ns(self) -> typing.Optional[IStringListVariable]:
        '''(Optional) The Amazon Simple Notification Service (Amazon SNS) topic ARNs for publishing stack-related events.'''
        result = self._values.get("notification_ar_ns")
        return typing.cast(typing.Optional[IStringListVariable], result)

    @builtins.property
    def on_stack_failure(self) -> typing.Optional["IOnFailureVariable"]:
        '''(Optional) Determines the action to take if stack creation failed.

        :default: - Rollback on failure
        '''
        result = self._values.get("on_stack_failure")
        return typing.cast(typing.Optional["IOnFailureVariable"], result)

    @builtins.property
    def parameters(self) -> typing.Optional[IMapListVariable]:
        '''(Optional) A list of Parameter structures that specify input parameters for the stack.

        For more information, see the `Parameter <https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_Parameter.html>`_ data type.
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[IMapListVariable], result)

    @builtins.property
    def resource_types(self) -> typing.Optional[IStringListVariable]:
        '''(Optional) The template resource types that you have permissions to work with for this create stack action.

        For example: AWS::EC2::Instance, AWS::EC2::*, or Custom::MyCustomInstance.
        '''
        result = self._values.get("resource_types")
        return typing.cast(typing.Optional[IStringListVariable], result)

    @builtins.property
    def role_arn(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that CloudFormation assumes to create the stack.

        CloudFormation uses the role's credentials to make calls on your behalf.
        CloudFormation always uses this role for all future operations on the stack.
        As long as users have permission to operate on the stack, CloudFormation uses this role even
        if the users don't have permission to pass it. Ensure that the role grants the least amount of privileges.

        If you don't specify a value, CloudFormation uses the role that was previously associated with the stack.
        If no role is available, CloudFormation uses a temporary session that is generated from your user credentials.
        '''
        result = self._values.get("role_arn")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def stack_policy(self) -> typing.Optional[BodyOrUrlProp]:
        '''(Optional) Stack policy body or URL.

        For more information, see `Prevent Updates to Stack Resources <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html>`_.
        '''
        result = self._values.get("stack_policy")
        return typing.cast(typing.Optional[BodyOrUrlProp], result)

    @builtins.property
    def tags(self) -> typing.Optional[IMapListVariable]:
        '''(Optional) Key-value pairs to associate with this stack.

        CloudFormation also propagates these tags to the resources created in the stack. You can specify a maximum number of 10 tags.
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[IMapListVariable], result)

    @builtins.property
    def timeout_in_minutes(self) -> typing.Optional[INumberVariable]:
        '''(Optional) The amount of time that can pass before the stack status becomes CREATE_FAILED.

        If DisableRollback isn't set or is set to false, the stack will be rolled back.
        '''
        result = self._values.get("timeout_in_minutes")
        return typing.cast(typing.Optional[INumberVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CreateStackStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CreateTagsStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.CreateTagsStep",
):
    '''AutomationStep implemenation for aws:createTags https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-createtag.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        resource_ids: IStringListVariable,
        tags: IMapListVariable,
        resource_type: typing.Optional["IResourceTypeVariable"] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param resource_ids: The IDs of the resource(s) to be tagged. If resource type isn't EC2, this field can contain only a single item.
        :param tags: The tags to associate with the resource(s).
        :param resource_type: (Optional) The type of resource(s) to be tagged. Valid values: EC2 | ManagedInstance | MaintenanceWindow | Parameter Default: EC2
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f20ee48975fccefe7ac2ac7d8a8a4924297a6792abdaa58503d4ee9437f7542)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CreateTagsStepProps(
            resource_ids=resource_ids,
            tags=tags,
            resource_type=resource_type,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''This step has no outputs.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="resourceIds")
    def resource_ids(self) -> IStringListVariable:
        return typing.cast(IStringListVariable, jsii.get(self, "resourceIds"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> IMapListVariable:
        return typing.cast(IMapListVariable, jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="resourceType")
    def resource_type(self) -> typing.Optional["IResourceTypeVariable"]:
        return typing.cast(typing.Optional["IResourceTypeVariable"], jsii.get(self, "resourceType"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.CreateTagsStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "resource_ids": "resourceIds",
        "tags": "tags",
        "resource_type": "resourceType",
    },
)
class CreateTagsStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        resource_ids: IStringListVariable,
        tags: IMapListVariable,
        resource_type: typing.Optional["IResourceTypeVariable"] = None,
    ) -> None:
        '''Properties for CreateTagStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param resource_ids: The IDs of the resource(s) to be tagged. If resource type isn't EC2, this field can contain only a single item.
        :param tags: The tags to associate with the resource(s).
        :param resource_type: (Optional) The type of resource(s) to be tagged. Valid values: EC2 | ManagedInstance | MaintenanceWindow | Parameter Default: EC2
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd8dd262701d5e216420dd9c2599aea6bef647a5838eca49d42ae0c7c7256aaf)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument resource_ids", value=resource_ids, expected_type=type_hints["resource_ids"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "resource_ids": resource_ids,
            "tags": tags,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if resource_type is not None:
            self._values["resource_type"] = resource_type

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def resource_ids(self) -> IStringListVariable:
        '''The IDs of the resource(s) to be tagged.

        If resource type isn't EC2, this field can contain only a single item.
        '''
        result = self._values.get("resource_ids")
        assert result is not None, "Required property 'resource_ids' is missing"
        return typing.cast(IStringListVariable, result)

    @builtins.property
    def tags(self) -> IMapListVariable:
        '''The tags to associate with the resource(s).'''
        result = self._values.get("tags")
        assert result is not None, "Required property 'tags' is missing"
        return typing.cast(IMapListVariable, result)

    @builtins.property
    def resource_type(self) -> typing.Optional["IResourceTypeVariable"]:
        '''(Optional) The type of resource(s) to be tagged.

        Valid values: EC2 | ManagedInstance | MaintenanceWindow | Parameter

        :default: EC2
        '''
        result = self._values.get("resource_type")
        return typing.cast(typing.Optional["IResourceTypeVariable"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CreateTagsStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DeleteImageStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DeleteImageStep",
):
    '''AutomationStep implementation for aws:deleteImage https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-delete.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        image_id: IStringVariable,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param image_id: The ID of the image to be deleted.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7918a829893ca74ddc5018c171bfb73f0ff2f9daafc8a965ff5e738f83c50ae7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DeleteImageStepProps(
            image_id=image_id,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''This step has no outputs.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "imageId"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.DeleteImageStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "image_id": "imageId",
    },
)
class DeleteImageStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        image_id: IStringVariable,
    ) -> None:
        '''Properties for DeleteImageStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param image_id: The ID of the image to be deleted.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d27e88de9d75b06b2b9ee40c00c4b943627b3f5e598a137ab30b3ffc073373b7)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument image_id", value=image_id, expected_type=type_hints["image_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "image_id": image_id,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def image_id(self) -> IStringVariable:
        '''The ID of the image to be deleted.'''
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return typing.cast(IStringVariable, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DeleteImageStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DeleteStackStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DeleteStackStep",
):
    '''AutomationStep implemenation for aws:deleteStack https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-deletestack.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        stack_name_variable: IStringVariable,
        role_arn: typing.Optional[IStringVariable] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param stack_name_variable: (Optional) Variable that is fed into this step declaring which stack to delete. Default: - StackName is the default value.
        :param role_arn: (Optional) The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that CloudFormation assumes to create the stack. CloudFormation uses the role's credentials to make calls on your behalf. CloudFormation always uses this role for all future operations on the stack. As long as users have permission to operate on the stack, CloudFormation uses this role even if the users don't have permission to pass it. Ensure that the role grants the least amount of privileges. If you don't specify a value, CloudFormation uses the role that was previously associated with the stack. If no role is available, CloudFormation uses a temporary session that is generated from your user credentials.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c454de90a263684d2e0248b180a4041752876ec2c13be1894f487426c0d520f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DeleteStackStepProps(
            stack_name_variable=stack_name_variable,
            role_arn=role_arn,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''The input required for this step is the stackNameVariable.

        :return: the stackNameVariable as declared in the constructor
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''No outputs emitted from Delete Stack step.

        :return: []
        '''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="stackNameVariable")
    def stack_name_variable(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "stackNameVariable"))

    @builtins.property
    @jsii.member(jsii_name="roleArn")
    def role_arn(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "roleArn"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.DeleteStackStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "stack_name_variable": "stackNameVariable",
        "role_arn": "roleArn",
    },
)
class DeleteStackStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        stack_name_variable: IStringVariable,
        role_arn: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties for DeleteStackStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param stack_name_variable: (Optional) Variable that is fed into this step declaring which stack to delete. Default: - StackName is the default value.
        :param role_arn: (Optional) The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that CloudFormation assumes to create the stack. CloudFormation uses the role's credentials to make calls on your behalf. CloudFormation always uses this role for all future operations on the stack. As long as users have permission to operate on the stack, CloudFormation uses this role even if the users don't have permission to pass it. Ensure that the role grants the least amount of privileges. If you don't specify a value, CloudFormation uses the role that was previously associated with the stack. If no role is available, CloudFormation uses a temporary session that is generated from your user credentials.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b933ebf2931383d7c3dcdc65ad8efd333fa3e56b0b11b0238be1082729e055e0)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument stack_name_variable", value=stack_name_variable, expected_type=type_hints["stack_name_variable"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "stack_name_variable": stack_name_variable,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if role_arn is not None:
            self._values["role_arn"] = role_arn

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def stack_name_variable(self) -> IStringVariable:
        '''(Optional) Variable that is fed into this step declaring which stack to delete.

        :default: - StackName is the default value.
        '''
        result = self._values.get("stack_name_variable")
        assert result is not None, "Required property 'stack_name_variable' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def role_arn(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that CloudFormation assumes to create the stack.

        CloudFormation uses the role's credentials to make calls on your behalf.
        CloudFormation always uses this role for all future operations on the stack.
        As long as users have permission to operate on the stack, CloudFormation uses this role even
        if the users don't have permission to pass it. Ensure that the role grants the least amount of privileges.

        If you don't specify a value, CloudFormation uses the role that was previously associated with the stack.
        If no role is available, CloudFormation uses a temporary session that is generated from your user credentials.
        '''
        result = self._values.get("role_arn")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DeleteStackStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IStringVariable)
class DictFormat(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DictFormat",
):
    def __init__(self, format: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''
        :param format: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a21a7e8d197f3aed68ed11fa6fe97a6c7fed8db50baf18c4b588b5ddacad07c6)
            check_type(argname="argument format", value=format, expected_type=type_hints["format"])
        jsii.create(self.__class__, self, [format])

    @jsii.member(jsii_name="print")
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "print", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="resolve")
    def resolve(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69c0c0efd00a365ac9a3bdfc6b5230c00b6574ebf6081ae072d0aec92bd29788)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", [inputs]))

    @jsii.member(jsii_name="resolveToDict")
    def resolve_to_dict(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__686016468b67aea85c5958cb763ff99367475ef22b6a0525abae0b6df2f84abe)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "resolveToDict", [inputs]))

    @jsii.member(jsii_name="resolveToString")
    def resolve_to_string(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.str:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c923d6f71533c5f77177a04acb7ec6c801abcd15c8134e72b5cba22b96e6744)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveToString", [inputs]))

    @jsii.member(jsii_name="toJSON")
    def to_json(self) -> typing.Any:
        '''JSON.stringify(variable) will implicitly invoke this variable.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJSON", []))

    @builtins.property
    @jsii.member(jsii_name="format")
    def format(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "format"))


@jsii.implements(IEnvironment)
class DockerEnvironment(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DockerEnvironment",
):
    '''Provides a Docker client against which customers can execute their commands.

    This utility will not download docker images, rather will create containers from images provided.
    You can use this rather than running your run commands against a real EC2 machine.
    '''

    @jsii.member(jsii_name="fromContainer")
    @builtins.classmethod
    def from_container(cls, container_id: builtins.str) -> "DockerEnvironment":
        '''Use an existing container against which to run commands using the run function.

        :param container_id: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82e0f56a7ca1ab281e211728631a7f6c2d3473bb083c4ef4b693d1361d41a19c)
            check_type(argname="argument container_id", value=container_id, expected_type=type_hints["container_id"])
        return typing.cast("DockerEnvironment", jsii.sinvoke(cls, "fromContainer", [container_id]))

    @jsii.member(jsii_name="fromImage")
    @builtins.classmethod
    def from_image(cls, image: builtins.str) -> "DockerEnvironment":
        '''Create a container from the provided image.

        The container created will be used by this instance to run commands using the run function.

        :param image: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4b1471cf18302c6579d1bf8e49a61b60d8d9068bf7220b665417614f34d7f09)
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
        return typing.cast("DockerEnvironment", jsii.sinvoke(cls, "fromImage", [image]))

    @jsii.member(jsii_name="removeContainer")
    def remove_container(self) -> None:
        '''Force removes the container associated with this instance.'''
        return typing.cast(None, jsii.invoke(self, "removeContainer", []))

    @jsii.member(jsii_name="run")
    def run(self, command: builtins.str) -> builtins.str:
        '''Runs commands against the docker specified during construction.

        This function runs synchronously.

        :param command: -

        :return: the response from the docker as a string.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d6590259dea715697c65615d0e1f22c5df49e5f7be843fbab2ce06da61adda6)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        return typing.cast(builtins.str, jsii.invoke(self, "run", [command]))

    @builtins.property
    @jsii.member(jsii_name="containerId")
    def container_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "containerId"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.DocumentResult",
    jsii_struct_bases=[SimulationResult],
    name_mapping={
        "executed_steps": "executedSteps",
        "response_code": "responseCode",
        "outputs": "outputs",
        "stack_trace": "stackTrace",
        "document_outputs": "documentOutputs",
    },
)
class DocumentResult(SimulationResult):
    def __init__(
        self,
        *,
        executed_steps: typing.Sequence[builtins.str],
        response_code: ResponseCode,
        outputs: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        stack_trace: typing.Optional[builtins.str] = None,
        document_outputs: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param executed_steps: All the steps that were executed in this Simulation.
        :param response_code: 
        :param outputs: May be empty if responseCode is FAILED/CANCELLED. There are no outputs provided for Command steps or documents.
        :param stack_trace: undefined if responseCode is SUCCESS.
        :param document_outputs: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf776619863c7996b1daeec6b7642cce00bcd086f961342758160415d66b423b)
            check_type(argname="argument executed_steps", value=executed_steps, expected_type=type_hints["executed_steps"])
            check_type(argname="argument response_code", value=response_code, expected_type=type_hints["response_code"])
            check_type(argname="argument outputs", value=outputs, expected_type=type_hints["outputs"])
            check_type(argname="argument stack_trace", value=stack_trace, expected_type=type_hints["stack_trace"])
            check_type(argname="argument document_outputs", value=document_outputs, expected_type=type_hints["document_outputs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "executed_steps": executed_steps,
            "response_code": response_code,
            "document_outputs": document_outputs,
        }
        if outputs is not None:
            self._values["outputs"] = outputs
        if stack_trace is not None:
            self._values["stack_trace"] = stack_trace

    @builtins.property
    def executed_steps(self) -> typing.List[builtins.str]:
        '''All the steps that were executed in this Simulation.'''
        result = self._values.get("executed_steps")
        assert result is not None, "Required property 'executed_steps' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def response_code(self) -> ResponseCode:
        result = self._values.get("response_code")
        assert result is not None, "Required property 'response_code' is missing"
        return typing.cast(ResponseCode, result)

    @builtins.property
    def outputs(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''May be empty if responseCode is FAILED/CANCELLED.

        There are no outputs provided for Command steps or documents.
        '''
        result = self._values.get("outputs")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def stack_trace(self) -> typing.Optional[builtins.str]:
        '''undefined if responseCode is SUCCESS.'''
        result = self._values.get("stack_trace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def document_outputs(self) -> typing.List[builtins.str]:
        result = self._values.get("document_outputs")
        assert result is not None, "Required property 'document_outputs' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DocumentResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DomainJoinStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DomainJoinStep",
):
    '''CommandStep implemenation for aws:softwareInventory https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-domainJoin.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        directory_id: IStringVariable,
        directory_name: IStringVariable,
        dns_ip_addresses: IStringListVariable,
        directory_ou: typing.Optional[IStringVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param directory_id: The ID of the directory.
        :param directory_name: The name of the domain.
        :param dns_ip_addresses: The IP addresses of the DNS servers.
        :param directory_ou: (Optional) The organizational unit (OU).
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf8a15a6f1a8c881a27b8c58586b34d818c1083e8bc9cad843d6f0fb97c9b9fb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DomainJoinStepProps(
            directory_id=directory_id,
            directory_name=directory_name,
            dns_ip_addresses=dns_ip_addresses,
            directory_ou=directory_ou,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''All Inputs for this command are optional.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="directoryId")
    def directory_id(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "directoryId"))

    @builtins.property
    @jsii.member(jsii_name="directoryName")
    def directory_name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "directoryName"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="directoryOU")
    def directory_ou(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "directoryOU"))

    @builtins.property
    @jsii.member(jsii_name="dnsIpAddresses")
    def dns_ip_addresses(self) -> typing.Optional[IStringListVariable]:
        return typing.cast(typing.Optional[IStringListVariable], jsii.get(self, "dnsIpAddresses"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.DomainJoinStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "directory_id": "directoryId",
        "directory_name": "directoryName",
        "dns_ip_addresses": "dnsIpAddresses",
        "directory_ou": "directoryOU",
    },
)
class DomainJoinStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        directory_id: IStringVariable,
        directory_name: IStringVariable,
        dns_ip_addresses: IStringListVariable,
        directory_ou: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties of DomainJoin step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param directory_id: The ID of the directory.
        :param directory_name: The name of the domain.
        :param dns_ip_addresses: The IP addresses of the DNS servers.
        :param directory_ou: (Optional) The organizational unit (OU).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__889cbdf96b162f8834876a74631a7187864a639e8667cb54886e33f737cbed67)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument directory_id", value=directory_id, expected_type=type_hints["directory_id"])
            check_type(argname="argument directory_name", value=directory_name, expected_type=type_hints["directory_name"])
            check_type(argname="argument dns_ip_addresses", value=dns_ip_addresses, expected_type=type_hints["dns_ip_addresses"])
            check_type(argname="argument directory_ou", value=directory_ou, expected_type=type_hints["directory_ou"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "directory_id": directory_id,
            "directory_name": directory_name,
            "dns_ip_addresses": dns_ip_addresses,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if directory_ou is not None:
            self._values["directory_ou"] = directory_ou

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def directory_id(self) -> IStringVariable:
        '''The ID of the directory.

        Example::

            "d-1234567890"
        '''
        result = self._values.get("directory_id")
        assert result is not None, "Required property 'directory_id' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def directory_name(self) -> IStringVariable:
        '''The name of the domain.

        Example::

            "example.com"
        '''
        result = self._values.get("directory_name")
        assert result is not None, "Required property 'directory_name' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def dns_ip_addresses(self) -> IStringListVariable:
        '''The IP addresses of the DNS servers.

        Example::

            ["198.51.100.1","198.51.100.2"]
        '''
        result = self._values.get("dns_ip_addresses")
        assert result is not None, "Required property 'dns_ip_addresses' is missing"
        return typing.cast(IStringListVariable, result)

    @builtins.property
    def directory_ou(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The organizational unit (OU).

        Example::

            "OU=test,DC=example,DC=com"
        '''
        result = self._values.get("directory_ou")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DomainJoinStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DownloadContentStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DownloadContentStep",
):
    '''AutomationStep implemenation for aws:downloadContent https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-downloadContent.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        downloadable_content: IDownloadableContent,
        destination_path: typing.Optional[IStringVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param downloadable_content: The information required to retrieve the content from the required source. This is a dictionary whose format changes based on the sourceType See the aws documentation for more info https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-downloadContent
        :param destination_path: (Optional) An optional local path on the instance where you want to download the file. If you don't specify a path, the content is downloaded to a path relative to your command ID.
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5aaf3d28eeab928673ebba5f4243a0fcad37126f7763d1ba633b38e52260ae65)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DownloadContentStepProps(
            downloadable_content=downloadable_content,
            destination_path=destination_path,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Inputs required for this command includes both the sourceType and sourceInfo variables and  destinationPath if provided.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="downloadableContent")
    def downloadable_content(self) -> IDownloadableContent:
        return typing.cast(IDownloadableContent, jsii.get(self, "downloadableContent"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="destinationPath")
    def destination_path(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "destinationPath"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.DownloadContentStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "downloadable_content": "downloadableContent",
        "destination_path": "destinationPath",
    },
)
class DownloadContentStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        downloadable_content: IDownloadableContent,
        destination_path: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties.json for ps Module step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param downloadable_content: The information required to retrieve the content from the required source. This is a dictionary whose format changes based on the sourceType See the aws documentation for more info https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-downloadContent
        :param destination_path: (Optional) An optional local path on the instance where you want to download the file. If you don't specify a path, the content is downloaded to a path relative to your command ID.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e964b124d913c4a2da4f1ebe04532981cb76e9d42719b9a959c0d61f7720f461)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument downloadable_content", value=downloadable_content, expected_type=type_hints["downloadable_content"])
            check_type(argname="argument destination_path", value=destination_path, expected_type=type_hints["destination_path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "downloadable_content": downloadable_content,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if destination_path is not None:
            self._values["destination_path"] = destination_path

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def downloadable_content(self) -> IDownloadableContent:
        '''The information required to retrieve the content from the required source.

        This is a dictionary whose format changes based on the sourceType
        See the aws documentation for more info
        https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-downloadContent
        '''
        result = self._values.get("downloadable_content")
        assert result is not None, "Required property 'downloadable_content' is missing"
        return typing.cast(IDownloadableContent, result)

    @builtins.property
    def destination_path(self) -> typing.Optional[IStringVariable]:
        '''(Optional) An optional local path on the instance where you want to download the file.

        If you don't specify a path, the content is downloaded to a path relative to your command ID.
        '''
        result = self._values.get("destination_path")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DownloadContentStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExecuteAutomationStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ExecuteAutomationStep",
):
    '''AutomationStep implementation for aws:executeAutomation https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-executeAutomation.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        document_name: IStringVariable,
        document_version: typing.Optional[IStringVariable] = None,
        max_concurrency: typing.Optional[IStringVariable] = None,
        max_errors: typing.Optional[IStringVariable] = None,
        runtime_parameters: typing.Optional[IStringMapVariable] = None,
        tags: typing.Optional[IMapListVariable] = None,
        target_locations: typing.Optional[IMapListVariable] = None,
        target_maps: typing.Optional[IMapListVariable] = None,
        target_parameter_name: typing.Optional[IStringVariable] = None,
        targets: typing.Optional[IMapListVariable] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param document_name: 
        :param document_version: 
        :param max_concurrency: 
        :param max_errors: 
        :param runtime_parameters: 
        :param tags: 
        :param target_locations: 
        :param target_maps: 
        :param target_parameter_name: 
        :param targets: 
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__769279ffc5e70495158bfb2d180c998a80950b96cd1a2e2a9e881e2a6d6363a8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ExecuteAutomationStepProps(
            document_name=document_name,
            document_version=document_version,
            max_concurrency=max_concurrency,
            max_errors=max_errors,
            runtime_parameters=runtime_parameters,
            tags=tags,
            target_locations=target_locations,
            target_maps=target_maps,
            target_parameter_name=target_parameter_name,
            targets=targets,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="documentName")
    def document_name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "documentName"))

    @builtins.property
    @jsii.member(jsii_name="documentVersion")
    def document_version(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "documentVersion"))

    @builtins.property
    @jsii.member(jsii_name="maxConcurrency")
    def max_concurrency(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "maxConcurrency"))

    @builtins.property
    @jsii.member(jsii_name="maxErrors")
    def max_errors(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "maxErrors"))

    @builtins.property
    @jsii.member(jsii_name="runtimeParameters")
    def runtime_parameters(self) -> typing.Optional[IStringMapVariable]:
        return typing.cast(typing.Optional[IStringMapVariable], jsii.get(self, "runtimeParameters"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Optional[IMapListVariable]:
        return typing.cast(typing.Optional[IMapListVariable], jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="targetLocations")
    def target_locations(self) -> typing.Optional[IMapListVariable]:
        return typing.cast(typing.Optional[IMapListVariable], jsii.get(self, "targetLocations"))

    @builtins.property
    @jsii.member(jsii_name="targetMaps")
    def target_maps(self) -> typing.Optional[IMapListVariable]:
        return typing.cast(typing.Optional[IMapListVariable], jsii.get(self, "targetMaps"))

    @builtins.property
    @jsii.member(jsii_name="targetParameterName")
    def target_parameter_name(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "targetParameterName"))

    @builtins.property
    @jsii.member(jsii_name="targets")
    def targets(self) -> typing.Optional[IMapListVariable]:
        return typing.cast(typing.Optional[IMapListVariable], jsii.get(self, "targets"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ExecuteAutomationStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "document_name": "documentName",
        "document_version": "documentVersion",
        "max_concurrency": "maxConcurrency",
        "max_errors": "maxErrors",
        "runtime_parameters": "runtimeParameters",
        "tags": "tags",
        "target_locations": "targetLocations",
        "target_maps": "targetMaps",
        "target_parameter_name": "targetParameterName",
        "targets": "targets",
    },
)
class ExecuteAutomationStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        document_name: IStringVariable,
        document_version: typing.Optional[IStringVariable] = None,
        max_concurrency: typing.Optional[IStringVariable] = None,
        max_errors: typing.Optional[IStringVariable] = None,
        runtime_parameters: typing.Optional[IStringMapVariable] = None,
        tags: typing.Optional[IMapListVariable] = None,
        target_locations: typing.Optional[IMapListVariable] = None,
        target_maps: typing.Optional[IMapListVariable] = None,
        target_parameter_name: typing.Optional[IStringVariable] = None,
        targets: typing.Optional[IMapListVariable] = None,
    ) -> None:
        '''
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param document_name: 
        :param document_version: 
        :param max_concurrency: 
        :param max_errors: 
        :param runtime_parameters: 
        :param tags: 
        :param target_locations: 
        :param target_maps: 
        :param target_parameter_name: 
        :param targets: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ddb66543f834e632b21143b76d7fbc589eefd88b9db39e4a14734632ff193a9f)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument document_name", value=document_name, expected_type=type_hints["document_name"])
            check_type(argname="argument document_version", value=document_version, expected_type=type_hints["document_version"])
            check_type(argname="argument max_concurrency", value=max_concurrency, expected_type=type_hints["max_concurrency"])
            check_type(argname="argument max_errors", value=max_errors, expected_type=type_hints["max_errors"])
            check_type(argname="argument runtime_parameters", value=runtime_parameters, expected_type=type_hints["runtime_parameters"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument target_locations", value=target_locations, expected_type=type_hints["target_locations"])
            check_type(argname="argument target_maps", value=target_maps, expected_type=type_hints["target_maps"])
            check_type(argname="argument target_parameter_name", value=target_parameter_name, expected_type=type_hints["target_parameter_name"])
            check_type(argname="argument targets", value=targets, expected_type=type_hints["targets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "document_name": document_name,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if document_version is not None:
            self._values["document_version"] = document_version
        if max_concurrency is not None:
            self._values["max_concurrency"] = max_concurrency
        if max_errors is not None:
            self._values["max_errors"] = max_errors
        if runtime_parameters is not None:
            self._values["runtime_parameters"] = runtime_parameters
        if tags is not None:
            self._values["tags"] = tags
        if target_locations is not None:
            self._values["target_locations"] = target_locations
        if target_maps is not None:
            self._values["target_maps"] = target_maps
        if target_parameter_name is not None:
            self._values["target_parameter_name"] = target_parameter_name
        if targets is not None:
            self._values["targets"] = targets

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def document_name(self) -> IStringVariable:
        result = self._values.get("document_name")
        assert result is not None, "Required property 'document_name' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def document_version(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("document_version")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def max_concurrency(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("max_concurrency")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def max_errors(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("max_errors")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def runtime_parameters(self) -> typing.Optional[IStringMapVariable]:
        result = self._values.get("runtime_parameters")
        return typing.cast(typing.Optional[IStringMapVariable], result)

    @builtins.property
    def tags(self) -> typing.Optional[IMapListVariable]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[IMapListVariable], result)

    @builtins.property
    def target_locations(self) -> typing.Optional[IMapListVariable]:
        result = self._values.get("target_locations")
        return typing.cast(typing.Optional[IMapListVariable], result)

    @builtins.property
    def target_maps(self) -> typing.Optional[IMapListVariable]:
        result = self._values.get("target_maps")
        return typing.cast(typing.Optional[IMapListVariable], result)

    @builtins.property
    def target_parameter_name(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("target_parameter_name")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def targets(self) -> typing.Optional[IMapListVariable]:
        result = self._values.get("targets")
        return typing.cast(typing.Optional[IMapListVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExecuteAutomationStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExecuteScriptStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ExecuteScriptStep",
):
    '''AutomationStep implementation for aws:executeScript https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-executeScript.html.'''

    def __init__(
        self,
        stage: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        code: ScriptCode,
        input_payload: typing.Mapping[builtins.str, IGenericVariable],
        language: ScriptLanguage,
        outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param stage: -
        :param id: -
        :param code: Inline code to be executed. String will be used to produce function in yaml/json. Simulation will execute the function in this code using the language specified.
        :param input_payload: InputPayload that will be passed to the first parameter of the handler. This can be used to pass input data to the script. The key of this dict is the variable name that will be available to the code. The value is the Variable object.
        :param language: (Required) Language used to execute the script.
        :param outputs: (Optional) Outputs that the function is expected to return. Be sure to prefix the selector for these outputs with "$.Payload." for executeScript step outputs. Default: []
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2826716496c296ca3069162df86bf193e6b74897b12f5e11a93ee52fa58505d2)
            check_type(argname="argument stage", value=stage, expected_type=type_hints["stage"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ExecuteScriptStepProps(
            code=code,
            input_payload=input_payload,
            language=language,
            outputs=outputs,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [stage, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listUserOutputs")
    def list_user_outputs(self) -> typing.List[Output]:
        '''Lists the outputs defined by the user for this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listUserOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="code")
    def code(self) -> ScriptCode:
        return typing.cast(ScriptCode, jsii.get(self, "code"))

    @builtins.property
    @jsii.member(jsii_name="inputs")
    def inputs(self) -> typing.Mapping[builtins.str, IGenericVariable]:
        return typing.cast(typing.Mapping[builtins.str, IGenericVariable], jsii.get(self, "inputs"))

    @builtins.property
    @jsii.member(jsii_name="language")
    def language(self) -> ScriptLanguage:
        return typing.cast(ScriptLanguage, jsii.get(self, "language"))

    @builtins.property
    @jsii.member(jsii_name="outputs")
    def outputs(self) -> typing.List[Output]:
        return typing.cast(typing.List[Output], jsii.get(self, "outputs"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ExecuteScriptStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "code": "code",
        "input_payload": "inputPayload",
        "language": "language",
        "outputs": "outputs",
    },
)
class ExecuteScriptStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        code: ScriptCode,
        input_payload: typing.Mapping[builtins.str, IGenericVariable],
        language: ScriptLanguage,
        outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for ExecuteScriptStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param code: Inline code to be executed. String will be used to produce function in yaml/json. Simulation will execute the function in this code using the language specified.
        :param input_payload: InputPayload that will be passed to the first parameter of the handler. This can be used to pass input data to the script. The key of this dict is the variable name that will be available to the code. The value is the Variable object.
        :param language: (Required) Language used to execute the script.
        :param outputs: (Optional) Outputs that the function is expected to return. Be sure to prefix the selector for these outputs with "$.Payload." for executeScript step outputs. Default: []
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0c4a09d9627727ecda0a0c2400fe5cac32d314e058fe0e41c4b563b58b66abc)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument code", value=code, expected_type=type_hints["code"])
            check_type(argname="argument input_payload", value=input_payload, expected_type=type_hints["input_payload"])
            check_type(argname="argument language", value=language, expected_type=type_hints["language"])
            check_type(argname="argument outputs", value=outputs, expected_type=type_hints["outputs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "code": code,
            "input_payload": input_payload,
            "language": language,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if outputs is not None:
            self._values["outputs"] = outputs

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def code(self) -> ScriptCode:
        '''Inline code to be executed.

        String will be used to produce function in yaml/json.
        Simulation will execute the function in this code using the language specified.
        '''
        result = self._values.get("code")
        assert result is not None, "Required property 'code' is missing"
        return typing.cast(ScriptCode, result)

    @builtins.property
    def input_payload(self) -> typing.Mapping[builtins.str, IGenericVariable]:
        '''InputPayload that will be passed to the first parameter of the handler.

        This can be used to pass input data to the script.
        The key of this dict is the variable name that will be available to the code.
        The value is the Variable object.
        '''
        result = self._values.get("input_payload")
        assert result is not None, "Required property 'input_payload' is missing"
        return typing.cast(typing.Mapping[builtins.str, IGenericVariable], result)

    @builtins.property
    def language(self) -> ScriptLanguage:
        '''(Required) Language used to execute the script.'''
        result = self._values.get("language")
        assert result is not None, "Required property 'language' is missing"
        return typing.cast(ScriptLanguage, result)

    @builtins.property
    def outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Outputs that the function is expected to return.

        Be sure to prefix the selector for these outputs with "$.Payload." for executeScript step outputs.

        :default: []
        '''
        result = self._values.get("outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExecuteScriptStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExecuteStateMachineStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ExecuteStateMachineStep",
):
    '''AutomationStep implementation of `aws:executeStateMachine <https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-executeStateMachine.html>`_.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        state_machine_arn: IStringVariable,
        execution_name: typing.Optional[IStringVariable] = None,
        input: typing.Optional[IStringVariable] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param state_machine_arn: The Amazon Resource Name (ARN) of the Step Functions state machine.
        :param execution_name: (Optional) The name of the execution.
        :param input: (Optional) A string that contains the JSON input data for the execution.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04e21ef6aa0f688be463495ce92b89574506008b962dc3865108483a302ff26b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ExecuteStateMachineStepProps(
            state_machine_arn=state_machine_arn,
            execution_name=execution_name,
            input=input,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''No outputs emitted from Delete Stack step.

        :return: []
        '''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="stateMachineArn")
    def state_machine_arn(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "stateMachineArn"))

    @builtins.property
    @jsii.member(jsii_name="executionName")
    def execution_name(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "executionName"))

    @builtins.property
    @jsii.member(jsii_name="input")
    def input(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "input"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ExecuteStateMachineStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "state_machine_arn": "stateMachineArn",
        "execution_name": "executionName",
        "input": "input",
    },
)
class ExecuteStateMachineStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        state_machine_arn: IStringVariable,
        execution_name: typing.Optional[IStringVariable] = None,
        input: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Props for ExecuteStateMachine step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param state_machine_arn: The Amazon Resource Name (ARN) of the Step Functions state machine.
        :param execution_name: (Optional) The name of the execution.
        :param input: (Optional) A string that contains the JSON input data for the execution.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8f637107edb9d13c1dbe1d8361731b75e9848a94f0b5dca69aa013960d4a1de)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument state_machine_arn", value=state_machine_arn, expected_type=type_hints["state_machine_arn"])
            check_type(argname="argument execution_name", value=execution_name, expected_type=type_hints["execution_name"])
            check_type(argname="argument input", value=input, expected_type=type_hints["input"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "state_machine_arn": state_machine_arn,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if execution_name is not None:
            self._values["execution_name"] = execution_name
        if input is not None:
            self._values["input"] = input

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def state_machine_arn(self) -> IStringVariable:
        '''The Amazon Resource Name (ARN) of the Step Functions state machine.'''
        result = self._values.get("state_machine_arn")
        assert result is not None, "Required property 'state_machine_arn' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def execution_name(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The name of the execution.'''
        result = self._values.get("execution_name")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def input(self) -> typing.Optional[IStringVariable]:
        '''(Optional) A string that contains the JSON input data for the execution.'''
        result = self._values.get("input")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExecuteStateMachineStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class FileScriptCode(
    ScriptCode,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.FileScriptCode",
):
    def __init__(self, full_path: builtins.str) -> None:
        '''
        :param full_path: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a096281fc475cc6926691794d748aa4a1d511e7425046a4d02839bd0cd4cb53)
            check_type(argname="argument full_path", value=full_path, expected_type=type_hints["full_path"])
        jsii.create(self.__class__, self, [full_path])

    @jsii.member(jsii_name="codeAsString")
    def code_as_string(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "codeAsString", []))

    @jsii.member(jsii_name="createOrGetFile")
    def create_or_get_file(self, _suffix: builtins.str) -> builtins.str:
        '''If there is a file for this code, return it.

        Otherwise, create a file with the specified suffix.

        :param _suffix: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd16a56052849ea3ca39c71e035ee1771b9a8eff9a670a6d8bb5eb23c44ff829)
            check_type(argname="argument _suffix", value=_suffix, expected_type=type_hints["_suffix"])
        return typing.cast(builtins.str, jsii.invoke(self, "createOrGetFile", [_suffix]))

    @builtins.property
    @jsii.member(jsii_name="fullPath")
    def full_path(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "fullPath"))


@jsii.implements(IGenericVariable)
class GenericVariable(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.GenericVariable",
):
    '''Abstraction of SSM variables.

    Variables are printed as using this syntax: {{ myVariable }}
    To resolve a variable, you must supply the available inputs and the variable will resolve the value.
    '''

    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__439c3ef61ff4ef64c8db771ab95a5ae493f98d3771d7da8926dfeb011d5993d2)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="assertType")
    @abc.abstractmethod
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        ...

    @jsii.member(jsii_name="print")
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "print", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="resolve")
    def resolve(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__570ca4af0d5cd41c7829c16d9aaa691286beceedaf461065a2eee4e4f79db0c4)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", [inputs]))

    @jsii.member(jsii_name="toJSON")
    def to_json(self) -> typing.Any:
        '''JSON.stringify(variable) will implicitly invoke this variable.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJSON", []))

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''Returns a string representation of an object.'''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

    @builtins.property
    @jsii.member(jsii_name="reference")
    def reference(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "reference"))


class _GenericVariableProxy(GenericVariable):
    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d701450914e899cd04b5ba4f7ba7163aeef74c0678a893f41a6e4f6e4e536ab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, GenericVariable).__jsii_proxy_class__ = lambda : _GenericVariableProxy


@jsii.implements(IDownloadableContent)
class GitContent(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.GitContent",
):
    def __init__(
        self,
        *,
        repository: IStringVariable,
        branch: typing.Optional[builtins.str] = None,
        commit_id: typing.Optional[builtins.str] = None,
        password: typing.Optional[SecureVariable] = None,
        private_ssh_key: typing.Optional[SecureVariable] = None,
        skip_host_key_checking: typing.Optional["IBooleanVariable"] = None,
        user_name: typing.Optional[SecureVariable] = None,
    ) -> None:
        '''
        :param repository: The Git repository URL to the file or directory you want to download.
        :param branch: The default is master. branch parameter is required only if your SSM document is stored in a branch other than master. Supply either commitId or branch (or neither).
        :param commit_id: The default is head. To use the version of your SSM document in a commit other than the latest, specify the full commit ID. For example: "bbc1ddb94...b76d3bEXAMPLE". Supply either commitId or branch (or neither).
        :param password: The password to use when connecting to the repository you specify using HTTP.
        :param private_ssh_key: The SSH key to use when connecting to the repository you specify.
        :param skip_host_key_checking: Determines the value of the StrictHostKeyChecking option when connecting to the repository you specify. The default value is false.
        :param user_name: The username to use when connecting to the repository you specify using HTTP.
        '''
        props = GitContentProps(
            repository=repository,
            branch=branch,
            commit_id=commit_id,
            password=password,
            private_ssh_key=private_ssh_key,
            skip_host_key_checking=skip_host_key_checking,
            user_name=user_name,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="formatSourceInfo")
    def format_source_info(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatSourceInfo", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @builtins.property
    @jsii.member(jsii_name="repository")
    def repository(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "repository"))

    @builtins.property
    @jsii.member(jsii_name="sourceType")
    def source_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceType"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branch"))

    @builtins.property
    @jsii.member(jsii_name="commitId")
    def commit_id(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "commitId"))

    @builtins.property
    @jsii.member(jsii_name="password")
    def password(self) -> typing.Optional[SecureVariable]:
        return typing.cast(typing.Optional[SecureVariable], jsii.get(self, "password"))

    @builtins.property
    @jsii.member(jsii_name="privateSshKey")
    def private_ssh_key(self) -> typing.Optional[SecureVariable]:
        return typing.cast(typing.Optional[SecureVariable], jsii.get(self, "privateSshKey"))

    @builtins.property
    @jsii.member(jsii_name="skipHostKeyChecking")
    def skip_host_key_checking(self) -> typing.Optional["IBooleanVariable"]:
        return typing.cast(typing.Optional["IBooleanVariable"], jsii.get(self, "skipHostKeyChecking"))

    @builtins.property
    @jsii.member(jsii_name="userName")
    def user_name(self) -> typing.Optional[SecureVariable]:
        return typing.cast(typing.Optional[SecureVariable], jsii.get(self, "userName"))


@jsii.implements(IDownloadableContent)
class GitHubContent(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.GitHubContent",
):
    def __init__(
        self,
        *,
        owner: IStringVariable,
        path: IStringVariable,
        repository: IStringVariable,
        token_info: SecureVariable,
        branch: typing.Optional[builtins.str] = None,
        commit_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param owner: The repository owner.
        :param path: The path to the file or directory you want to download.
        :param repository: The name of the repository.
        :param token_info: The Systems Manager parameter (a SecureString parameter) where you store your GitHub access token information.
        :param branch: The default is master. branch parameter is required only if your SSM document is stored in a branch other than master. Supply either commitId or branch (or neither).
        :param commit_id: The default is head. To use the version of your SSM document in a commit other than the latest, specify the full commit ID. For example: "bbc1ddb94...b76d3bEXAMPLE". Supply either commitId or branch (or neither).
        '''
        props = GitHubContentProps(
            owner=owner,
            path=path,
            repository=repository,
            token_info=token_info,
            branch=branch,
            commit_id=commit_id,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="formatSourceInfo")
    def format_source_info(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatSourceInfo", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @builtins.property
    @jsii.member(jsii_name="owner")
    def owner(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "owner"))

    @builtins.property
    @jsii.member(jsii_name="path")
    def path(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "path"))

    @builtins.property
    @jsii.member(jsii_name="repository")
    def repository(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "repository"))

    @builtins.property
    @jsii.member(jsii_name="sourceType")
    def source_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceType"))

    @builtins.property
    @jsii.member(jsii_name="tokenInfo")
    def token_info(self) -> SecureVariable:
        return typing.cast(SecureVariable, jsii.get(self, "tokenInfo"))

    @builtins.property
    @jsii.member(jsii_name="branch")
    def branch(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "branch"))

    @builtins.property
    @jsii.member(jsii_name="commitId")
    def commit_id(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "commitId"))


class HardCodedSecureVariable(
    SecureVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedSecureVariable",
):
    '''A hard-coded string variable.

    Used when not dependent on step inputs.
    '''

    def __init__(self, val: builtins.str) -> None:
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62776a7ec71ddf417f77ba60518b6c738f82bc55d2cf2697dde856d0858f6bd3)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        jsii.create(self.__class__, self, [val])

    @jsii.member(jsii_name="print")
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "print", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="resolve")
    def resolve(self, _inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param _inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f4e529da2d1c9ab3f7d99fa4b1d7d6bde60851763181caa65a460b37eac72b5)
            check_type(argname="argument _inputs", value=_inputs, expected_type=type_hints["_inputs"])
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", [_inputs]))

    @builtins.property
    @jsii.member(jsii_name="val")
    def val(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "val"))


@jsii.implements(IGenericVariable)
class HardCodedValueBase(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedValueBase",
):
    def __init__(self, val: typing.Any) -> None:
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b2499253656d74e32b98eccfefbaea32fa90141582bd2a3983e6d6b82ab2e54)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        jsii.create(self.__class__, self, [val])

    @jsii.member(jsii_name="assertType")
    @abc.abstractmethod
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        ...

    @jsii.member(jsii_name="print")
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "print", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="resolve")
    def resolve(self, _inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param _inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7422e708fe99a05a9f2a3ce26d3fbf30d52d7795a679e430d8e729ae65beea5e)
            check_type(argname="argument _inputs", value=_inputs, expected_type=type_hints["_inputs"])
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", [_inputs]))

    @jsii.member(jsii_name="toJSON")
    def to_json(self) -> typing.Any:
        '''JSON.stringify(variable) will implicitly invoke this variable.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJSON", []))

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''Returns a string representation of an object.'''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

    @builtins.property
    @jsii.member(jsii_name="val")
    def val(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "val"))


class _HardCodedValueBaseProxy(HardCodedValueBase):
    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d38e118d6d0afd7c57c552bc2c48e3cc470a81e6162ab0737482246f90c6324c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, HardCodedValueBase).__jsii_proxy_class__ = lambda : _HardCodedValueBaseProxy


@jsii.implements(IDownloadableContent)
class HttpContent(
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HttpContent",
):
    def __init__(
        self,
        *,
        url: IStringVariable,
        allow_insecure_download: typing.Optional["IBooleanVariable"] = None,
        auth_method: typing.Optional[AuthMethod] = None,
    ) -> None:
        '''
        :param url: The URL to the file or directory you want to download.
        :param allow_insecure_download: Determines whether a download can be performed over a connection that isn't encrypted with Secure Socket Layer (SSL) or Transport Layer Security (TLS). The default value is false. We don't recommend performing downloads without encryption. If you choose to do so, you assume all associated risks. Security is a shared responsibility between AWS and you. This is described as the shared responsibility model. To learn more, see the shared responsibility model.
        :param auth_method: Determines whether a username and password are used for authentication when connecting to the url you specify. If you specify Basic or Digest, you must provide values for the username and password parameters. To use the Digest method, SSM Agent version 3.0.1181.0 or later must be installed on your instance. The Digest method supports MD5 and SHA256 encryption.
        '''
        props = HttpContentProps(
            url=url,
            allow_insecure_download=allow_insecure_download,
            auth_method=auth_method,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="formatSourceInfo")
    def format_source_info(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "formatSourceInfo", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @builtins.property
    @jsii.member(jsii_name="sourceType")
    def source_type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "sourceType"))

    @builtins.property
    @jsii.member(jsii_name="url")
    def url(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "url"))

    @builtins.property
    @jsii.member(jsii_name="allowInsecureDownload")
    def allow_insecure_download(self) -> typing.Optional["IBooleanVariable"]:
        return typing.cast(typing.Optional["IBooleanVariable"], jsii.get(self, "allowInsecureDownload"))

    @builtins.property
    @jsii.member(jsii_name="authMethod")
    def auth_method(self) -> typing.Optional[AuthMethod]:
        return typing.cast(typing.Optional[AuthMethod], jsii.get(self, "authMethod"))


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IActionVariable")
class IActionVariable(IStringVariable, typing_extensions.Protocol):
    pass


class _IActionVariableProxy(
    jsii.proxy_for(IStringVariable), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IActionVariable"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IActionVariable).__jsii_proxy_class__ = lambda : _IActionVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IBooleanVariable")
class IBooleanVariable(IGenericVariable, typing_extensions.Protocol):
    '''A boolean variable.'''

    @jsii.member(jsii_name="resolveToBoolean")
    def resolve_to_boolean(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.bool:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        ...


class _IBooleanVariableProxy(
    jsii.proxy_for(IGenericVariable), # type: ignore[misc]
):
    '''A boolean variable.'''

    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IBooleanVariable"

    @jsii.member(jsii_name="resolveToBoolean")
    def resolve_to_boolean(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.bool:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: are the execution inputs.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d3750ea78c9c599657c6c794c8c7199a0e68faca4ed784d957499edbf77535e)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(builtins.bool, jsii.invoke(self, "resolveToBoolean", [inputs]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IBooleanVariable).__jsii_proxy_class__ = lambda : _IBooleanVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IDesiredStateVariable")
class IDesiredStateVariable(IStringVariable, typing_extensions.Protocol):
    pass


class _IDesiredStateVariableProxy(
    jsii.proxy_for(IStringVariable), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IDesiredStateVariable"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDesiredStateVariable).__jsii_proxy_class__ = lambda : _IDesiredStateVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IDocumentHashTypeVariable")
class IDocumentHashTypeVariable(IStringVariable, typing_extensions.Protocol):
    pass


class _IDocumentHashTypeVariableProxy(
    jsii.proxy_for(IStringVariable), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IDocumentHashTypeVariable"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDocumentHashTypeVariable).__jsii_proxy_class__ = lambda : _IDocumentHashTypeVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IInstallUninstallRepairVariable")
class IInstallUninstallRepairVariable(IStringVariable, typing_extensions.Protocol):
    pass


class _IInstallUninstallRepairVariableProxy(
    jsii.proxy_for(IStringVariable), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IInstallUninstallRepairVariable"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInstallUninstallRepairVariable).__jsii_proxy_class__ = lambda : _IInstallUninstallRepairVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IInstallationTypeVariable")
class IInstallationTypeVariable(IStringVariable, typing_extensions.Protocol):
    pass


class _IInstallationTypeVariableProxy(
    jsii.proxy_for(IStringVariable), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IInstallationTypeVariable"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInstallationTypeVariable).__jsii_proxy_class__ = lambda : _IInstallationTypeVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IOnFailureVariable")
class IOnFailureVariable(IStringVariable, typing_extensions.Protocol):
    pass


class _IOnFailureVariableProxy(
    jsii.proxy_for(IStringVariable), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IOnFailureVariable"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IOnFailureVariable).__jsii_proxy_class__ = lambda : _IOnFailureVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IPackageNameVariable")
class IPackageNameVariable(IStringVariable, typing_extensions.Protocol):
    pass


class _IPackageNameVariableProxy(
    jsii.proxy_for(IStringVariable), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IPackageNameVariable"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPackageNameVariable).__jsii_proxy_class__ = lambda : _IPackageNameVariableProxy


@jsii.interface(jsii_type="@cdklabs/cdk-ssm-documents.IResourceTypeVariable")
class IResourceTypeVariable(IStringVariable, typing_extensions.Protocol):
    pass


class _IResourceTypeVariableProxy(
    jsii.proxy_for(IStringVariable), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "@cdklabs/cdk-ssm-documents.IResourceTypeVariable"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IResourceTypeVariable).__jsii_proxy_class__ = lambda : _IResourceTypeVariableProxy


class InlineScriptCode(
    ScriptCode,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.InlineScriptCode",
):
    def __init__(self, inline_code: builtins.str) -> None:
        '''
        :param inline_code: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6e0535f0e492b832de4b517e12aea6ca1daba79117817ae5d19f95b00f5c616)
            check_type(argname="argument inline_code", value=inline_code, expected_type=type_hints["inline_code"])
        jsii.create(self.__class__, self, [inline_code])

    @jsii.member(jsii_name="codeAsString")
    def code_as_string(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "codeAsString", []))

    @jsii.member(jsii_name="createOrGetFile")
    def create_or_get_file(self, suffix: builtins.str) -> builtins.str:
        '''If there is a file for this code, return it.

        Otherwise, create a file with the specified suffix.

        :param suffix: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__641ad856100feac96e516e3f593bab142dcfe8cd078f2f3e45338d275d10feb7)
            check_type(argname="argument suffix", value=suffix, expected_type=type_hints["suffix"])
        return typing.cast(builtins.str, jsii.invoke(self, "createOrGetFile", [suffix]))

    @builtins.property
    @jsii.member(jsii_name="inlineCode")
    def inline_code(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "inlineCode"))


class InvokeLambdaFunctionStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.InvokeLambdaFunctionStep",
):
    '''AutomationStep implemenation for aws:invokeLambdaFunction https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-lamb.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        function_name: IStringVariable,
        client_context: typing.Optional[IStringVariable] = None,
        invocation_type: typing.Optional[IStringVariable] = None,
        log_type: typing.Optional[IStringVariable] = None,
        payload: typing.Optional[IStringMapVariable] = None,
        qualifier: typing.Optional[IStringVariable] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param function_name: The name of the Lambda function. This function must exist.
        :param client_context: (Optional) The client-specific information.
        :param invocation_type: (Optional) The invocation type. The default value is RequestResponse.
        :param log_type: (Optional) If the default value is Tail, the invocation type must be RequestResponse. Lambda returns the last 4 KB of log data produced by your Lambda function, base64-encoded.
        :param payload: (Optional) The JSON input for your Lambda function.
        :param qualifier: (Optional) The function version or alias name.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f988a082bb79889c6c8ab5d10131faef30d25b8c9471b2ca218842787be9e065)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = InvokeLambdaFunctionStepProps(
            function_name=function_name,
            client_context=client_context,
            invocation_type=invocation_type,
            log_type=log_type,
            payload=payload,
            qualifier=qualifier,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="functionName")
    def function_name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "functionName"))

    @builtins.property
    @jsii.member(jsii_name="awsInvoker")
    def aws_invoker(self) -> typing.Optional[IAwsInvoker]:
        return typing.cast(typing.Optional[IAwsInvoker], jsii.get(self, "awsInvoker"))

    @builtins.property
    @jsii.member(jsii_name="clientContext")
    def client_context(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "clientContext"))

    @builtins.property
    @jsii.member(jsii_name="invocationType")
    def invocation_type(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "invocationType"))

    @builtins.property
    @jsii.member(jsii_name="logType")
    def log_type(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "logType"))

    @builtins.property
    @jsii.member(jsii_name="payload")
    def payload(self) -> typing.Optional[IStringMapVariable]:
        return typing.cast(typing.Optional[IStringMapVariable], jsii.get(self, "payload"))

    @builtins.property
    @jsii.member(jsii_name="qualifier")
    def qualifier(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "qualifier"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.InvokeLambdaFunctionStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "function_name": "functionName",
        "client_context": "clientContext",
        "invocation_type": "invocationType",
        "log_type": "logType",
        "payload": "payload",
        "qualifier": "qualifier",
    },
)
class InvokeLambdaFunctionStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        function_name: IStringVariable,
        client_context: typing.Optional[IStringVariable] = None,
        invocation_type: typing.Optional[IStringVariable] = None,
        log_type: typing.Optional[IStringVariable] = None,
        payload: typing.Optional[IStringMapVariable] = None,
        qualifier: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties for InvokeLambdaFunctionStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param function_name: The name of the Lambda function. This function must exist.
        :param client_context: (Optional) The client-specific information.
        :param invocation_type: (Optional) The invocation type. The default value is RequestResponse.
        :param log_type: (Optional) If the default value is Tail, the invocation type must be RequestResponse. Lambda returns the last 4 KB of log data produced by your Lambda function, base64-encoded.
        :param payload: (Optional) The JSON input for your Lambda function.
        :param qualifier: (Optional) The function version or alias name.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__260d8a9bac3171aa48a2140b029bfaac8e6d506b494bfeb06cd9b971df358fea)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
            check_type(argname="argument client_context", value=client_context, expected_type=type_hints["client_context"])
            check_type(argname="argument invocation_type", value=invocation_type, expected_type=type_hints["invocation_type"])
            check_type(argname="argument log_type", value=log_type, expected_type=type_hints["log_type"])
            check_type(argname="argument payload", value=payload, expected_type=type_hints["payload"])
            check_type(argname="argument qualifier", value=qualifier, expected_type=type_hints["qualifier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "function_name": function_name,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if client_context is not None:
            self._values["client_context"] = client_context
        if invocation_type is not None:
            self._values["invocation_type"] = invocation_type
        if log_type is not None:
            self._values["log_type"] = log_type
        if payload is not None:
            self._values["payload"] = payload
        if qualifier is not None:
            self._values["qualifier"] = qualifier

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def function_name(self) -> IStringVariable:
        '''The name of the Lambda function.

        This function must exist.
        '''
        result = self._values.get("function_name")
        assert result is not None, "Required property 'function_name' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def client_context(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The client-specific information.'''
        result = self._values.get("client_context")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def invocation_type(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The invocation type.

        The default value is RequestResponse.
        '''
        result = self._values.get("invocation_type")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def log_type(self) -> typing.Optional[IStringVariable]:
        '''(Optional) If the default value is Tail, the invocation type must be RequestResponse.

        Lambda returns the last 4 KB of log data produced by your Lambda function, base64-encoded.
        '''
        result = self._values.get("log_type")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def payload(self) -> typing.Optional[IStringMapVariable]:
        '''(Optional) The JSON input for your Lambda function.'''
        result = self._values.get("payload")
        return typing.cast(typing.Optional[IStringMapVariable], result)

    @builtins.property
    def qualifier(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The function version or alias name.'''
        result = self._values.get("qualifier")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InvokeLambdaFunctionStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class InvokeWebhookStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.InvokeWebhookStep",
):
    '''AutomationStep implementation for `aws:invokeWebhook <https://docs.aws.amazon.com/systems-manager/latest/userguide/invoke-webhook.html>`_.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        integration_name: IStringVariable,
        body: typing.Optional[IStringVariable] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param integration_name: The name of the Automation integration. For example, exampleIntegration. The integration you specify must already exist.
        :param body: (Optional) The payload you want to send when your webhook integration is invoked.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d98b66121c98c49c21e9a829f3028cf525b5bef9a6411b6d120a9ad81c31b7c3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = InvokeWebhookStepProps(
            integration_name=integration_name,
            body=body,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="integrationName")
    def integration_name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "integrationName"))

    @builtins.property
    @jsii.member(jsii_name="body")
    def body(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "body"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.InvokeWebhookStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "integration_name": "integrationName",
        "body": "body",
    },
)
class InvokeWebhookStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional["OnCancel"] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        integration_name: IStringVariable,
        body: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties for InvokeWebhookStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param integration_name: The name of the Automation integration. For example, exampleIntegration. The integration you specify must already exist.
        :param body: (Optional) The payload you want to send when your webhook integration is invoked.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12f6a385027a66ded166fcbc0eda468bfea513bbacc2be059f649605120e592e)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument integration_name", value=integration_name, expected_type=type_hints["integration_name"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "integration_name": integration_name,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if body is not None:
            self._values["body"] = body

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional["OnCancel"]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional["OnCancel"], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def integration_name(self) -> IStringVariable:
        '''The name of the Automation integration.

        For example, exampleIntegration. The integration you specify must already exist.
        '''
        result = self._values.get("integration_name")
        assert result is not None, "Required property 'integration_name' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def body(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The payload you want to send when your webhook integration is invoked.'''
        result = self._values.get("body")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InvokeWebhookStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IMapListVariable)
class MapListVariable(
    GenericVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.MapListVariable",
):
    '''A map list variable reference.

    Used to resolve the value from step inputs.
    '''

    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4551ba08c76458e224d56e58450cc9141b6f63575c6314dbe83a5c15e1bd1a2d)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, reference: builtins.str) -> "MapListVariable":
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70ca355cfb1db717b7c1ecef889d642e917cd359941a56f5e64c5ad5949af19c)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        return typing.cast("MapListVariable", jsii.sinvoke(cls, "of", [reference]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecb8de4da8eab3110879e9a8bab9664936bb816da64e556956d6e6c7290093bd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToMapList")
    def resolve_to_map_list(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.List[typing.Mapping[builtins.str, typing.Any]]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da6cb7752ad49a3e323a6aaa792ca41cd67e70bfc298a33792bf9f7ee82b3ca0)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.List[typing.Mapping[builtins.str, typing.Any]], jsii.invoke(self, "resolveToMapList", [inputs]))


class NonSecureVariable(
    SecureVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.NonSecureVariable",
):
    '''A string variable reference.

    Used to resolve the value from step inputs.
    '''

    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1e30614d1a67f6c389f87f9682d78a6ef9f5363adbbbe93d26651afc49a9846)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="print")
    def print(self) -> typing.Any:
        '''Prints the variable in a way that SSM understands.

        This is typically in the form of {{ Variable }} or the value.
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "print", []))

    @jsii.member(jsii_name="requiredInputs")
    def required_inputs(self) -> typing.List[builtins.str]:
        '''The inputs that are required for determining the value of this variable.

        In the case of a single variable string, this will return a single value.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "requiredInputs", []))

    @jsii.member(jsii_name="resolve")
    def resolve(self, inputs: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a79b3e3d9b0088961c812f62e69fed25f03e48c9c7a771bb0393c3c18f8cafe2)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", [inputs]))

    @builtins.property
    @jsii.member(jsii_name="reference")
    def reference(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "reference"))


@jsii.implements(INumberVariable)
class NumberVariable(
    GenericVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.NumberVariable",
):
    '''A number variable reference.

    Used to resolve the value from step inputs.
    '''

    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b0f1755fa1e6ae327b973036eb2089e58fbc844a906310a73b8d321491ee295)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, reference: builtins.str) -> "NumberVariable":
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27d2c8926ce8859189b386b7f4f28611190b1266b6c8d9eb9331c26c9cae61d7)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        return typing.cast("NumberVariable", jsii.sinvoke(cls, "of", [reference]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75f939d957d3590d1874284f8de414db2703118e140d4d1f7dae3c94890cbbd7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToNumber")
    def resolve_to_number(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> jsii.Number:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1007fe234c4cad1b374433a2cb0a5b9459d317a688e4305394ce15928887aa63)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(jsii.Number, jsii.invoke(self, "resolveToNumber", [inputs]))


class OnCancel(
    OnFailure,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@cdklabs/cdk-ssm-documents.OnCancel",
):
    '''Steps can specify an action to take onCancel.

    See docs here: https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#canProp
    The supported actions are abort (default) or invoking a specific step.
    This behavior can be adopted by using the static methods available on OnCancel.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="abort")
    @builtins.classmethod
    def abort(cls) -> "OnCancel":
        '''To abort execution if a cancellation occurs during execution of the current step.

        (This is the default behavior.)
        '''
        return typing.cast("OnCancel", jsii.sinvoke(cls, "abort", []))

    @jsii.member(jsii_name="invokeStep")
    @builtins.classmethod
    def invoke_step(cls, step: AutomationStep) -> "OnCancel":
        '''Invoke a specific step.

        Provide the step object to execute for the onCancel action.
        If you don't have a handle to the step object, use the invokeStepByName function.
        Not all action types may be invoked during cancellation. See documentation referenced on this class.

        :param step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f26b3a34abe845c955ac47d0ecc284d4b9858b8cd9054f3314f34648e7c9226a)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
        return typing.cast("OnCancel", jsii.sinvoke(cls, "invokeStep", [step]))

    @jsii.member(jsii_name="invokeStepByName")
    @builtins.classmethod
    def invoke_step_by_name(cls, step_name: builtins.str) -> "OnCancel":
        '''Invoke a specific step by the step name for the OnCancel action.

        Not all action types may be invoked during cancellation. See documentation referenced on this class.

        :param step_name: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ea077d727b5346dfde397a16343ba8142fcceb382c55e162fc43b27f50f809b)
            check_type(argname="argument step_name", value=step_name, expected_type=type_hints["step_name"])
        return typing.cast("OnCancel", jsii.sinvoke(cls, "invokeStepByName", [step_name]))


class _OnCancelProxy(
    OnCancel,
    jsii.proxy_for(OnFailure), # type: ignore[misc]
):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, OnCancel).__jsii_proxy_class__ = lambda : _OnCancelProxy


class PauseStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.PauseStep",
):
    '''AutomationStep implementation for aws:pause https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-pause.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a70b6e0c99aac7400efda428da0dcd2506e270507823111a712a6b9af60bd54)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AutomationStepProps(
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''No inputs required for Pause step.

        :return: []
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''No outputs emitted from Pause step.

        :return: []
        '''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))


class PsModuleStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.PsModuleStep",
):
    '''AutomationStep implemenation for aws:psmodule https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-psModule.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        source: IStringVariable,
        run_command: typing.Optional[typing.Sequence[IStringVariable]] = None,
        source_hash: typing.Optional[IStringVariable] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        working_directory: typing.Optional[IStringVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param source: The URL or local path on the instance to the application .zip file. The name of the zip file must be the name of the module to be installed.
        :param run_command: Specify the commands to run or the path to an existing script on the instance.
        :param source_hash: (Optional) The SHA256 hash of the .zip file.
        :param timeout_seconds: (Optional) The time in seconds for a command to be completed before it's considered to have failed. When the timeout is reached, Systems Manager stops the command execution.
        :param working_directory: (Optional) The path to the working directory on your instance.
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b6071ba1c4a032f783155589a3537c1f8dd75514fa844dcc16d69877ca2cfe4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = PsModuleStepProps(
            source=source,
            run_command=run_command,
            source_hash=source_hash,
            timeout_seconds=timeout_seconds,
            working_directory=working_directory,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Inputs required for this command includes both the runCommand variables and workingDirectory if provided.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="source")
    def source(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "source"))

    @builtins.property
    @jsii.member(jsii_name="runCommand")
    def run_command(self) -> typing.Optional[typing.List[IStringVariable]]:
        return typing.cast(typing.Optional[typing.List[IStringVariable]], jsii.get(self, "runCommand"))

    @builtins.property
    @jsii.member(jsii_name="sourceHash")
    def source_hash(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "sourceHash"))

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "timeoutSeconds"))

    @builtins.property
    @jsii.member(jsii_name="workingDirectory")
    def working_directory(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "workingDirectory"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.PsModuleStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "source": "source",
        "run_command": "runCommand",
        "source_hash": "sourceHash",
        "timeout_seconds": "timeoutSeconds",
        "working_directory": "workingDirectory",
    },
)
class PsModuleStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        source: IStringVariable,
        run_command: typing.Optional[typing.Sequence[IStringVariable]] = None,
        source_hash: typing.Optional[IStringVariable] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        working_directory: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties for ps Module step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param source: The URL or local path on the instance to the application .zip file. The name of the zip file must be the name of the module to be installed.
        :param run_command: Specify the commands to run or the path to an existing script on the instance.
        :param source_hash: (Optional) The SHA256 hash of the .zip file.
        :param timeout_seconds: (Optional) The time in seconds for a command to be completed before it's considered to have failed. When the timeout is reached, Systems Manager stops the command execution.
        :param working_directory: (Optional) The path to the working directory on your instance.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18e479aed07c35924b07ca205129ceccaeca655bb4211314db0066de99f302e8)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument run_command", value=run_command, expected_type=type_hints["run_command"])
            check_type(argname="argument source_hash", value=source_hash, expected_type=type_hints["source_hash"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument working_directory", value=working_directory, expected_type=type_hints["working_directory"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "source": source,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if run_command is not None:
            self._values["run_command"] = run_command
        if source_hash is not None:
            self._values["source_hash"] = source_hash
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if working_directory is not None:
            self._values["working_directory"] = working_directory

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def source(self) -> IStringVariable:
        '''The URL or local path on the instance to the application .zip file. The name of the zip file must be the name of the module to be installed.'''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def run_command(self) -> typing.Optional[typing.List[IStringVariable]]:
        '''Specify the commands to run or the path to an existing script on the instance.'''
        result = self._values.get("run_command")
        return typing.cast(typing.Optional[typing.List[IStringVariable]], result)

    @builtins.property
    def source_hash(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The SHA256 hash of the .zip file.'''
        result = self._values.get("source_hash")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) The time in seconds for a command to be completed before it's considered to have failed.

        When the timeout is reached, Systems Manager stops the command execution.
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def working_directory(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The path to the working directory on your instance.'''
        result = self._values.get("working_directory")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PsModuleStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RebootInstanceAndWait(
    CompositeAutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RebootInstanceAndWait",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        instance_id: IStringVariable,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param instance_id: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2b3c67c89c3b5082e59c90f7266ef202e645f8c3b11283bc973ef3e760ac05e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument instance_id", value=instance_id, expected_type=type_hints["instance_id"])
        jsii.create(self.__class__, self, [scope, id, instance_id])

    @jsii.member(jsii_name="addToDocument")
    def add_to_document(self, doc: AutomationDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ac06fef9ba268c1c74c1ec0314914a6fb20311998398cf9caba444894cb1b8bb)
            check_type(argname="argument doc", value=doc, expected_type=type_hints["doc"])
        return typing.cast(None, jsii.invoke(self, "addToDocument", [doc]))

    @builtins.property
    @jsii.member(jsii_name="describe")
    def describe(self) -> "WaitForResourceStep":
        return typing.cast("WaitForResourceStep", jsii.get(self, "describe"))

    @builtins.property
    @jsii.member(jsii_name="reboot")
    def reboot(self) -> AwsApiStep:
        return typing.cast(AwsApiStep, jsii.get(self, "reboot"))


class RunCommandStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RunCommandStep",
):
    '''AutomationStep implementation of `aws:runCommand <https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-runcommand.html>`_.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        document_name: IStringVariable,
        targets: typing.Union[IStringListVariable, IMapListVariable],
        cloud_watch_output_config: typing.Optional[IStringMapVariable] = None,
        command_timeout_seconds: typing.Optional[INumberVariable] = None,
        comment: typing.Optional[IStringVariable] = None,
        document_hash: typing.Optional[IStringVariable] = None,
        document_hash_type: typing.Optional[IDocumentHashTypeVariable] = None,
        max_concurrency: typing.Optional[INumberVariable] = None,
        max_errors: typing.Optional[INumberVariable] = None,
        notification_config: typing.Optional[IStringMapVariable] = None,
        output_s3_bucket_name: typing.Optional[IStringVariable] = None,
        output_s3_key_prefix: typing.Optional[IStringVariable] = None,
        parameters: typing.Optional[IStringMapVariable] = None,
        service_role_arn: typing.Optional[IStringVariable] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param document_name: If the Command type document is owned by you or AWS, specify the name of the document. If you're using a document shared with you by a different AWS account, specify the Amazon Resource Name (ARN) of the document.
        :param targets: The instance IDs where you want the command to run. You can specify a maximum of 50 IDs. You can also use the pseudo parameter {{ RESOURCE_ID }} in place of instance IDs to run the command on all instances in the target group. For more information about pseudo parameters, see `About pseudo parameters <https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-register-tasks-parameters.html>`_. Another alternative is to send commands to a fleet of instances by using the Targets parameter. The Targets parameter accepts Amazon Elastic Compute Cloud (Amazon EC2) tags. For more information about how to use the Targets parameter, see `Using targets and rate controls to send commands to a fleet <https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html>`_.
        :param cloud_watch_output_config: (Optional) Configuration options for sending command output to Amazon CloudWatch Logs. For more information about sending command output to CloudWatch Logs, see `Configuring Amazon CloudWatch Logs for Run Command <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-rc-setting-up-cwlogs.html>`_.
        :param command_timeout_seconds: (Optional) The amount of time in seconds to wait for a command to deliver to the AWS Systems Manager SSM Agent on an instance. If the command isn't received by the SSM Agent on the instance before the value specified is reached, then the status of the command changes to Delivery Timed Out.
        :param comment: (Optional) User-defined information about the command.
        :param document_hash: (Optional) The hash for the document.
        :param document_hash_type: (Optional) The type of the hash.
        :param max_concurrency: (Optional) The maximum concurrency.
        :param max_errors: (Optional) The maximum errors.
        :param notification_config: (Optional) The configurations for sending notifications.
        :param output_s3_bucket_name: (Optional) The name of the S3 bucket for command output responses.
        :param output_s3_key_prefix: (Optional) The prefix.
        :param parameters: (Optional) The required and optional parameters specified in the document.
        :param service_role_arn: (Optional) The ARN of the AWS Identity and Access Management (IAM) role.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae82e9b3e9ffdd61fb04a49e1306de49cf4d8e5da1eda394a0f308c21ad6bda3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RunCommandStepProps(
            document_name=document_name,
            targets=targets,
            cloud_watch_output_config=cloud_watch_output_config,
            command_timeout_seconds=command_timeout_seconds,
            comment=comment,
            document_hash=document_hash,
            document_hash_type=document_hash_type,
            max_concurrency=max_concurrency,
            max_errors=max_errors,
            notification_config=notification_config,
            output_s3_bucket_name=output_s3_bucket_name,
            output_s3_key_prefix=output_s3_key_prefix,
            parameters=parameters,
            service_role_arn=service_role_arn,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="documentName")
    def document_name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "documentName"))

    @builtins.property
    @jsii.member(jsii_name="targets")
    def targets(self) -> typing.Union[IStringListVariable, IMapListVariable]:
        return typing.cast(typing.Union[IStringListVariable, IMapListVariable], jsii.get(self, "targets"))

    @builtins.property
    @jsii.member(jsii_name="cloudWatchOutputConfig")
    def cloud_watch_output_config(self) -> typing.Optional[IStringMapVariable]:
        return typing.cast(typing.Optional[IStringMapVariable], jsii.get(self, "cloudWatchOutputConfig"))

    @builtins.property
    @jsii.member(jsii_name="commandTimeoutSeconds")
    def command_timeout_seconds(self) -> typing.Optional[INumberVariable]:
        return typing.cast(typing.Optional[INumberVariable], jsii.get(self, "commandTimeoutSeconds"))

    @builtins.property
    @jsii.member(jsii_name="comment")
    def comment(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "comment"))

    @builtins.property
    @jsii.member(jsii_name="documentHash")
    def document_hash(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "documentHash"))

    @builtins.property
    @jsii.member(jsii_name="documentHashType")
    def document_hash_type(self) -> typing.Optional[IDocumentHashTypeVariable]:
        return typing.cast(typing.Optional[IDocumentHashTypeVariable], jsii.get(self, "documentHashType"))

    @builtins.property
    @jsii.member(jsii_name="maxConcurrency")
    def max_concurrency(self) -> typing.Optional[INumberVariable]:
        return typing.cast(typing.Optional[INumberVariable], jsii.get(self, "maxConcurrency"))

    @builtins.property
    @jsii.member(jsii_name="maxErrors")
    def max_errors(self) -> typing.Optional[INumberVariable]:
        return typing.cast(typing.Optional[INumberVariable], jsii.get(self, "maxErrors"))

    @builtins.property
    @jsii.member(jsii_name="notificationConfig")
    def notification_config(self) -> typing.Optional[IStringMapVariable]:
        return typing.cast(typing.Optional[IStringMapVariable], jsii.get(self, "notificationConfig"))

    @builtins.property
    @jsii.member(jsii_name="outputS3BucketName")
    def output_s3_bucket_name(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "outputS3BucketName"))

    @builtins.property
    @jsii.member(jsii_name="outputS3KeyPrefix")
    def output_s3_key_prefix(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "outputS3KeyPrefix"))

    @builtins.property
    @jsii.member(jsii_name="parameters")
    def parameters(self) -> typing.Optional[IStringMapVariable]:
        return typing.cast(typing.Optional[IStringMapVariable], jsii.get(self, "parameters"))

    @builtins.property
    @jsii.member(jsii_name="serviceRoleArn")
    def service_role_arn(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "serviceRoleArn"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RunCommandStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "document_name": "documentName",
        "targets": "targets",
        "cloud_watch_output_config": "cloudWatchOutputConfig",
        "command_timeout_seconds": "commandTimeoutSeconds",
        "comment": "comment",
        "document_hash": "documentHash",
        "document_hash_type": "documentHashType",
        "max_concurrency": "maxConcurrency",
        "max_errors": "maxErrors",
        "notification_config": "notificationConfig",
        "output_s3_bucket_name": "outputS3BucketName",
        "output_s3_key_prefix": "outputS3KeyPrefix",
        "parameters": "parameters",
        "service_role_arn": "serviceRoleArn",
    },
)
class RunCommandStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        document_name: IStringVariable,
        targets: typing.Union[IStringListVariable, IMapListVariable],
        cloud_watch_output_config: typing.Optional[IStringMapVariable] = None,
        command_timeout_seconds: typing.Optional[INumberVariable] = None,
        comment: typing.Optional[IStringVariable] = None,
        document_hash: typing.Optional[IStringVariable] = None,
        document_hash_type: typing.Optional[IDocumentHashTypeVariable] = None,
        max_concurrency: typing.Optional[INumberVariable] = None,
        max_errors: typing.Optional[INumberVariable] = None,
        notification_config: typing.Optional[IStringMapVariable] = None,
        output_s3_bucket_name: typing.Optional[IStringVariable] = None,
        output_s3_key_prefix: typing.Optional[IStringVariable] = None,
        parameters: typing.Optional[IStringMapVariable] = None,
        service_role_arn: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties for RunCommandStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param document_name: If the Command type document is owned by you or AWS, specify the name of the document. If you're using a document shared with you by a different AWS account, specify the Amazon Resource Name (ARN) of the document.
        :param targets: The instance IDs where you want the command to run. You can specify a maximum of 50 IDs. You can also use the pseudo parameter {{ RESOURCE_ID }} in place of instance IDs to run the command on all instances in the target group. For more information about pseudo parameters, see `About pseudo parameters <https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-register-tasks-parameters.html>`_. Another alternative is to send commands to a fleet of instances by using the Targets parameter. The Targets parameter accepts Amazon Elastic Compute Cloud (Amazon EC2) tags. For more information about how to use the Targets parameter, see `Using targets and rate controls to send commands to a fleet <https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html>`_.
        :param cloud_watch_output_config: (Optional) Configuration options for sending command output to Amazon CloudWatch Logs. For more information about sending command output to CloudWatch Logs, see `Configuring Amazon CloudWatch Logs for Run Command <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-rc-setting-up-cwlogs.html>`_.
        :param command_timeout_seconds: (Optional) The amount of time in seconds to wait for a command to deliver to the AWS Systems Manager SSM Agent on an instance. If the command isn't received by the SSM Agent on the instance before the value specified is reached, then the status of the command changes to Delivery Timed Out.
        :param comment: (Optional) User-defined information about the command.
        :param document_hash: (Optional) The hash for the document.
        :param document_hash_type: (Optional) The type of the hash.
        :param max_concurrency: (Optional) The maximum concurrency.
        :param max_errors: (Optional) The maximum errors.
        :param notification_config: (Optional) The configurations for sending notifications.
        :param output_s3_bucket_name: (Optional) The name of the S3 bucket for command output responses.
        :param output_s3_key_prefix: (Optional) The prefix.
        :param parameters: (Optional) The required and optional parameters specified in the document.
        :param service_role_arn: (Optional) The ARN of the AWS Identity and Access Management (IAM) role.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1062cc7195160b74c1853353a52fd8f6171639e926a461e3d7c79bb9ce4313f)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument document_name", value=document_name, expected_type=type_hints["document_name"])
            check_type(argname="argument targets", value=targets, expected_type=type_hints["targets"])
            check_type(argname="argument cloud_watch_output_config", value=cloud_watch_output_config, expected_type=type_hints["cloud_watch_output_config"])
            check_type(argname="argument command_timeout_seconds", value=command_timeout_seconds, expected_type=type_hints["command_timeout_seconds"])
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument document_hash", value=document_hash, expected_type=type_hints["document_hash"])
            check_type(argname="argument document_hash_type", value=document_hash_type, expected_type=type_hints["document_hash_type"])
            check_type(argname="argument max_concurrency", value=max_concurrency, expected_type=type_hints["max_concurrency"])
            check_type(argname="argument max_errors", value=max_errors, expected_type=type_hints["max_errors"])
            check_type(argname="argument notification_config", value=notification_config, expected_type=type_hints["notification_config"])
            check_type(argname="argument output_s3_bucket_name", value=output_s3_bucket_name, expected_type=type_hints["output_s3_bucket_name"])
            check_type(argname="argument output_s3_key_prefix", value=output_s3_key_prefix, expected_type=type_hints["output_s3_key_prefix"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument service_role_arn", value=service_role_arn, expected_type=type_hints["service_role_arn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "document_name": document_name,
            "targets": targets,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if cloud_watch_output_config is not None:
            self._values["cloud_watch_output_config"] = cloud_watch_output_config
        if command_timeout_seconds is not None:
            self._values["command_timeout_seconds"] = command_timeout_seconds
        if comment is not None:
            self._values["comment"] = comment
        if document_hash is not None:
            self._values["document_hash"] = document_hash
        if document_hash_type is not None:
            self._values["document_hash_type"] = document_hash_type
        if max_concurrency is not None:
            self._values["max_concurrency"] = max_concurrency
        if max_errors is not None:
            self._values["max_errors"] = max_errors
        if notification_config is not None:
            self._values["notification_config"] = notification_config
        if output_s3_bucket_name is not None:
            self._values["output_s3_bucket_name"] = output_s3_bucket_name
        if output_s3_key_prefix is not None:
            self._values["output_s3_key_prefix"] = output_s3_key_prefix
        if parameters is not None:
            self._values["parameters"] = parameters
        if service_role_arn is not None:
            self._values["service_role_arn"] = service_role_arn

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[OnCancel]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[OnCancel], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def document_name(self) -> IStringVariable:
        '''If the Command type document is owned by you or AWS, specify the name of the document.

        If you're using a document shared with you by a different AWS account, specify the Amazon Resource Name (ARN) of the document.
        '''
        result = self._values.get("document_name")
        assert result is not None, "Required property 'document_name' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def targets(self) -> typing.Union[IStringListVariable, IMapListVariable]:
        '''The instance IDs where you want the command to run. You can specify a maximum of 50 IDs.

        You can also use the pseudo parameter {{ RESOURCE_ID }} in place of instance IDs to run the command on all instances in the target group. For more information about pseudo parameters, see `About pseudo parameters <https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-register-tasks-parameters.html>`_.

        Another alternative is to send commands to a fleet of instances by using the Targets parameter. The Targets parameter accepts Amazon Elastic Compute Cloud (Amazon EC2) tags. For more information about how to use the Targets parameter, see `Using targets and rate controls to send commands to a fleet <https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html>`_.
        '''
        result = self._values.get("targets")
        assert result is not None, "Required property 'targets' is missing"
        return typing.cast(typing.Union[IStringListVariable, IMapListVariable], result)

    @builtins.property
    def cloud_watch_output_config(self) -> typing.Optional[IStringMapVariable]:
        '''(Optional) Configuration options for sending command output to Amazon CloudWatch Logs.

        For more information about sending command output to CloudWatch Logs, see `Configuring Amazon CloudWatch Logs for Run Command <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-rc-setting-up-cwlogs.html>`_.
        '''
        result = self._values.get("cloud_watch_output_config")
        return typing.cast(typing.Optional[IStringMapVariable], result)

    @builtins.property
    def command_timeout_seconds(self) -> typing.Optional[INumberVariable]:
        '''(Optional) The amount of time in seconds to wait for a command to deliver to the AWS Systems Manager SSM Agent on an instance.

        If the command isn't received by the SSM Agent on the instance before the value specified is reached, then the status of the command changes to Delivery Timed Out.
        '''
        result = self._values.get("command_timeout_seconds")
        return typing.cast(typing.Optional[INumberVariable], result)

    @builtins.property
    def comment(self) -> typing.Optional[IStringVariable]:
        '''(Optional) User-defined information about the command.'''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def document_hash(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The hash for the document.'''
        result = self._values.get("document_hash")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def document_hash_type(self) -> typing.Optional[IDocumentHashTypeVariable]:
        '''(Optional) The type of the hash.'''
        result = self._values.get("document_hash_type")
        return typing.cast(typing.Optional[IDocumentHashTypeVariable], result)

    @builtins.property
    def max_concurrency(self) -> typing.Optional[INumberVariable]:
        '''(Optional) The maximum concurrency.'''
        result = self._values.get("max_concurrency")
        return typing.cast(typing.Optional[INumberVariable], result)

    @builtins.property
    def max_errors(self) -> typing.Optional[INumberVariable]:
        '''(Optional) The maximum errors.'''
        result = self._values.get("max_errors")
        return typing.cast(typing.Optional[INumberVariable], result)

    @builtins.property
    def notification_config(self) -> typing.Optional[IStringMapVariable]:
        '''(Optional) The configurations for sending notifications.'''
        result = self._values.get("notification_config")
        return typing.cast(typing.Optional[IStringMapVariable], result)

    @builtins.property
    def output_s3_bucket_name(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The name of the S3 bucket for command output responses.'''
        result = self._values.get("output_s3_bucket_name")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def output_s3_key_prefix(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The prefix.'''
        result = self._values.get("output_s3_key_prefix")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def parameters(self) -> typing.Optional[IStringMapVariable]:
        '''(Optional) The required and optional parameters specified in the document.'''
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[IStringMapVariable], result)

    @builtins.property
    def service_role_arn(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The ARN of the AWS Identity and Access Management (IAM) role.'''
        result = self._values.get("service_role_arn")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunCommandStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RunDockerActionStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RunDockerActionStep",
):
    '''CommandStep implementation for aws:runDockerAction https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-rundockeraction.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        action: IStringVariable,
        cmd: typing.Optional[IStringVariable] = None,
        container: typing.Optional[IStringVariable] = None,
        cpu_shares: typing.Optional[IStringVariable] = None,
        env: typing.Optional[IStringVariable] = None,
        image: typing.Optional[IStringVariable] = None,
        memory: typing.Optional[IStringVariable] = None,
        publish: typing.Optional[IStringVariable] = None,
        user: typing.Optional[IStringVariable] = None,
        volume: typing.Optional[IStringListVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param action: 
        :param cmd: 
        :param container: 
        :param cpu_shares: 
        :param env: 
        :param image: 
        :param memory: 
        :param publish: 
        :param user: 
        :param volume: 
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7025b4621cf14573910a7a4e62d0350bd9dd72740d7d443e1106486be4143cd)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RunDockerActionStepProps(
            action=action,
            cmd=cmd,
            container=container,
            cpu_shares=cpu_shares,
            env=env,
            image=image,
            memory=memory,
            publish=publish,
            user=user,
            volume=volume,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="dockerAction")
    def docker_action(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "dockerAction"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="cmd")
    def cmd(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "cmd"))

    @builtins.property
    @jsii.member(jsii_name="container")
    def container(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "container"))

    @builtins.property
    @jsii.member(jsii_name="cpuShares")
    def cpu_shares(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "cpuShares"))

    @builtins.property
    @jsii.member(jsii_name="env")
    def env(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "env"))

    @builtins.property
    @jsii.member(jsii_name="image")
    def image(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "image"))

    @builtins.property
    @jsii.member(jsii_name="memory")
    def memory(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "memory"))

    @builtins.property
    @jsii.member(jsii_name="publish")
    def publish(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "publish"))

    @builtins.property
    @jsii.member(jsii_name="user")
    def user(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "user"))

    @builtins.property
    @jsii.member(jsii_name="volume")
    def volume(self) -> typing.Optional[IStringListVariable]:
        return typing.cast(typing.Optional[IStringListVariable], jsii.get(self, "volume"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RunDockerActionStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "action": "action",
        "cmd": "cmd",
        "container": "container",
        "cpu_shares": "cpuShares",
        "env": "env",
        "image": "image",
        "memory": "memory",
        "publish": "publish",
        "user": "user",
        "volume": "volume",
    },
)
class RunDockerActionStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        action: IStringVariable,
        cmd: typing.Optional[IStringVariable] = None,
        container: typing.Optional[IStringVariable] = None,
        cpu_shares: typing.Optional[IStringVariable] = None,
        env: typing.Optional[IStringVariable] = None,
        image: typing.Optional[IStringVariable] = None,
        memory: typing.Optional[IStringVariable] = None,
        publish: typing.Optional[IStringVariable] = None,
        user: typing.Optional[IStringVariable] = None,
        volume: typing.Optional[IStringListVariable] = None,
    ) -> None:
        '''
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param action: 
        :param cmd: 
        :param container: 
        :param cpu_shares: 
        :param env: 
        :param image: 
        :param memory: 
        :param publish: 
        :param user: 
        :param volume: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c69b288f04f11f0fbfce2b4cc9157d3b30ce1cfd5499ebd3c7d37a08567a40c)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument cmd", value=cmd, expected_type=type_hints["cmd"])
            check_type(argname="argument container", value=container, expected_type=type_hints["container"])
            check_type(argname="argument cpu_shares", value=cpu_shares, expected_type=type_hints["cpu_shares"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument memory", value=memory, expected_type=type_hints["memory"])
            check_type(argname="argument publish", value=publish, expected_type=type_hints["publish"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
            check_type(argname="argument volume", value=volume, expected_type=type_hints["volume"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "action": action,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if cmd is not None:
            self._values["cmd"] = cmd
        if container is not None:
            self._values["container"] = container
        if cpu_shares is not None:
            self._values["cpu_shares"] = cpu_shares
        if env is not None:
            self._values["env"] = env
        if image is not None:
            self._values["image"] = image
        if memory is not None:
            self._values["memory"] = memory
        if publish is not None:
            self._values["publish"] = publish
        if user is not None:
            self._values["user"] = user
        if volume is not None:
            self._values["volume"] = volume

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def action(self) -> IStringVariable:
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def cmd(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("cmd")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def container(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("container")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def cpu_shares(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("cpu_shares")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def env(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("env")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def image(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("image")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def memory(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("memory")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def publish(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("publish")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def user(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("user")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def volume(self) -> typing.Optional[IStringListVariable]:
        result = self._values.get("volume")
        return typing.cast(typing.Optional[IStringListVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunDockerActionStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RunDocumentStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RunDocumentStep",
):
    '''CommandStep implementation for aws:runDocument https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-rundocument.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        step_document: IRunDocumentLocation,
        document_parameters: typing.Optional[IStringMapVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param step_document: Document info containing document type and document path. Can be of type LocalRunDocument or SsmRunDocument.
        :param document_parameters: Parameters for the document.
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3e57789a5c52f59e7a761c95913ad47e4914de8542a2280f6c76df07719818a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RunDocumentStepProps(
            step_document=step_document,
            document_parameters=document_parameters,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="stepDocument")
    def step_document(self) -> IRunDocumentLocation:
        return typing.cast(IRunDocumentLocation, jsii.get(self, "stepDocument"))

    @builtins.property
    @jsii.member(jsii_name="documentParameters")
    def document_parameters(self) -> typing.Optional[IStringMapVariable]:
        return typing.cast(typing.Optional[IStringMapVariable], jsii.get(self, "documentParameters"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RunDocumentStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "step_document": "stepDocument",
        "document_parameters": "documentParameters",
    },
)
class RunDocumentStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        step_document: IRunDocumentLocation,
        document_parameters: typing.Optional[IStringMapVariable] = None,
    ) -> None:
        '''Properties for Run Document step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param step_document: Document info containing document type and document path. Can be of type LocalRunDocument or SsmRunDocument.
        :param document_parameters: Parameters for the document.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c4e8ceb3fb5bf644484b2c94b3f62aecacf84527c8f2802acd5f68f0afed92e2)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument step_document", value=step_document, expected_type=type_hints["step_document"])
            check_type(argname="argument document_parameters", value=document_parameters, expected_type=type_hints["document_parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "step_document": step_document,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if document_parameters is not None:
            self._values["document_parameters"] = document_parameters

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def step_document(self) -> IRunDocumentLocation:
        '''Document info containing document type and document path.

        Can be of type LocalRunDocument or SsmRunDocument.
        '''
        result = self._values.get("step_document")
        assert result is not None, "Required property 'step_document' is missing"
        return typing.cast(IRunDocumentLocation, result)

    @builtins.property
    def document_parameters(self) -> typing.Optional[IStringMapVariable]:
        '''Parameters for the document.'''
        result = self._values.get("document_parameters")
        return typing.cast(typing.Optional[IStringMapVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunDocumentStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RunInstanceStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RunInstanceStep",
):
    '''AutomationStep implemenation for aws:runInstance https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-runinstance.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        image_id: IStringVariable,
        additional_info: typing.Optional[IStringVariable] = None,
        block_device_mappings: typing.Optional[IMapListVariable] = None,
        client_token: typing.Optional[IStringVariable] = None,
        disable_api_termination: typing.Optional[IBooleanVariable] = None,
        ebs_optimized: typing.Optional[IBooleanVariable] = None,
        iam_instance_profile_arn: typing.Optional[IStringVariable] = None,
        iam_instance_profile_name: typing.Optional[IStringVariable] = None,
        instance_initiated_shutdown_behavior: typing.Optional[IStringVariable] = None,
        instance_type: typing.Optional[IStringVariable] = None,
        kernel_id: typing.Optional[IStringVariable] = None,
        key_name: typing.Optional[IStringVariable] = None,
        max_instance_count: typing.Optional[INumberVariable] = None,
        min_instance_count: typing.Optional[INumberVariable] = None,
        monitoring: typing.Optional[IBooleanVariable] = None,
        network_interfaces: typing.Optional[IMapListVariable] = None,
        placement: typing.Optional[IStringMapVariable] = None,
        private_ip_address: typing.Optional[IStringVariable] = None,
        ramdisk_id: typing.Optional[IStringVariable] = None,
        security_group_ids: typing.Optional[IStringListVariable] = None,
        security_groups: typing.Optional[IStringListVariable] = None,
        subnet_id: typing.Optional[IStringVariable] = None,
        tag_specifications: typing.Optional[IMapListVariable] = None,
        user_data: typing.Optional[IStringVariable] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param image_id: The ID of the Amazon Machine Image (AMI).
        :param additional_info: (Optional) Reserved.
        :param block_device_mappings: (Optional) The block devices for the instance.
        :param client_token: (Optional) The identifier to ensure idempotency of the request.
        :param disable_api_termination: (Optional) Turns on or turns off instance API termination.
        :param ebs_optimized: (Optional) Turns on or turns off Amazon Elastic Block Store (Amazon EBS) optimization.
        :param iam_instance_profile_arn: (Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) instance profile for the instance.
        :param iam_instance_profile_name: (Optional) The name of the IAM instance profile for the instance.
        :param instance_initiated_shutdown_behavior: (Optional) Indicates whether the instance stops or terminates on system shutdown.
        :param instance_type: (Optional) The instance type.
        :param kernel_id: (Optional) The ID of the kernel.
        :param key_name: (Optional) The name of the key pair.
        :param max_instance_count: (Optional) The maximum number of instances to be launched.
        :param min_instance_count: (Optional) The minimum number of instances to be launched.
        :param monitoring: (Optional) Turns on or turns off detailed monitoring.
        :param network_interfaces: (Optional) The network interfaces.
        :param placement: (Optional) The placement for the instance.
        :param private_ip_address: (Optional) The primary IPv4 address.
        :param ramdisk_id: (Optional) The ID of the RAM disk.
        :param security_group_ids: (Optional) The IDs of the security groups for the instance.
        :param security_groups: (Optional) The names of the security groups for the instance.
        :param subnet_id: (Optional) The subnet ID.
        :param tag_specifications: (Optional) The tags to apply to the resources during launch. You can only tag instances and volumes at launch. The specified tags are applied to all instances or volumes that are created during launch. To tag an instance after it has been launched, use the aws:createTags  Create tags for AWS resources action.
        :param user_data: (Optional) A script provided as a string literal value. If a literal value is entered, then it must be Base64-encoded.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae33577b7327b4b382e4eaed6434e8424b65f6c029e35ca2a4cc0056a650e65f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RunInstanceStepProps(
            image_id=image_id,
            additional_info=additional_info,
            block_device_mappings=block_device_mappings,
            client_token=client_token,
            disable_api_termination=disable_api_termination,
            ebs_optimized=ebs_optimized,
            iam_instance_profile_arn=iam_instance_profile_arn,
            iam_instance_profile_name=iam_instance_profile_name,
            instance_initiated_shutdown_behavior=instance_initiated_shutdown_behavior,
            instance_type=instance_type,
            kernel_id=kernel_id,
            key_name=key_name,
            max_instance_count=max_instance_count,
            min_instance_count=min_instance_count,
            monitoring=monitoring,
            network_interfaces=network_interfaces,
            placement=placement,
            private_ip_address=private_ip_address,
            ramdisk_id=ramdisk_id,
            security_group_ids=security_group_ids,
            security_groups=security_groups,
            subnet_id=subnet_id,
            tag_specifications=tag_specifications,
            user_data=user_data,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Derives the inputs based on given variables.

        :return: list of required inputs.
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.

        :return: IDs and states of the new instances
        '''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "imageId"))

    @builtins.property
    @jsii.member(jsii_name="additionalInfo")
    def additional_info(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "additionalInfo"))

    @builtins.property
    @jsii.member(jsii_name="blockDeviceMappings")
    def block_device_mappings(self) -> typing.Optional[IMapListVariable]:
        return typing.cast(typing.Optional[IMapListVariable], jsii.get(self, "blockDeviceMappings"))

    @builtins.property
    @jsii.member(jsii_name="clientToken")
    def client_token(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "clientToken"))

    @builtins.property
    @jsii.member(jsii_name="disableApiTermination")
    def disable_api_termination(self) -> typing.Optional[IBooleanVariable]:
        return typing.cast(typing.Optional[IBooleanVariable], jsii.get(self, "disableApiTermination"))

    @builtins.property
    @jsii.member(jsii_name="ebsOptimized")
    def ebs_optimized(self) -> typing.Optional[IBooleanVariable]:
        return typing.cast(typing.Optional[IBooleanVariable], jsii.get(self, "ebsOptimized"))

    @builtins.property
    @jsii.member(jsii_name="iamInstanceProfileArn")
    def iam_instance_profile_arn(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "iamInstanceProfileArn"))

    @builtins.property
    @jsii.member(jsii_name="iamInstanceProfileName")
    def iam_instance_profile_name(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "iamInstanceProfileName"))

    @builtins.property
    @jsii.member(jsii_name="instanceInitiatedShutdownBehavior")
    def instance_initiated_shutdown_behavior(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "instanceInitiatedShutdownBehavior"))

    @builtins.property
    @jsii.member(jsii_name="instanceType")
    def instance_type(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "instanceType"))

    @builtins.property
    @jsii.member(jsii_name="kernelId")
    def kernel_id(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "kernelId"))

    @builtins.property
    @jsii.member(jsii_name="keyName")
    def key_name(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "keyName"))

    @builtins.property
    @jsii.member(jsii_name="maxInstanceCount")
    def max_instance_count(self) -> typing.Optional[INumberVariable]:
        return typing.cast(typing.Optional[INumberVariable], jsii.get(self, "maxInstanceCount"))

    @builtins.property
    @jsii.member(jsii_name="minInstanceCount")
    def min_instance_count(self) -> typing.Optional[INumberVariable]:
        return typing.cast(typing.Optional[INumberVariable], jsii.get(self, "minInstanceCount"))

    @builtins.property
    @jsii.member(jsii_name="monitoring")
    def monitoring(self) -> typing.Optional[IBooleanVariable]:
        return typing.cast(typing.Optional[IBooleanVariable], jsii.get(self, "monitoring"))

    @builtins.property
    @jsii.member(jsii_name="networkInterfaces")
    def network_interfaces(self) -> typing.Optional[IMapListVariable]:
        return typing.cast(typing.Optional[IMapListVariable], jsii.get(self, "networkInterfaces"))

    @builtins.property
    @jsii.member(jsii_name="placement")
    def placement(self) -> typing.Optional[IStringMapVariable]:
        return typing.cast(typing.Optional[IStringMapVariable], jsii.get(self, "placement"))

    @builtins.property
    @jsii.member(jsii_name="privateIpAddress")
    def private_ip_address(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "privateIpAddress"))

    @builtins.property
    @jsii.member(jsii_name="ramdiskId")
    def ramdisk_id(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "ramdiskId"))

    @builtins.property
    @jsii.member(jsii_name="securityGroupIds")
    def security_group_ids(self) -> typing.Optional[IStringListVariable]:
        return typing.cast(typing.Optional[IStringListVariable], jsii.get(self, "securityGroupIds"))

    @builtins.property
    @jsii.member(jsii_name="securityGroups")
    def security_groups(self) -> typing.Optional[IStringListVariable]:
        return typing.cast(typing.Optional[IStringListVariable], jsii.get(self, "securityGroups"))

    @builtins.property
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "subnetId"))

    @builtins.property
    @jsii.member(jsii_name="tagSpecifications")
    def tag_specifications(self) -> typing.Optional[IMapListVariable]:
        return typing.cast(typing.Optional[IMapListVariable], jsii.get(self, "tagSpecifications"))

    @builtins.property
    @jsii.member(jsii_name="userData")
    def user_data(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "userData"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RunInstanceStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "image_id": "imageId",
        "additional_info": "additionalInfo",
        "block_device_mappings": "blockDeviceMappings",
        "client_token": "clientToken",
        "disable_api_termination": "disableApiTermination",
        "ebs_optimized": "ebsOptimized",
        "iam_instance_profile_arn": "iamInstanceProfileArn",
        "iam_instance_profile_name": "iamInstanceProfileName",
        "instance_initiated_shutdown_behavior": "instanceInitiatedShutdownBehavior",
        "instance_type": "instanceType",
        "kernel_id": "kernelId",
        "key_name": "keyName",
        "max_instance_count": "maxInstanceCount",
        "min_instance_count": "minInstanceCount",
        "monitoring": "monitoring",
        "network_interfaces": "networkInterfaces",
        "placement": "placement",
        "private_ip_address": "privateIpAddress",
        "ramdisk_id": "ramdiskId",
        "security_group_ids": "securityGroupIds",
        "security_groups": "securityGroups",
        "subnet_id": "subnetId",
        "tag_specifications": "tagSpecifications",
        "user_data": "userData",
    },
)
class RunInstanceStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        image_id: IStringVariable,
        additional_info: typing.Optional[IStringVariable] = None,
        block_device_mappings: typing.Optional[IMapListVariable] = None,
        client_token: typing.Optional[IStringVariable] = None,
        disable_api_termination: typing.Optional[IBooleanVariable] = None,
        ebs_optimized: typing.Optional[IBooleanVariable] = None,
        iam_instance_profile_arn: typing.Optional[IStringVariable] = None,
        iam_instance_profile_name: typing.Optional[IStringVariable] = None,
        instance_initiated_shutdown_behavior: typing.Optional[IStringVariable] = None,
        instance_type: typing.Optional[IStringVariable] = None,
        kernel_id: typing.Optional[IStringVariable] = None,
        key_name: typing.Optional[IStringVariable] = None,
        max_instance_count: typing.Optional[INumberVariable] = None,
        min_instance_count: typing.Optional[INumberVariable] = None,
        monitoring: typing.Optional[IBooleanVariable] = None,
        network_interfaces: typing.Optional[IMapListVariable] = None,
        placement: typing.Optional[IStringMapVariable] = None,
        private_ip_address: typing.Optional[IStringVariable] = None,
        ramdisk_id: typing.Optional[IStringVariable] = None,
        security_group_ids: typing.Optional[IStringListVariable] = None,
        security_groups: typing.Optional[IStringListVariable] = None,
        subnet_id: typing.Optional[IStringVariable] = None,
        tag_specifications: typing.Optional[IMapListVariable] = None,
        user_data: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties for RunInstanceStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param image_id: The ID of the Amazon Machine Image (AMI).
        :param additional_info: (Optional) Reserved.
        :param block_device_mappings: (Optional) The block devices for the instance.
        :param client_token: (Optional) The identifier to ensure idempotency of the request.
        :param disable_api_termination: (Optional) Turns on or turns off instance API termination.
        :param ebs_optimized: (Optional) Turns on or turns off Amazon Elastic Block Store (Amazon EBS) optimization.
        :param iam_instance_profile_arn: (Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) instance profile for the instance.
        :param iam_instance_profile_name: (Optional) The name of the IAM instance profile for the instance.
        :param instance_initiated_shutdown_behavior: (Optional) Indicates whether the instance stops or terminates on system shutdown.
        :param instance_type: (Optional) The instance type.
        :param kernel_id: (Optional) The ID of the kernel.
        :param key_name: (Optional) The name of the key pair.
        :param max_instance_count: (Optional) The maximum number of instances to be launched.
        :param min_instance_count: (Optional) The minimum number of instances to be launched.
        :param monitoring: (Optional) Turns on or turns off detailed monitoring.
        :param network_interfaces: (Optional) The network interfaces.
        :param placement: (Optional) The placement for the instance.
        :param private_ip_address: (Optional) The primary IPv4 address.
        :param ramdisk_id: (Optional) The ID of the RAM disk.
        :param security_group_ids: (Optional) The IDs of the security groups for the instance.
        :param security_groups: (Optional) The names of the security groups for the instance.
        :param subnet_id: (Optional) The subnet ID.
        :param tag_specifications: (Optional) The tags to apply to the resources during launch. You can only tag instances and volumes at launch. The specified tags are applied to all instances or volumes that are created during launch. To tag an instance after it has been launched, use the aws:createTags  Create tags for AWS resources action.
        :param user_data: (Optional) A script provided as a string literal value. If a literal value is entered, then it must be Base64-encoded.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5aa8846cdece2eb98372bab0b08f32012f7707cd49ecd3c64d4b35cd18ec0b7f)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument image_id", value=image_id, expected_type=type_hints["image_id"])
            check_type(argname="argument additional_info", value=additional_info, expected_type=type_hints["additional_info"])
            check_type(argname="argument block_device_mappings", value=block_device_mappings, expected_type=type_hints["block_device_mappings"])
            check_type(argname="argument client_token", value=client_token, expected_type=type_hints["client_token"])
            check_type(argname="argument disable_api_termination", value=disable_api_termination, expected_type=type_hints["disable_api_termination"])
            check_type(argname="argument ebs_optimized", value=ebs_optimized, expected_type=type_hints["ebs_optimized"])
            check_type(argname="argument iam_instance_profile_arn", value=iam_instance_profile_arn, expected_type=type_hints["iam_instance_profile_arn"])
            check_type(argname="argument iam_instance_profile_name", value=iam_instance_profile_name, expected_type=type_hints["iam_instance_profile_name"])
            check_type(argname="argument instance_initiated_shutdown_behavior", value=instance_initiated_shutdown_behavior, expected_type=type_hints["instance_initiated_shutdown_behavior"])
            check_type(argname="argument instance_type", value=instance_type, expected_type=type_hints["instance_type"])
            check_type(argname="argument kernel_id", value=kernel_id, expected_type=type_hints["kernel_id"])
            check_type(argname="argument key_name", value=key_name, expected_type=type_hints["key_name"])
            check_type(argname="argument max_instance_count", value=max_instance_count, expected_type=type_hints["max_instance_count"])
            check_type(argname="argument min_instance_count", value=min_instance_count, expected_type=type_hints["min_instance_count"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument network_interfaces", value=network_interfaces, expected_type=type_hints["network_interfaces"])
            check_type(argname="argument placement", value=placement, expected_type=type_hints["placement"])
            check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
            check_type(argname="argument ramdisk_id", value=ramdisk_id, expected_type=type_hints["ramdisk_id"])
            check_type(argname="argument security_group_ids", value=security_group_ids, expected_type=type_hints["security_group_ids"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument tag_specifications", value=tag_specifications, expected_type=type_hints["tag_specifications"])
            check_type(argname="argument user_data", value=user_data, expected_type=type_hints["user_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "image_id": image_id,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if additional_info is not None:
            self._values["additional_info"] = additional_info
        if block_device_mappings is not None:
            self._values["block_device_mappings"] = block_device_mappings
        if client_token is not None:
            self._values["client_token"] = client_token
        if disable_api_termination is not None:
            self._values["disable_api_termination"] = disable_api_termination
        if ebs_optimized is not None:
            self._values["ebs_optimized"] = ebs_optimized
        if iam_instance_profile_arn is not None:
            self._values["iam_instance_profile_arn"] = iam_instance_profile_arn
        if iam_instance_profile_name is not None:
            self._values["iam_instance_profile_name"] = iam_instance_profile_name
        if instance_initiated_shutdown_behavior is not None:
            self._values["instance_initiated_shutdown_behavior"] = instance_initiated_shutdown_behavior
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if kernel_id is not None:
            self._values["kernel_id"] = kernel_id
        if key_name is not None:
            self._values["key_name"] = key_name
        if max_instance_count is not None:
            self._values["max_instance_count"] = max_instance_count
        if min_instance_count is not None:
            self._values["min_instance_count"] = min_instance_count
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if network_interfaces is not None:
            self._values["network_interfaces"] = network_interfaces
        if placement is not None:
            self._values["placement"] = placement
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if ramdisk_id is not None:
            self._values["ramdisk_id"] = ramdisk_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications
        if user_data is not None:
            self._values["user_data"] = user_data

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[OnCancel]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[OnCancel], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def image_id(self) -> IStringVariable:
        '''The ID of the Amazon Machine Image (AMI).'''
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def additional_info(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Reserved.'''
        result = self._values.get("additional_info")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def block_device_mappings(self) -> typing.Optional[IMapListVariable]:
        '''(Optional) The block devices for the instance.'''
        result = self._values.get("block_device_mappings")
        return typing.cast(typing.Optional[IMapListVariable], result)

    @builtins.property
    def client_token(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The identifier to ensure idempotency of the request.'''
        result = self._values.get("client_token")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def disable_api_termination(self) -> typing.Optional[IBooleanVariable]:
        '''(Optional) Turns on or turns off instance API termination.'''
        result = self._values.get("disable_api_termination")
        return typing.cast(typing.Optional[IBooleanVariable], result)

    @builtins.property
    def ebs_optimized(self) -> typing.Optional[IBooleanVariable]:
        '''(Optional) Turns on or turns off Amazon Elastic Block Store (Amazon EBS) optimization.'''
        result = self._values.get("ebs_optimized")
        return typing.cast(typing.Optional[IBooleanVariable], result)

    @builtins.property
    def iam_instance_profile_arn(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) instance profile for the instance.'''
        result = self._values.get("iam_instance_profile_arn")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def iam_instance_profile_name(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The name of the IAM instance profile for the instance.'''
        result = self._values.get("iam_instance_profile_name")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def instance_initiated_shutdown_behavior(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Indicates whether the instance stops or terminates on system shutdown.'''
        result = self._values.get("instance_initiated_shutdown_behavior")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The instance type.'''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def kernel_id(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The ID of the kernel.'''
        result = self._values.get("kernel_id")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def key_name(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The name of the key pair.'''
        result = self._values.get("key_name")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def max_instance_count(self) -> typing.Optional[INumberVariable]:
        '''(Optional) The maximum number of instances to be launched.'''
        result = self._values.get("max_instance_count")
        return typing.cast(typing.Optional[INumberVariable], result)

    @builtins.property
    def min_instance_count(self) -> typing.Optional[INumberVariable]:
        '''(Optional) The minimum number of instances to be launched.'''
        result = self._values.get("min_instance_count")
        return typing.cast(typing.Optional[INumberVariable], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[IBooleanVariable]:
        '''(Optional) Turns on or turns off detailed monitoring.'''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[IBooleanVariable], result)

    @builtins.property
    def network_interfaces(self) -> typing.Optional[IMapListVariable]:
        '''(Optional) The network interfaces.'''
        result = self._values.get("network_interfaces")
        return typing.cast(typing.Optional[IMapListVariable], result)

    @builtins.property
    def placement(self) -> typing.Optional[IStringMapVariable]:
        '''(Optional) The placement for the instance.'''
        result = self._values.get("placement")
        return typing.cast(typing.Optional[IStringMapVariable], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The primary IPv4 address.'''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def ramdisk_id(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The ID of the RAM disk.'''
        result = self._values.get("ramdisk_id")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def security_group_ids(self) -> typing.Optional[IStringListVariable]:
        '''(Optional) The IDs of the security groups for the instance.'''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[IStringListVariable], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[IStringListVariable]:
        '''(Optional) The names of the security groups for the instance.'''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[IStringListVariable], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The subnet ID.'''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def tag_specifications(self) -> typing.Optional[IMapListVariable]:
        '''(Optional) The tags to apply to the resources during launch.

        You can only tag instances and volumes at launch. The specified tags are applied to all instances or volumes that are created during launch.
        To tag an instance after it has been launched, use the aws:createTags  Create tags for AWS resources action.
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[IMapListVariable], result)

    @builtins.property
    def user_data(self) -> typing.Optional[IStringVariable]:
        '''(Optional) A script provided as a string literal value.

        If a literal value is entered, then it must be Base64-encoded.
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunInstanceStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RunPowerShellScriptStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RunPowerShellScriptStep",
):
    '''AutomationStep implementation for aws:runPowerShellScript https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-runPowerShellScript.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        run_command: typing.Sequence[IStringVariable],
        timeout_seconds: typing.Optional[jsii.Number] = None,
        working_directory: typing.Optional[IStringVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param run_command: Specify the commands to run or the path to an existing script on the instance.
        :param timeout_seconds: (Optional) The time in seconds for a command to be completed before it's considered to have failed. When the timeout is reached, Systems Manager stops the command execution.
        :param working_directory: (Optional) The path to the working directory on your instance.
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b87d5aa383e45a5024cb67520e20e42ec8e41e502b38b74d1e326aaf11271f11)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RunPowerShellScriptStepProps(
            run_command=run_command,
            timeout_seconds=timeout_seconds,
            working_directory=working_directory,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Inputs required for this command includes both the runCommand variables and workingDirectory if provided.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="runCommand")
    def run_command(self) -> typing.List[IStringVariable]:
        return typing.cast(typing.List[IStringVariable], jsii.get(self, "runCommand"))

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "timeoutSeconds"))

    @builtins.property
    @jsii.member(jsii_name="workingDirectory")
    def working_directory(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "workingDirectory"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RunPowerShellScriptStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "run_command": "runCommand",
        "timeout_seconds": "timeoutSeconds",
        "working_directory": "workingDirectory",
    },
)
class RunPowerShellScriptStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        run_command: typing.Sequence[IStringVariable],
        timeout_seconds: typing.Optional[jsii.Number] = None,
        working_directory: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties for runPowerShellScript step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param run_command: Specify the commands to run or the path to an existing script on the instance.
        :param timeout_seconds: (Optional) The time in seconds for a command to be completed before it's considered to have failed. When the timeout is reached, Systems Manager stops the command execution.
        :param working_directory: (Optional) The path to the working directory on your instance.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9bbd636826934f2c6cd8e2332fc039ce4e5bee8d6ae92febb4e2144212896479)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument run_command", value=run_command, expected_type=type_hints["run_command"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument working_directory", value=working_directory, expected_type=type_hints["working_directory"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "run_command": run_command,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if working_directory is not None:
            self._values["working_directory"] = working_directory

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def run_command(self) -> typing.List[IStringVariable]:
        '''Specify the commands to run or the path to an existing script on the instance.'''
        result = self._values.get("run_command")
        assert result is not None, "Required property 'run_command' is missing"
        return typing.cast(typing.List[IStringVariable], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) The time in seconds for a command to be completed before it's considered to have failed.

        When the timeout is reached, Systems Manager stops the command execution.
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def working_directory(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The path to the working directory on your instance.'''
        result = self._values.get("working_directory")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunPowerShellScriptStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RunShellScriptStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.RunShellScriptStep",
):
    '''AutomationStep implemenation for aws:runShellScript https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-sleep.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        run_command: typing.Sequence[IStringVariable],
        timeout_seconds: typing.Optional[jsii.Number] = None,
        working_directory: typing.Optional[IStringVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param run_command: Specify the commands to run or the path to an existing script on the instance.
        :param timeout_seconds: (Optional) The time in seconds for a command to be completed before it's considered to have failed. When the timeout is reached, Systems Manager stops the command execution.
        :param working_directory: (Optional) The path to the working directory on your instance.
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81f8e051a3be67574c41343d7c1055cec31c28cb63ce9828dea32c9b65a8e95e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RunShellScriptStepProps(
            run_command=run_command,
            timeout_seconds=timeout_seconds,
            working_directory=working_directory,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Inputs required for this command includes both the runCommand variables and workingDirectory if provided.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="runCommand")
    def run_command(self) -> typing.List[IStringVariable]:
        return typing.cast(typing.List[IStringVariable], jsii.get(self, "runCommand"))

    @builtins.property
    @jsii.member(jsii_name="timeoutSeconds")
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "timeoutSeconds"))

    @builtins.property
    @jsii.member(jsii_name="workingDirectory")
    def working_directory(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "workingDirectory"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.RunShellScriptStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "run_command": "runCommand",
        "timeout_seconds": "timeoutSeconds",
        "working_directory": "workingDirectory",
    },
)
class RunShellScriptStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        run_command: typing.Sequence[IStringVariable],
        timeout_seconds: typing.Optional[jsii.Number] = None,
        working_directory: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties for sleep step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param run_command: Specify the commands to run or the path to an existing script on the instance.
        :param timeout_seconds: (Optional) The time in seconds for a command to be completed before it's considered to have failed. When the timeout is reached, Systems Manager stops the command execution.
        :param working_directory: (Optional) The path to the working directory on your instance.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f3ed3881420c6377aaac6e46a33e9664baed75e588ba6a8bffd45c1bcb65ea8)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument run_command", value=run_command, expected_type=type_hints["run_command"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument working_directory", value=working_directory, expected_type=type_hints["working_directory"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "run_command": run_command,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if working_directory is not None:
            self._values["working_directory"] = working_directory

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def run_command(self) -> typing.List[IStringVariable]:
        '''Specify the commands to run or the path to an existing script on the instance.'''
        result = self._values.get("run_command")
        assert result is not None, "Required property 'run_command' is missing"
        return typing.cast(typing.List[IStringVariable], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) The time in seconds for a command to be completed before it's considered to have failed.

        When the timeout is reached, Systems Manager stops the command execution.
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def working_directory(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The path to the working directory on your instance.'''
        result = self._values.get("working_directory")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunShellScriptStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SleepStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.SleepStep",
):
    '''AutomationStep implemenation for aws:sleep https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-sleep.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        sleep_seconds: jsii.Number,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param sleep_seconds: (Required) The amount of seconds to sleep for. May not exceed 604800. This will be used in the SSM doc as well as how long to indicate sleep to the sleepHook.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__886bbe5fdcfcd5afb75de9614bb1dea4a330f6a4f6cd3192d76c31709849cee9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SleepStepProps(
            sleep_seconds=sleep_seconds,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''No inputs required for Sleep step.

        :return: []
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''No outputs emitted from Sleep step.

        :return: []
        '''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="sleepSeconds")
    def sleep_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "sleepSeconds"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.SleepStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "sleep_seconds": "sleepSeconds",
    },
)
class SleepStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        sleep_seconds: jsii.Number,
    ) -> None:
        '''Properties for sleep step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param sleep_seconds: (Required) The amount of seconds to sleep for. May not exceed 604800. This will be used in the SSM doc as well as how long to indicate sleep to the sleepHook.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ffe9ee3514cf2409014c1b17509c9168a4dd0a3c3dd1edea5dbe4b356891b8f)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument sleep_seconds", value=sleep_seconds, expected_type=type_hints["sleep_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "sleep_seconds": sleep_seconds,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[OnCancel]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[OnCancel], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def sleep_seconds(self) -> jsii.Number:
        '''(Required) The amount of seconds to sleep for.

        May not exceed 604800.
        This will be used in the SSM doc as well as how long to indicate sleep to the sleepHook.
        '''
        result = self._values.get("sleep_seconds")
        assert result is not None, "Required property 'sleep_seconds' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SleepStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SoftwareInventoryStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.SoftwareInventoryStep",
):
    '''AutomationStep implemenation for aws:softwareInventory https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-softwareinventory.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        applications: typing.Optional[IStringVariable] = None,
        aws_components: typing.Optional[IStringVariable] = None,
        custom_inventory: typing.Optional[IStringVariable] = None,
        files: typing.Optional[IStringVariable] = None,
        instance_detailed_information: typing.Optional[IStringVariable] = None,
        network_config: typing.Optional[IStringVariable] = None,
        services: typing.Optional[IStringVariable] = None,
        windows_registry: typing.Optional[IStringVariable] = None,
        windows_roles: typing.Optional[IStringVariable] = None,
        windows_updates: typing.Optional[IStringVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param applications: (Optional) Collect metadata for installed applications.
        :param aws_components: (Optional) Collect metadata for AWS components like amazon-ssm-agent.
        :param custom_inventory: (Optional) Collect custom inventory data. For more information about custom inventory, see Working with custom inventory
        :param files: (Optional, requires SSM Agent version 2.2.64.0 or later) Collect metadata for files, including file names, the time files were created, the time files were last modified and accessed, and file sizes, to name a few. For more information about collecting file inventory, see Working with file and Windows registry.
        :param instance_detailed_information: (Optional) Collect more instance information than is provided by the default inventory plugin (aws:instanceInformation), including CPU model, speed, and the number of cores, to name a few.
        :param network_config: (Optional) Collect metadata for network configurations.
        :param services: (Optional, Windows OS only, requires SSM Agent version 2.2.64.0 or later) Collect metadata for service configurations.
        :param windows_registry: (Optional, Windows OS only, requires SSM Agent version 2.2.64.0 or later) Collect Windows Registry keys and values. You can choose a key path and collect all keys and values recursively. You can also collect a specific registry key and its value for a specific path. Inventory collects the key path, name, type, and the value. For more information about collecting Windows Registry inventory, see Working with file and Windows registry inventory.
        :param windows_roles: (Optional, Windows OS only, requires SSM Agent version 2.2.64.0 or later) Collect metadata for Microsoft Windows role configurations.
        :param windows_updates: (Optional) Collect metadata for all Windows updates.
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de56635f7635fb0e8266680528784ec2015a544b69557cb0c5b5f4fab17c4951)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SoftwareInventoryStepProps(
            applications=applications,
            aws_components=aws_components,
            custom_inventory=custom_inventory,
            files=files,
            instance_detailed_information=instance_detailed_information,
            network_config=network_config,
            services=services,
            windows_registry=windows_registry,
            windows_roles=windows_roles,
            windows_updates=windows_updates,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''All Inputs for this command are optional.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="applications")
    def applications(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "applications"))

    @builtins.property
    @jsii.member(jsii_name="awsComponents")
    def aws_components(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "awsComponents"))

    @builtins.property
    @jsii.member(jsii_name="customInventory")
    def custom_inventory(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "customInventory"))

    @builtins.property
    @jsii.member(jsii_name="files")
    def files(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "files"))

    @builtins.property
    @jsii.member(jsii_name="instanceDetailedInformation")
    def instance_detailed_information(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "instanceDetailedInformation"))

    @builtins.property
    @jsii.member(jsii_name="networkConfig")
    def network_config(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "networkConfig"))

    @builtins.property
    @jsii.member(jsii_name="services")
    def services(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "services"))

    @builtins.property
    @jsii.member(jsii_name="windowsRegistry")
    def windows_registry(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "windowsRegistry"))

    @builtins.property
    @jsii.member(jsii_name="windowsRoles")
    def windows_roles(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "windowsRoles"))

    @builtins.property
    @jsii.member(jsii_name="windowsUpdates")
    def windows_updates(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "windowsUpdates"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.SoftwareInventoryStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "applications": "applications",
        "aws_components": "awsComponents",
        "custom_inventory": "customInventory",
        "files": "files",
        "instance_detailed_information": "instanceDetailedInformation",
        "network_config": "networkConfig",
        "services": "services",
        "windows_registry": "windowsRegistry",
        "windows_roles": "windowsRoles",
        "windows_updates": "windowsUpdates",
    },
)
class SoftwareInventoryStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        applications: typing.Optional[IStringVariable] = None,
        aws_components: typing.Optional[IStringVariable] = None,
        custom_inventory: typing.Optional[IStringVariable] = None,
        files: typing.Optional[IStringVariable] = None,
        instance_detailed_information: typing.Optional[IStringVariable] = None,
        network_config: typing.Optional[IStringVariable] = None,
        services: typing.Optional[IStringVariable] = None,
        windows_registry: typing.Optional[IStringVariable] = None,
        windows_roles: typing.Optional[IStringVariable] = None,
        windows_updates: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties of SoftwareInventory step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param applications: (Optional) Collect metadata for installed applications.
        :param aws_components: (Optional) Collect metadata for AWS components like amazon-ssm-agent.
        :param custom_inventory: (Optional) Collect custom inventory data. For more information about custom inventory, see Working with custom inventory
        :param files: (Optional, requires SSM Agent version 2.2.64.0 or later) Collect metadata for files, including file names, the time files were created, the time files were last modified and accessed, and file sizes, to name a few. For more information about collecting file inventory, see Working with file and Windows registry.
        :param instance_detailed_information: (Optional) Collect more instance information than is provided by the default inventory plugin (aws:instanceInformation), including CPU model, speed, and the number of cores, to name a few.
        :param network_config: (Optional) Collect metadata for network configurations.
        :param services: (Optional, Windows OS only, requires SSM Agent version 2.2.64.0 or later) Collect metadata for service configurations.
        :param windows_registry: (Optional, Windows OS only, requires SSM Agent version 2.2.64.0 or later) Collect Windows Registry keys and values. You can choose a key path and collect all keys and values recursively. You can also collect a specific registry key and its value for a specific path. Inventory collects the key path, name, type, and the value. For more information about collecting Windows Registry inventory, see Working with file and Windows registry inventory.
        :param windows_roles: (Optional, Windows OS only, requires SSM Agent version 2.2.64.0 or later) Collect metadata for Microsoft Windows role configurations.
        :param windows_updates: (Optional) Collect metadata for all Windows updates.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e52ca2fb45d99d1f08554ec7c5084abe46d1b9e169241da50ddb8855cfd7f3a)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument applications", value=applications, expected_type=type_hints["applications"])
            check_type(argname="argument aws_components", value=aws_components, expected_type=type_hints["aws_components"])
            check_type(argname="argument custom_inventory", value=custom_inventory, expected_type=type_hints["custom_inventory"])
            check_type(argname="argument files", value=files, expected_type=type_hints["files"])
            check_type(argname="argument instance_detailed_information", value=instance_detailed_information, expected_type=type_hints["instance_detailed_information"])
            check_type(argname="argument network_config", value=network_config, expected_type=type_hints["network_config"])
            check_type(argname="argument services", value=services, expected_type=type_hints["services"])
            check_type(argname="argument windows_registry", value=windows_registry, expected_type=type_hints["windows_registry"])
            check_type(argname="argument windows_roles", value=windows_roles, expected_type=type_hints["windows_roles"])
            check_type(argname="argument windows_updates", value=windows_updates, expected_type=type_hints["windows_updates"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if applications is not None:
            self._values["applications"] = applications
        if aws_components is not None:
            self._values["aws_components"] = aws_components
        if custom_inventory is not None:
            self._values["custom_inventory"] = custom_inventory
        if files is not None:
            self._values["files"] = files
        if instance_detailed_information is not None:
            self._values["instance_detailed_information"] = instance_detailed_information
        if network_config is not None:
            self._values["network_config"] = network_config
        if services is not None:
            self._values["services"] = services
        if windows_registry is not None:
            self._values["windows_registry"] = windows_registry
        if windows_roles is not None:
            self._values["windows_roles"] = windows_roles
        if windows_updates is not None:
            self._values["windows_updates"] = windows_updates

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def applications(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Collect metadata for installed applications.'''
        result = self._values.get("applications")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def aws_components(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Collect metadata for AWS components like amazon-ssm-agent.'''
        result = self._values.get("aws_components")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def custom_inventory(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Collect custom inventory data.

        For more information about custom inventory, see Working with custom inventory
        '''
        result = self._values.get("custom_inventory")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def files(self) -> typing.Optional[IStringVariable]:
        '''(Optional, requires SSM Agent version 2.2.64.0 or later) Collect metadata for files, including file names, the time files were created, the time files were last modified and accessed, and file sizes, to name a few. For more information about collecting file inventory, see Working with file and Windows registry.'''
        result = self._values.get("files")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def instance_detailed_information(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Collect more instance information than is provided by the default inventory plugin (aws:instanceInformation), including CPU model, speed, and the number of cores, to name a few.'''
        result = self._values.get("instance_detailed_information")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def network_config(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Collect metadata for network configurations.'''
        result = self._values.get("network_config")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def services(self) -> typing.Optional[IStringVariable]:
        '''(Optional, Windows OS only, requires SSM Agent version 2.2.64.0 or later) Collect metadata for service configurations.'''
        result = self._values.get("services")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def windows_registry(self) -> typing.Optional[IStringVariable]:
        '''(Optional, Windows OS only, requires SSM Agent version 2.2.64.0 or later) Collect Windows Registry keys and values. You can choose a key path and collect all keys and values recursively. You can also collect a specific registry key and its value for a specific path. Inventory collects the key path, name, type, and the value. For more information about collecting Windows Registry inventory, see Working with file and Windows registry inventory.'''
        result = self._values.get("windows_registry")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def windows_roles(self) -> typing.Optional[IStringVariable]:
        '''(Optional, Windows OS only, requires SSM Agent version 2.2.64.0 or later) Collect metadata for Microsoft Windows role configurations.'''
        result = self._values.get("windows_roles")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def windows_updates(self) -> typing.Optional[IStringVariable]:
        '''(Optional) Collect metadata for all Windows updates.'''
        result = self._values.get("windows_updates")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SoftwareInventoryStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StepFallback(
    OnCancel,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.StepFallback",
):
    def __init__(
        self,
        step: AutomationStep,
        validate_step_action: builtins.bool,
    ) -> None:
        '''
        :param step: -
        :param validate_step_action: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9546d83a5b8960789ef896c0e4f82046a3c1acb109ce2b485a5ae2588eec31be)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
            check_type(argname="argument validate_step_action", value=validate_step_action, expected_type=type_hints["validate_step_action"])
        jsii.create(self.__class__, self, [step, validate_step_action])

    @jsii.member(jsii_name="stepToInvoke")
    def step_to_invoke(self, _current_step: AutomationStep) -> builtins.str:
        '''
        :param _current_step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f41e2bd80acf6e0d2f4d78c2d526578435203d0e8d6c61056cc504ff1f7d147)
            check_type(argname="argument _current_step", value=_current_step, expected_type=type_hints["_current_step"])
        return typing.cast(builtins.str, jsii.invoke(self, "stepToInvoke", [_current_step]))

    @jsii.member(jsii_name="toSsmValue")
    def to_ssm_value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "toSsmValue", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ILLEGAL_FALLBACK_ACTIONS")
    def ILLEGAL_FALLBACK_ACTIONS(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "ILLEGAL_FALLBACK_ACTIONS"))

    @builtins.property
    @jsii.member(jsii_name="step")
    def step(self) -> AutomationStep:
        return typing.cast(AutomationStep, jsii.get(self, "step"))


class StepNameFallback(
    OnCancel,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.StepNameFallback",
):
    def __init__(self, step: builtins.str, validate_step_action: builtins.bool) -> None:
        '''
        :param step: -
        :param validate_step_action: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8132a3162299d52ed3479ffe269b953acb516e7e09760ec6f9d41aaee9b0fe89)
            check_type(argname="argument step", value=step, expected_type=type_hints["step"])
            check_type(argname="argument validate_step_action", value=validate_step_action, expected_type=type_hints["validate_step_action"])
        jsii.create(self.__class__, self, [step, validate_step_action])

    @jsii.member(jsii_name="stepToInvoke")
    def step_to_invoke(self, current_step: AutomationStep) -> builtins.str:
        '''
        :param current_step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41aa8639e688d9fe19ea813059b960f0c6a6bcb293c2523c9d6d7bb75d8c8b35)
            check_type(argname="argument current_step", value=current_step, expected_type=type_hints["current_step"])
        return typing.cast(builtins.str, jsii.invoke(self, "stepToInvoke", [current_step]))

    @jsii.member(jsii_name="toSsmValue")
    def to_ssm_value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "toSsmValue", []))

    @builtins.property
    @jsii.member(jsii_name="step")
    def step(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "step"))

    @builtins.property
    @jsii.member(jsii_name="validateStepAction")
    def validate_step_action(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "validateStepAction"))


@jsii.implements(IStringListVariable)
class StringListVariable(
    GenericVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.StringListVariable",
):
    '''A string list variable reference.

    Used to resolve the value from step inputs.
    '''

    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f0eec48e869b2ef86c812f2f7c9dde81b535e1f8376fb83a58cedc2bc133625)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, reference: builtins.str) -> "StringListVariable":
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a78c47d6900f044455fb48a7655ebd81621a3803d2302b4af51a87a680afff9)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        return typing.cast("StringListVariable", jsii.sinvoke(cls, "of", [reference]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7ef1e2a792ef5837c8a78fb5750e9622c1dd9b840f6a8a2d1979469227c9979)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToStringList")
    def resolve_to_string_list(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.List[builtins.str]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8673c7dcc243406d34660e77cf80662966f18bd016cb66010866ec5a530f5763)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "resolveToStringList", [inputs]))


@jsii.implements(IStringMapVariable)
class StringMapVariable(
    GenericVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.StringMapVariable",
):
    '''A string map variable reference.

    Used to resolve the value from step inputs.
    '''

    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01785f5b03c5482d57ea333bd7b70afebd7cc5246039989726f1902916f90b81)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, reference: builtins.str) -> "StringMapVariable":
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62585f5db74bc9e70cf7256a77628eb77e67f81acd3c4eb172403521e1bbb0f2)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        return typing.cast("StringMapVariable", jsii.sinvoke(cls, "of", [reference]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0d4c3bf53f70e5a50c6a1ac78a79362246e172d8e30944f80930d619c0b796e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToStringMap")
    def resolve_to_string_map(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__15f3c09257b7ac07b5275b98194471e1582f57bae1153ec571d04fa4fe2cea3d)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "resolveToStringMap", [inputs]))


class StringStep(
    CompositeAutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.StringStep",
):
    '''StringStep allows for including a step from an existing automation document verbatim.

    This is useful in that it allows developers to integrate with existing document steps.
    This step can be used just as you would use any other Step including simulation and deployment.
    '''

    @jsii.member(jsii_name="fromJson")
    @builtins.classmethod
    def from_json(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        json: builtins.str,
    ) -> "StringStep":
        '''Builds a step object from a json declaration.

        You may cast the step afterword to the associated Step for this action
        if you wish to gain access to action specific functionality,

        :param scope: -
        :param json: -

        :return: Step associated with the provided activity.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e061d3f6995cdf022390b8d6c834c9e585f349e43cfa610c7df054f0bdd83ed2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument json", value=json, expected_type=type_hints["json"])
        return typing.cast("StringStep", jsii.sinvoke(cls, "fromJson", [scope, json]))

    @jsii.member(jsii_name="fromObject")
    @builtins.classmethod
    def from_object(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> "StringStep":
        '''Builds a step object from an object.

        You may cast the step afterword to the associated Step for this action
        if you wish to gain access to action specific functionality,

        :param scope: -
        :param props: -

        :return: Step associated with the provided activity.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9303d9813b6bb041633cd9e1ed713fe06d73f85827a94f2d462a9f5c76dc03a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast("StringStep", jsii.sinvoke(cls, "fromObject", [scope, props]))

    @jsii.member(jsii_name="fromYaml")
    @builtins.classmethod
    def from_yaml(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        input_yaml: builtins.str,
    ) -> "StringStep":
        '''Builds a step object from a yaml declaration.

        You may cast the step afterword to the associated Step for this action
        if you wish to gain access to action specific functionality,

        :param scope: -
        :param input_yaml: -

        :return: Step associated with the provided activity.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__902684dde795720c72918cf0b4e4dab5d71fc74cab535600af2e8c8617b27df7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument input_yaml", value=input_yaml, expected_type=type_hints["input_yaml"])
        return typing.cast("StringStep", jsii.sinvoke(cls, "fromYaml", [scope, input_yaml]))

    @jsii.member(jsii_name="addToDocument")
    def add_to_document(self, doc: AutomationDocumentBuilder) -> None:
        '''
        :param doc: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7440108fb4a4efb9bd2e5195ac80b6b7bef5d30169bacc5d29fdaed3d4bfb330)
            check_type(argname="argument doc", value=doc, expected_type=type_hints["doc"])
        return typing.cast(None, jsii.invoke(self, "addToDocument", [doc]))


@jsii.implements(IStringVariable)
class StringVariable(
    GenericVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.StringVariable",
):
    '''A string variable reference.

    Used to resolve the value from step inputs.
    '''

    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1670eea8bb7d6c7344e46fd6300930b26431a7d796947554518279ed0315197)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, reference: builtins.str) -> "StringVariable":
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e18102998bbc140be5364332238b767be316a33313fff276645f1597b7dfd847)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        return typing.cast("StringVariable", jsii.sinvoke(cls, "of", [reference]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bab88eabcbd7add1143916143b923d0170ef9c2bfe09b4d28850688e08af54f6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToString")
    def resolve_to_string(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.str:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f0169c6ec362ac785e1c438955a65b091963659260aa5c57a68f2223584f123)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveToString", [inputs]))


class TimedDocument(
    AutomationDocument,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.TimedDocument",
):
    def __init__(
        self,
        stage: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        doc_variables: typing.Optional[typing.Sequence[Input]] = None,
        assume_role: typing.Optional[IStringVariable] = None,
        description: typing.Optional[builtins.str] = None,
        doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
        doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
        document_format: typing.Optional[DocumentFormat] = None,
        document_name: typing.Optional[builtins.str] = None,
        header: typing.Optional[builtins.str] = None,
        requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        target_type: typing.Optional[builtins.str] = None,
        update_method: typing.Optional[builtins.str] = None,
        version_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param stage: -
        :param id: -
        :param doc_variables: (Optional) Custom document variables.
        :param assume_role: (Optional) Assume role to use for this document. If provided, this value MUST be included as one of the documentInput names.
        :param description: (Optional) Description of the document. Defaults to the document name.
        :param doc_inputs: (Optional) Inputs required by the document.
        :param doc_outputs: (Optional) Outputs to be emitted from the document. The outputs are placed in a StringSet called outputs (as is done in SSM). Default: []
        :param document_format: (Optional) Specifies whether this document should be written as YAML or JSON. Default: JSON
        :param document_name: (Optional) Name of the document. Will default to the id provided for the CDK node.
        :param header: (Optional) A Header/comment to include at the start of a YAML document. JSON documents do not support headers.
        :param requires: ``AWS::SSM::Document.Requires``.
        :param tags: ``AWS::SSM::Document.Tags``.
        :param target_type: ``AWS::SSM::Document.TargetType``.
        :param update_method: If the document resource you specify in your template already exists, this parameter determines whether a new version of the existing document is created, or the existing document is replaced. ``Replace`` is the default method. If you specify ``NewVersion`` for the ``UpdateMethod`` parameter, and the ``Name`` of the document does not match an existing resource, a new document is created. When you specify ``NewVersion`` , the default version of the document is changed to the newly created version.
        :param version_name: ``AWS::SSM::Document.VersionName``.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd25558475f757c18912232cfca993dbce6035e99538751024c3f5b478383a80)
            check_type(argname="argument stage", value=stage, expected_type=type_hints["stage"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AutomationDocumentProps(
            doc_variables=doc_variables,
            assume_role=assume_role,
            description=description,
            doc_inputs=doc_inputs,
            doc_outputs=doc_outputs,
            document_format=document_format,
            document_name=document_name,
            header=header,
            requires=requires,
            tags=tags,
            target_type=target_type,
            update_method=update_method,
            version_name=version_name,
        )

        jsii.create(self.__class__, self, [stage, id, props])

    @jsii.member(jsii_name="collectedSteps")
    def collected_steps(self) -> typing.List[AutomationStep]:
        return typing.cast(typing.List[AutomationStep], jsii.invoke(self, "collectedSteps", []))


class UpdateAgentStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.UpdateAgentStep",
):
    '''CommandStep implementation for aws:UpdateAgent https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-updateagent.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        agent_name: typing.Optional[IStringVariable] = None,
        allow_downgrade: typing.Optional[IBooleanVariable] = None,
        source: typing.Optional[IStringVariable] = None,
        source_region: typing.Optional[builtins.str] = None,
        target_version: typing.Optional[IStringVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param agent_name: EC2Config. This is the name of the agent that runs the EC2Config service. Default: EC2Config
        :param allow_downgrade: Allow the EC2Config service to be downgraded to an earlier version. If set to false, the service can be upgraded to newer versions only (default). If set to true, specify the earlier version.
        :param source: Must use one and only one of source or sourceRegion. The location where Systems Manager copies the version of EC2Config to install. You can't change this location.
        :param source_region: Must use one and only one of source or sourceRegion. If source is provided it will be used as is. If sourceRegion is provided it will populate source with https://s3.{sourceRegion}.amazonaws.com/aws-ssm-{sourceRegion}/manifest.json
        :param target_version: A specific version of the EC2Config service to install. If not specified, the service will be updated to the latest version.
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f419e1a3ba0d372a52656c2e408c019a63c633bad25b72b80280b2235c68b417)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = UpdateAgentStepProps(
            agent_name=agent_name,
            allow_downgrade=allow_downgrade,
            source=source,
            source_region=source_region,
            target_version=target_version,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Inputs required for this command include agentName allowDowngrade source and targetVersion if version other than latest is desired.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="agentName")
    def agent_name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "agentName"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="source")
    def source(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "source"))

    @builtins.property
    @jsii.member(jsii_name="allowDowngrade")
    def allow_downgrade(self) -> typing.Optional[IBooleanVariable]:
        return typing.cast(typing.Optional[IBooleanVariable], jsii.get(self, "allowDowngrade"))

    @builtins.property
    @jsii.member(jsii_name="targetVersion")
    def target_version(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "targetVersion"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.UpdateAgentStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "agent_name": "agentName",
        "allow_downgrade": "allowDowngrade",
        "source": "source",
        "source_region": "sourceRegion",
        "target_version": "targetVersion",
    },
)
class UpdateAgentStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        agent_name: typing.Optional[IStringVariable] = None,
        allow_downgrade: typing.Optional[IBooleanVariable] = None,
        source: typing.Optional[IStringVariable] = None,
        source_region: typing.Optional[builtins.str] = None,
        target_version: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties UpdateAgent step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param agent_name: EC2Config. This is the name of the agent that runs the EC2Config service. Default: EC2Config
        :param allow_downgrade: Allow the EC2Config service to be downgraded to an earlier version. If set to false, the service can be upgraded to newer versions only (default). If set to true, specify the earlier version.
        :param source: Must use one and only one of source or sourceRegion. The location where Systems Manager copies the version of EC2Config to install. You can't change this location.
        :param source_region: Must use one and only one of source or sourceRegion. If source is provided it will be used as is. If sourceRegion is provided it will populate source with https://s3.{sourceRegion}.amazonaws.com/aws-ssm-{sourceRegion}/manifest.json
        :param target_version: A specific version of the EC2Config service to install. If not specified, the service will be updated to the latest version.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d70fb83e6b71d73558c25a3680729607d61339d3bd6af016a698af71c2d5dcae)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument agent_name", value=agent_name, expected_type=type_hints["agent_name"])
            check_type(argname="argument allow_downgrade", value=allow_downgrade, expected_type=type_hints["allow_downgrade"])
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument source_region", value=source_region, expected_type=type_hints["source_region"])
            check_type(argname="argument target_version", value=target_version, expected_type=type_hints["target_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if agent_name is not None:
            self._values["agent_name"] = agent_name
        if allow_downgrade is not None:
            self._values["allow_downgrade"] = allow_downgrade
        if source is not None:
            self._values["source"] = source
        if source_region is not None:
            self._values["source_region"] = source_region
        if target_version is not None:
            self._values["target_version"] = target_version

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def agent_name(self) -> typing.Optional[IStringVariable]:
        '''EC2Config.

        This is the name of the agent that runs the EC2Config service.

        :default: EC2Config
        '''
        result = self._values.get("agent_name")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def allow_downgrade(self) -> typing.Optional[IBooleanVariable]:
        '''Allow the EC2Config service to be downgraded to an earlier version.

        If set to false, the service can be upgraded to newer versions only (default).
        If set to true, specify the earlier version.
        '''
        result = self._values.get("allow_downgrade")
        return typing.cast(typing.Optional[IBooleanVariable], result)

    @builtins.property
    def source(self) -> typing.Optional[IStringVariable]:
        '''Must use one and only one of source or sourceRegion.

        The location where Systems Manager copies the version of EC2Config to install. You can't change this location.
        '''
        result = self._values.get("source")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def source_region(self) -> typing.Optional[builtins.str]:
        '''Must use one and only one of source or sourceRegion.

        If source is provided it will be used as is.
        If sourceRegion is provided it will populate source with https://s3.{sourceRegion}.amazonaws.com/aws-ssm-{sourceRegion}/manifest.json
        '''
        result = self._values.get("source_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target_version(self) -> typing.Optional[IStringVariable]:
        '''A specific version of the EC2Config service to install.

        If not specified, the service will be updated to the latest version.
        '''
        result = self._values.get("target_version")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UpdateAgentStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class UpdateSSMAgentStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.UpdateSSMAgentStep",
):
    '''AutomationStep implemenation for aws:UpdateSsmAgent https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-updatessmagent.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        allow_downgrade: IBooleanVariable,
        agent_name: typing.Optional[IStringVariable] = None,
        source: typing.Optional[IStringVariable] = None,
        source_region: typing.Optional[builtins.str] = None,
        target_version: typing.Optional[IStringVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param allow_downgrade: Allow the SSM Agent to be downgraded to an earlier version. If set to false, the agent can be upgraded to newer versions only (default). If set to true, specify the earlier version.
        :param agent_name: amazon-ssm-agent. This is the name of the Systems Manager agent that processes requests and runs commands on the instance.
        :param source: Must use one and only one of source or sourceRegion. The location where Systems Manager copies the SSM Agent version to install. You can't change this location.
        :param source_region: Must use one and only one of source or sourceRegion. If source is provided it will be used as is. If sourceRegion is provided it will populate source with https://s3.{sourceRegion}.amazonaws.com/aws-ssm-{sourceRegion}/manifest.json
        :param target_version: A specific version of SSM Agent to install. If not specified, the agent will be updated to the latest version.
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78e4a64a81f48992a117f4220b17c237fc90339c5c0eaf45f5edb98806daa46f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = UpdateSSMAgentStepProps(
            allow_downgrade=allow_downgrade,
            agent_name=agent_name,
            source=source,
            source_region=source_region,
            target_version=target_version,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Inputs required for this command include agentName allowDowngrade source and targetVersion if version other than latest is desired.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="agentName")
    def agent_name(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "agentName"))

    @builtins.property
    @jsii.member(jsii_name="allowDowngrade")
    def allow_downgrade(self) -> IBooleanVariable:
        return typing.cast(IBooleanVariable, jsii.get(self, "allowDowngrade"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="source")
    def source(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "source"))

    @builtins.property
    @jsii.member(jsii_name="targetVersion")
    def target_version(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "targetVersion"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.UpdateSSMAgentStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "allow_downgrade": "allowDowngrade",
        "agent_name": "agentName",
        "source": "source",
        "source_region": "sourceRegion",
        "target_version": "targetVersion",
    },
)
class UpdateSSMAgentStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        allow_downgrade: IBooleanVariable,
        agent_name: typing.Optional[IStringVariable] = None,
        source: typing.Optional[IStringVariable] = None,
        source_region: typing.Optional[builtins.str] = None,
        target_version: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties UpdateAgent step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param allow_downgrade: Allow the SSM Agent to be downgraded to an earlier version. If set to false, the agent can be upgraded to newer versions only (default). If set to true, specify the earlier version.
        :param agent_name: amazon-ssm-agent. This is the name of the Systems Manager agent that processes requests and runs commands on the instance.
        :param source: Must use one and only one of source or sourceRegion. The location where Systems Manager copies the SSM Agent version to install. You can't change this location.
        :param source_region: Must use one and only one of source or sourceRegion. If source is provided it will be used as is. If sourceRegion is provided it will populate source with https://s3.{sourceRegion}.amazonaws.com/aws-ssm-{sourceRegion}/manifest.json
        :param target_version: A specific version of SSM Agent to install. If not specified, the agent will be updated to the latest version.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1615cf15d1d401aa8235505bdec1126b6d0f0521523b5e0c8747737290a621c5)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument allow_downgrade", value=allow_downgrade, expected_type=type_hints["allow_downgrade"])
            check_type(argname="argument agent_name", value=agent_name, expected_type=type_hints["agent_name"])
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument source_region", value=source_region, expected_type=type_hints["source_region"])
            check_type(argname="argument target_version", value=target_version, expected_type=type_hints["target_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "allow_downgrade": allow_downgrade,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if agent_name is not None:
            self._values["agent_name"] = agent_name
        if source is not None:
            self._values["source"] = source
        if source_region is not None:
            self._values["source_region"] = source_region
        if target_version is not None:
            self._values["target_version"] = target_version

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def allow_downgrade(self) -> IBooleanVariable:
        '''Allow the SSM Agent to be downgraded to an earlier version.

        If set to false, the agent can be upgraded to newer versions only (default).
        If set to true, specify the earlier version.
        '''
        result = self._values.get("allow_downgrade")
        assert result is not None, "Required property 'allow_downgrade' is missing"
        return typing.cast(IBooleanVariable, result)

    @builtins.property
    def agent_name(self) -> typing.Optional[IStringVariable]:
        '''amazon-ssm-agent.

        This is the name of the Systems Manager agent that processes requests and runs commands on the instance.
        '''
        result = self._values.get("agent_name")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def source(self) -> typing.Optional[IStringVariable]:
        '''Must use one and only one of source or sourceRegion.

        The location where Systems Manager copies the SSM Agent version to install. You can't change this location.
        '''
        result = self._values.get("source")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def source_region(self) -> typing.Optional[builtins.str]:
        '''Must use one and only one of source or sourceRegion.

        If source is provided it will be used as is.
        If sourceRegion is provided it will populate source with https://s3.{sourceRegion}.amazonaws.com/aws-ssm-{sourceRegion}/manifest.json
        '''
        result = self._values.get("source_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target_version(self) -> typing.Optional[IStringVariable]:
        '''A specific version of SSM Agent to install.

        If not specified, the agent will be updated to the latest version.
        '''
        result = self._values.get("target_version")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UpdateSSMAgentStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.UpdateVariableProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "variable_name": "variableName",
        "variable_value": "variableValue",
    },
)
class UpdateVariableProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        variable_name: builtins.str,
        variable_value: IGenericVariable,
    ) -> None:
        '''Properties for update variable step.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param variable_name: (Required) The name of the variable to be updated. Must use format ``variable:<variable name>``.
        :param variable_value: (Required) The value of the variable to be updated.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a21939076f80e3e3a259e33d35df6765e10f00da2234b93297cb9c1fea63199d)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument variable_name", value=variable_name, expected_type=type_hints["variable_name"])
            check_type(argname="argument variable_value", value=variable_value, expected_type=type_hints["variable_value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "variable_name": variable_name,
            "variable_value": variable_value,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[OnCancel]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[OnCancel], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def variable_name(self) -> builtins.str:
        '''(Required) The name of the variable to be updated.

        Must use format ``variable:<variable name>``.
        '''
        result = self._values.get("variable_name")
        assert result is not None, "Required property 'variable_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def variable_value(self) -> IGenericVariable:
        '''(Required) The value of the variable to be updated.'''
        result = self._values.get("variable_value")
        assert result is not None, "Required property 'variable_value' is missing"
        return typing.cast(IGenericVariable, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UpdateVariableProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class UpdateVariableStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.UpdateVariableStep",
):
    '''AutomationStep implementation for aws:updateVariable https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-update-variable.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        variable_name: builtins.str,
        variable_value: IGenericVariable,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param variable_name: (Required) The name of the variable to be updated. Must use format ``variable:<variable name>``.
        :param variable_value: (Required) The value of the variable to be updated.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0048d0826f1abdaf7744fd0eddd55439a14ca327ffa2432acfb1cf8d579d43c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = UpdateVariableProps(
            variable_name=variable_name,
            variable_value=variable_value,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''No outputs emitted from update variable step.

        :return: []
        '''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="variableName")
    def variable_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "variableName"))

    @builtins.property
    @jsii.member(jsii_name="variableValue")
    def variable_value(self) -> IGenericVariable:
        return typing.cast(IGenericVariable, jsii.get(self, "variableValue"))


class Abort(
    OnCancel,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.Abort",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="stepToInvoke")
    def step_to_invoke(self, _current_step: AutomationStep) -> builtins.str:
        '''
        :param _current_step: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b5f0b1b010f0b3a0e2a3068785f968d071e794e2b9fa1bb278a27c630238ae6)
            check_type(argname="argument _current_step", value=_current_step, expected_type=type_hints["_current_step"])
        return typing.cast(builtins.str, jsii.invoke(self, "stepToInvoke", [_current_step]))

    @jsii.member(jsii_name="toSsmValue")
    def to_ssm_value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "toSsmValue", []))


@jsii.implements(IActionVariable)
class ActionVariable(
    StringVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ActionVariable",
):
    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__510ff57af2b894f9a228ac383ce48b5d36c6d8e102c5924abdafd7cfbe64a276)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19bee8c11d86aa989695e635be116b201cdce97b9c19f615420ae2a8c22a36f0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @builtins.property
    @jsii.member(jsii_name="validValues")
    def valid_values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "validValues"))


class ApplicationsStep(
    CommandStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ApplicationsStep",
):
    '''CommandStep implemenation for aws:applications https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-plugins.html#aws-applications.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        action: IInstallUninstallRepairVariable,
        source: IStringVariable,
        parameters: typing.Optional[IStringVariable] = None,
        source_hash: typing.Optional[IStringVariable] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param action: 
        :param source: 
        :param parameters: 
        :param source_hash: 
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08a1574ecdae85548d3f165fd4c7a103252434da339d2f6c57f341b65f81cada)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApplicationsStepProps(
            action=action,
            source=source,
            parameters=parameters,
            source_hash=source_hash,
            exit_on_failure=exit_on_failure,
            exit_on_success=exit_on_success,
            finally_step=finally_step,
            mark_success_and_exit_on_failure=mark_success_and_exit_on_failure,
            on_cancel=on_cancel,
            precondition=precondition,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="installAction")
    def install_action(self) -> IInstallUninstallRepairVariable:
        return typing.cast(IInstallUninstallRepairVariable, jsii.get(self, "installAction"))

    @builtins.property
    @jsii.member(jsii_name="platforms")
    def platforms(self) -> typing.List[Platform]:
        return typing.cast(typing.List[Platform], jsii.get(self, "platforms"))

    @builtins.property
    @jsii.member(jsii_name="source")
    def source(self) -> IStringVariable:
        return typing.cast(IStringVariable, jsii.get(self, "source"))

    @builtins.property
    @jsii.member(jsii_name="parameters")
    def parameters(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "parameters"))

    @builtins.property
    @jsii.member(jsii_name="sourceHash")
    def source_hash(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "sourceHash"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ApplicationsStepProps",
    jsii_struct_bases=[CommandStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "exit_on_failure": "exitOnFailure",
        "exit_on_success": "exitOnSuccess",
        "finally_step": "finallyStep",
        "mark_success_and_exit_on_failure": "markSuccessAndExitOnFailure",
        "on_cancel": "onCancel",
        "precondition": "precondition",
        "action": "action",
        "source": "source",
        "parameters": "parameters",
        "source_hash": "sourceHash",
    },
)
class ApplicationsStepProps(CommandStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        exit_on_failure: typing.Optional[builtins.bool] = None,
        exit_on_success: typing.Optional[builtins.bool] = None,
        finally_step: typing.Optional[builtins.bool] = None,
        mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
        on_cancel: typing.Optional[Step] = None,
        precondition: typing.Optional[Precondition] = None,
        action: IInstallUninstallRepairVariable,
        source: IStringVariable,
        parameters: typing.Optional[IStringVariable] = None,
        source_hash: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param exit_on_failure: (Optional) Whether to exit the document execution after failed execution of this step. Finally step will be run. Default: false
        :param exit_on_success: (Optional) Whether to exit the document execution after successful execution of this step. Finally step will be run. Default: false
        :param finally_step: 
        :param mark_success_and_exit_on_failure: 
        :param on_cancel: (Optional) Step to jump to in the event that this step is cancelled. Default: undefined
        :param precondition: (Optional) A precondition to test before execution occurrs. When the precondition isn't met, the command step isn't executed. Default: undefined
        :param action: 
        :param source: 
        :param parameters: 
        :param source_hash: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__136bf2e2baea328a9796e94bface30ee8bc0c5f71d8ce7b58f25fd07b0c16937)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument exit_on_failure", value=exit_on_failure, expected_type=type_hints["exit_on_failure"])
            check_type(argname="argument exit_on_success", value=exit_on_success, expected_type=type_hints["exit_on_success"])
            check_type(argname="argument finally_step", value=finally_step, expected_type=type_hints["finally_step"])
            check_type(argname="argument mark_success_and_exit_on_failure", value=mark_success_and_exit_on_failure, expected_type=type_hints["mark_success_and_exit_on_failure"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument precondition", value=precondition, expected_type=type_hints["precondition"])
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument source_hash", value=source_hash, expected_type=type_hints["source_hash"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "action": action,
            "source": source,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if exit_on_failure is not None:
            self._values["exit_on_failure"] = exit_on_failure
        if exit_on_success is not None:
            self._values["exit_on_success"] = exit_on_success
        if finally_step is not None:
            self._values["finally_step"] = finally_step
        if mark_success_and_exit_on_failure is not None:
            self._values["mark_success_and_exit_on_failure"] = mark_success_and_exit_on_failure
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if precondition is not None:
            self._values["precondition"] = precondition
        if parameters is not None:
            self._values["parameters"] = parameters
        if source_hash is not None:
            self._values["source_hash"] = source_hash

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def exit_on_failure(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after failed execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exit_on_success(self) -> typing.Optional[builtins.bool]:
        '''(Optional) Whether to exit the document execution after successful execution of this step.

        Finally step will be run.

        :default: false
        '''
        result = self._values.get("exit_on_success")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def finally_step(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("finally_step")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mark_success_and_exit_on_failure(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("mark_success_and_exit_on_failure")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[Step]:
        '''(Optional) Step to jump to in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[Step], result)

    @builtins.property
    def precondition(self) -> typing.Optional[Precondition]:
        '''(Optional) A precondition to test before execution occurrs.

        When the precondition isn't met, the command step isn't executed.

        :default: undefined
        '''
        result = self._values.get("precondition")
        return typing.cast(typing.Optional[Precondition], result)

    @builtins.property
    def action(self) -> IInstallUninstallRepairVariable:
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast(IInstallUninstallRepairVariable, result)

    @builtins.property
    def source(self) -> IStringVariable:
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(IStringVariable, result)

    @builtins.property
    def parameters(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("parameters")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def source_hash(self) -> typing.Optional[IStringVariable]:
        result = self._values.get("source_hash")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationsStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApproveStep(
    AutomationStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ApproveStep",
):
    '''AutomationStep implementation for aws:approve https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-approve.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        approvers: IStringListVariable,
        message: typing.Optional[IStringVariable] = None,
        min_required_approvals: typing.Optional[INumberVariable] = None,
        notification_arn: typing.Optional[IStringVariable] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param approvers: A list of AWS authenticated principals who are able to either approve or reject the action. The maximum number of approvers is 10. You can specify principals by using any of the following formats: - An AWS Identity and Access Management (IAM) user name - An IAM user ARN - An IAM role ARN - An IAM assume role user ARN
        :param message: (Optional) The information you want to include in the Amazon SNS topic when the approval request is sent. The maximum message length is 4096 characters.
        :param min_required_approvals: (Optional) The minimum number of approvals required to resume the automation. If you don't specify a value, the system defaults to one. The value for this parameter must be a positive number. The value for this parameter can't exceed the number of approvers defined by the Approvers parameter.
        :param notification_arn: (Optional) The Amazon Resource Name (ARN of an Amazon Simple Notification Service (Amazon SNS) topic for Automation approvals. When you specify an aws:approve step in a runbook, Automation sends a message to this topic letting principals know that they must either approve or reject an Automation step. The title of the Amazon SNS topic must be prefixed with "Automation".
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__56c6313727da6b0bec1ee8ac80eed4db0906df91d88d008be2666163eea455a4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApproveStepProps(
            approvers=approvers,
            message=message,
            min_required_approvals=min_required_approvals,
            notification_arn=notification_arn,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listInputs")
    def list_inputs(self) -> typing.List[builtins.str]:
        '''Lists the inputs that are required for this step.'''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "listInputs", []))

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''Lists the outputs that will be returned from this step.'''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="provideDate")
    def _provide_date(self) -> datetime.datetime:
        '''Override to mock the date the reviewer approved.'''
        return typing.cast(datetime.datetime, jsii.invoke(self, "provideDate", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="approvers")
    def approvers(self) -> IStringListVariable:
        return typing.cast(IStringListVariable, jsii.get(self, "approvers"))

    @builtins.property
    @jsii.member(jsii_name="message")
    def message(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "message"))

    @builtins.property
    @jsii.member(jsii_name="minRequiredApprovals")
    def min_required_approvals(self) -> typing.Optional[INumberVariable]:
        return typing.cast(typing.Optional[INumberVariable], jsii.get(self, "minRequiredApprovals"))

    @builtins.property
    @jsii.member(jsii_name="notificationArn")
    def notification_arn(self) -> typing.Optional[IStringVariable]:
        return typing.cast(typing.Optional[IStringVariable], jsii.get(self, "notificationArn"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.ApproveStepProps",
    jsii_struct_bases=[AutomationStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "approvers": "approvers",
        "message": "message",
        "min_required_approvals": "minRequiredApprovals",
        "notification_arn": "notificationArn",
    },
)
class ApproveStepProps(AutomationStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        approvers: IStringListVariable,
        message: typing.Optional[IStringVariable] = None,
        min_required_approvals: typing.Optional[INumberVariable] = None,
        notification_arn: typing.Optional[IStringVariable] = None,
    ) -> None:
        '''Properties for ApproveStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param approvers: A list of AWS authenticated principals who are able to either approve or reject the action. The maximum number of approvers is 10. You can specify principals by using any of the following formats: - An AWS Identity and Access Management (IAM) user name - An IAM user ARN - An IAM role ARN - An IAM assume role user ARN
        :param message: (Optional) The information you want to include in the Amazon SNS topic when the approval request is sent. The maximum message length is 4096 characters.
        :param min_required_approvals: (Optional) The minimum number of approvals required to resume the automation. If you don't specify a value, the system defaults to one. The value for this parameter must be a positive number. The value for this parameter can't exceed the number of approvers defined by the Approvers parameter.
        :param notification_arn: (Optional) The Amazon Resource Name (ARN of an Amazon Simple Notification Service (Amazon SNS) topic for Automation approvals. When you specify an aws:approve step in a runbook, Automation sends a message to this topic letting principals know that they must either approve or reject an Automation step. The title of the Amazon SNS topic must be prefixed with "Automation".
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b669cf68225d1e3a91a8018db4eea78fe84d91535e247cae020ab550f190b2d)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument approvers", value=approvers, expected_type=type_hints["approvers"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument min_required_approvals", value=min_required_approvals, expected_type=type_hints["min_required_approvals"])
            check_type(argname="argument notification_arn", value=notification_arn, expected_type=type_hints["notification_arn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "approvers": approvers,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if message is not None:
            self._values["message"] = message
        if min_required_approvals is not None:
            self._values["min_required_approvals"] = min_required_approvals
        if notification_arn is not None:
            self._values["notification_arn"] = notification_arn

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[OnCancel]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[OnCancel], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def approvers(self) -> IStringListVariable:
        '''A list of AWS authenticated principals who are able to either approve or reject the action.

        The maximum number of approvers is 10.

        You can specify principals by using any of the following formats:

        - An AWS Identity and Access Management (IAM) user name
        - An IAM user ARN
        - An IAM role ARN
        - An IAM assume role user ARN
        '''
        result = self._values.get("approvers")
        assert result is not None, "Required property 'approvers' is missing"
        return typing.cast(IStringListVariable, result)

    @builtins.property
    def message(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The information you want to include in the Amazon SNS topic when the approval request is sent.

        The maximum message length is 4096 characters.
        '''
        result = self._values.get("message")
        return typing.cast(typing.Optional[IStringVariable], result)

    @builtins.property
    def min_required_approvals(self) -> typing.Optional[INumberVariable]:
        '''(Optional) The minimum number of approvals required to resume the automation.

        If you don't specify a value, the system defaults to one. The value for this parameter must be a positive number. The value for this parameter can't exceed the number of approvers defined by the Approvers parameter.
        '''
        result = self._values.get("min_required_approvals")
        return typing.cast(typing.Optional[INumberVariable], result)

    @builtins.property
    def notification_arn(self) -> typing.Optional[IStringVariable]:
        '''(Optional) The Amazon Resource Name (ARN of an Amazon Simple Notification Service (Amazon SNS) topic for Automation approvals.

        When you specify an aws:approve step in a runbook, Automation sends a message to this topic letting principals know that they must either approve or reject an Automation step. The title of the Amazon SNS topic must be prefixed with "Automation".
        '''
        result = self._values.get("notification_arn")
        return typing.cast(typing.Optional[IStringVariable], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApproveStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AssertAwsResourceStep(
    AwsApiStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.AssertAwsResourceStep",
):
    '''AutomationStep implementation of aws:assertAwsResourceProperty.

    https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-assertAwsResourceProperty.html
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        desired_values: typing.Sequence[builtins.str],
        selector: builtins.str,
        api_params: typing.Mapping[builtins.str, typing.Any],
        pascal_case_api: builtins.str,
        service: AwsService,
        java_script_api: typing.Optional[builtins.str] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param desired_values: (Required) Value extracted from AWS response desired to be one of these desired values.
        :param selector: (Required) Json path selector to extract value from AWS response.
        :param api_params: (Required) API Params to submit with the request to the api. You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}
        :param pascal_case_api: (Required) The AWS api represented in PascalCase. This value is used as-is in the SSM yaml/json. This is used as the default for javaScriptApi (see that param).
        :param service: (Required) The AWS service to be invoked.
        :param java_script_api: (Optional) The api as represented the AWS JavaScript API. This is usually lowerCamelCase. This is used in the simulation run to execute the AWS API against the JavaScript SDK. Default: - will use the camelCaseApi param and substitute the first character for lowercase by default.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e22bc24b203ef4809b9cd3d0c8e657857bbabb659bd99a0aaad5b30735525a1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AssertAwsResourceStepProps(
            desired_values=desired_values,
            selector=selector,
            api_params=api_params,
            pascal_case_api=pascal_case_api,
            service=service,
            java_script_api=java_script_api,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="listOutputs")
    def list_outputs(self) -> typing.List[Output]:
        '''There are no outputs for this step.

        :return: empty list
        '''
        return typing.cast(typing.List[Output], jsii.invoke(self, "listOutputs", []))

    @jsii.member(jsii_name="toSsmEntry")
    def to_ssm_entry(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Converts this step into an object to prepare for yaml/json representation of this step.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toSsmEntry", []))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="desiredValues")
    def desired_values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "desiredValues"))

    @builtins.property
    @jsii.member(jsii_name="selector")
    def selector(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "selector"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.AssertAwsResourceStepProps",
    jsii_struct_bases=[AwsInvocationProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "api_params": "apiParams",
        "pascal_case_api": "pascalCaseApi",
        "service": "service",
        "java_script_api": "javaScriptApi",
        "desired_values": "desiredValues",
        "selector": "selector",
    },
)
class AssertAwsResourceStepProps(AwsInvocationProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        api_params: typing.Mapping[builtins.str, typing.Any],
        pascal_case_api: builtins.str,
        service: AwsService,
        java_script_api: typing.Optional[builtins.str] = None,
        desired_values: typing.Sequence[builtins.str],
        selector: builtins.str,
    ) -> None:
        '''Properties for AssertAwsResourceStep.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param api_params: (Required) API Params to submit with the request to the api. You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}
        :param pascal_case_api: (Required) The AWS api represented in PascalCase. This value is used as-is in the SSM yaml/json. This is used as the default for javaScriptApi (see that param).
        :param service: (Required) The AWS service to be invoked.
        :param java_script_api: (Optional) The api as represented the AWS JavaScript API. This is usually lowerCamelCase. This is used in the simulation run to execute the AWS API against the JavaScript SDK. Default: - will use the camelCaseApi param and substitute the first character for lowercase by default.
        :param desired_values: (Required) Value extracted from AWS response desired to be one of these desired values.
        :param selector: (Required) Json path selector to extract value from AWS response.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d5db218805d4f4a95a0282144aa84d9b30754fd94e52f48a09c2e196ceff894)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument api_params", value=api_params, expected_type=type_hints["api_params"])
            check_type(argname="argument pascal_case_api", value=pascal_case_api, expected_type=type_hints["pascal_case_api"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument java_script_api", value=java_script_api, expected_type=type_hints["java_script_api"])
            check_type(argname="argument desired_values", value=desired_values, expected_type=type_hints["desired_values"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_params": api_params,
            "pascal_case_api": pascal_case_api,
            "service": service,
            "desired_values": desired_values,
            "selector": selector,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if java_script_api is not None:
            self._values["java_script_api"] = java_script_api

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[OnCancel]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[OnCancel], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def api_params(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''(Required) API Params to submit with the request to the api.

        You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}

        Example::

            { 'VolumeIds': ['{{ EbsDescribeInstance.VolumeId }}'] }
        '''
        result = self._values.get("api_params")
        assert result is not None, "Required property 'api_params' is missing"
        return typing.cast(typing.Mapping[builtins.str, typing.Any], result)

    @builtins.property
    def pascal_case_api(self) -> builtins.str:
        '''(Required) The AWS api represented in PascalCase.

        This value is used as-is in the SSM yaml/json.
        This is used as the default for javaScriptApi (see that param).

        Example::

            DescribeInstances
        '''
        result = self._values.get("pascal_case_api")
        assert result is not None, "Required property 'pascal_case_api' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> AwsService:
        '''(Required) The AWS service to be invoked.

        Example::

            AwsService.S3
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(AwsService, result)

    @builtins.property
    def java_script_api(self) -> typing.Optional[builtins.str]:
        '''(Optional) The api as represented the AWS JavaScript API.

        This is usually lowerCamelCase.
        This is used in the simulation run to execute the AWS API against the JavaScript SDK.

        :default: - will use the camelCaseApi param and substitute the first character for lowercase by default.

        Example::

            describeInstances
        '''
        result = self._values.get("java_script_api")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def desired_values(self) -> typing.List[builtins.str]:
        '''(Required) Value extracted from AWS response desired to be one of these desired values.'''
        result = self._values.get("desired_values")
        assert result is not None, "Required property 'desired_values' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def selector(self) -> builtins.str:
        '''(Required) Json path selector to extract value from AWS response.'''
        result = self._values.get("selector")
        assert result is not None, "Required property 'selector' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AssertAwsResourceStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.AwsApiStepProps",
    jsii_struct_bases=[AwsInvocationProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "api_params": "apiParams",
        "pascal_case_api": "pascalCaseApi",
        "service": "service",
        "java_script_api": "javaScriptApi",
        "outputs": "outputs",
    },
)
class AwsApiStepProps(AwsInvocationProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        api_params: typing.Mapping[builtins.str, typing.Any],
        pascal_case_api: builtins.str,
        service: AwsService,
        java_script_api: typing.Optional[builtins.str] = None,
        outputs: typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Properties for AwsInvocation.

        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param api_params: (Required) API Params to submit with the request to the api. You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}
        :param pascal_case_api: (Required) The AWS api represented in PascalCase. This value is used as-is in the SSM yaml/json. This is used as the default for javaScriptApi (see that param).
        :param service: (Required) The AWS service to be invoked.
        :param java_script_api: (Optional) The api as represented the AWS JavaScript API. This is usually lowerCamelCase. This is used in the simulation run to execute the AWS API against the JavaScript SDK. Default: - will use the camelCaseApi param and substitute the first character for lowercase by default.
        :param outputs: (Required) specify the outputs to extract from the JavaScript JSON response.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b91281414afbedbf69038929e84c6b2a49b684b1945e545f26700d9e02a2d77f)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument api_params", value=api_params, expected_type=type_hints["api_params"])
            check_type(argname="argument pascal_case_api", value=pascal_case_api, expected_type=type_hints["pascal_case_api"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument java_script_api", value=java_script_api, expected_type=type_hints["java_script_api"])
            check_type(argname="argument outputs", value=outputs, expected_type=type_hints["outputs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_params": api_params,
            "pascal_case_api": pascal_case_api,
            "service": service,
            "outputs": outputs,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if java_script_api is not None:
            self._values["java_script_api"] = java_script_api

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[OnCancel]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[OnCancel], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def api_params(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''(Required) API Params to submit with the request to the api.

        You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}

        Example::

            { 'VolumeIds': ['{{ EbsDescribeInstance.VolumeId }}'] }
        '''
        result = self._values.get("api_params")
        assert result is not None, "Required property 'api_params' is missing"
        return typing.cast(typing.Mapping[builtins.str, typing.Any], result)

    @builtins.property
    def pascal_case_api(self) -> builtins.str:
        '''(Required) The AWS api represented in PascalCase.

        This value is used as-is in the SSM yaml/json.
        This is used as the default for javaScriptApi (see that param).

        Example::

            DescribeInstances
        '''
        result = self._values.get("pascal_case_api")
        assert result is not None, "Required property 'pascal_case_api' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> AwsService:
        '''(Required) The AWS service to be invoked.

        Example::

            AwsService.S3
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(AwsService, result)

    @builtins.property
    def java_script_api(self) -> typing.Optional[builtins.str]:
        '''(Optional) The api as represented the AWS JavaScript API.

        This is usually lowerCamelCase.
        This is used in the simulation run to execute the AWS API against the JavaScript SDK.

        :default: - will use the camelCaseApi param and substitute the first character for lowercase by default.

        Example::

            describeInstances
        '''
        result = self._values.get("java_script_api")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def outputs(self) -> typing.List[Output]:
        '''(Required) specify the outputs to extract from the JavaScript JSON response.'''
        result = self._values.get("outputs")
        assert result is not None, "Required property 'outputs' is missing"
        return typing.cast(typing.List[Output], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AwsApiStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IBooleanVariable)
class BooleanVariable(
    GenericVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.BooleanVariable",
):
    '''A boolean variable reference.

    Used to resolve the value from step inputs.
    '''

    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6c13815b1fa05199fe64475fd4851510e39530c1f1b7bc11bdada06a9989a35)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, reference: builtins.str) -> "BooleanVariable":
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f27bb4d11185b740ac5d46a699ead1a039f888044207642375917b0f292c1e3)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        return typing.cast("BooleanVariable", jsii.sinvoke(cls, "of", [reference]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef9d78fbd94c1db58a4273bfb57f1d5aadbb07ff1d95db77b7a4f46925a2fda8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToBoolean")
    def resolve_to_boolean(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.bool:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a295e96edb52227da27d11831a4ef807a3bb3e43d005fffac613d70df501539)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(builtins.bool, jsii.invoke(self, "resolveToBoolean", [inputs]))


@jsii.implements(IDesiredStateVariable)
class DesiredStateVariable(
    StringVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DesiredStateVariable",
):
    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4267f843d172e6d3e8618337be16c0d98b9681dad51ea659bd03a11131d71323)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd85be8a97db3ee21cd9423aacc45a86913f096aab23e12a1db836ce32e6839b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @builtins.property
    @jsii.member(jsii_name="validValues")
    def valid_values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "validValues"))


@jsii.implements(IDocumentHashTypeVariable)
class DocumentHashTypeVariable(
    StringVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.DocumentHashTypeVariable",
):
    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb0ae3dddba8a1c30a1858bfdcbf1cb9428a1ed404cecbd07017973ec7f8f28e)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce3d0cc0f5ab6192ed547615c9fdde98566fb4976944dfa2e8e59194f34263bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @builtins.property
    @jsii.member(jsii_name="validValues")
    def valid_values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "validValues"))


@jsii.implements(IBooleanVariable)
class HardCodedBoolean(
    HardCodedValueBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedBoolean",
):
    '''A hard-coded boolean variable.

    Used when not dependent on step inputs.
    '''

    def __init__(self, val: typing.Any) -> None:
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c16d8d5cb28aeb7a4c94c247ebf213f9650d38461538b56f412558bcfe46d7b8)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        jsii.create(self.__class__, self, [val])

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__271d795c03776c1b6e5db4ed4f7f3e8c6cde9de371139c2d1f53c9f705827269)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToBoolean")
    def resolve_to_boolean(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.bool:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3144a64c4c4ea88d4a2ae3e503a03b4768bf2d2040c91d2832650211622065b2)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(builtins.bool, jsii.invoke(self, "resolveToBoolean", [inputs]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="FALSE")
    def FALSE(cls) -> "HardCodedBoolean":
        return typing.cast("HardCodedBoolean", jsii.sget(cls, "FALSE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="TRUE")
    def TRUE(cls) -> "HardCodedBoolean":
        return typing.cast("HardCodedBoolean", jsii.sget(cls, "TRUE"))


@jsii.implements(IMapListVariable)
class HardCodedMapList(
    HardCodedValueBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedMapList",
):
    '''A hard-coded map list variable.

    Used when not dependent on step inputs.
    '''

    def __init__(self, val: typing.Any) -> None:
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b0a71dd7fbf2b47c145c424c48c7f5b3efef6f00e02e0c0629bf7d3aaee873d)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        jsii.create(self.__class__, self, [val])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(
        cls,
        val: typing.Sequence[typing.Mapping[builtins.str, typing.Any]],
    ) -> "HardCodedMapList":
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3b54250baff25d9653fcbdf8f750c0aebd6a544dfc96cfb6d5397a6e5c7620e)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        return typing.cast("HardCodedMapList", jsii.sinvoke(cls, "of", [val]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f80da4a8765eb1b1705bfb88a584bafd3616a12243f5368c54c57f9a5fb42580)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToMapList")
    def resolve_to_map_list(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.List[typing.Mapping[builtins.str, typing.Any]]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f60574f51857768ceb70ecefa34e85727bbeb17057b7ec51632026bd54d04470)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.List[typing.Mapping[builtins.str, typing.Any]], jsii.invoke(self, "resolveToMapList", [inputs]))


@jsii.implements(INumberVariable)
class HardCodedNumber(
    HardCodedValueBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedNumber",
):
    '''A hard-coded number variable.

    Used when not dependent on step inputs.
    '''

    def __init__(self, val: typing.Any) -> None:
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__234ac17e40662af208236ba6171c29a53219ca1f4d2b0f63c5d079582c3e9338)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        jsii.create(self.__class__, self, [val])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, val: jsii.Number) -> "HardCodedNumber":
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0944a57d06e0d1e12107f3312191d384c8dfc72657fe1517cee1c38d4e77a663)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        return typing.cast("HardCodedNumber", jsii.sinvoke(cls, "of", [val]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28bc1b5138b3b9dd8d990bc9fe1280201145d47f036f49bb3d066b56f5690378)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToNumber")
    def resolve_to_number(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> jsii.Number:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__414922d52e00bc4bd49eb6aab307ac0a891a2e9c87ddb3e164d5a0daea2efacd)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(jsii.Number, jsii.invoke(self, "resolveToNumber", [inputs]))


@jsii.implements(IStringVariable)
class HardCodedString(
    HardCodedValueBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedString",
):
    '''A hard-coded string variable.

    Used when not dependent on step inputs.
    '''

    def __init__(self, val: typing.Any) -> None:
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54499f8ba88672d8661a98fdacc683a12c6247fd15bb80279cffecdbbb7cc9b2)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        jsii.create(self.__class__, self, [val])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, val: builtins.str) -> "HardCodedString":
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__245c22562d52647b98c55b0029eca2cce14ec4e295a8342a7585d745605648b2)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        return typing.cast("HardCodedString", jsii.sinvoke(cls, "of", [val]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a81c2c02ea74a5073cf1427d5bae3aab7fafbe443b6a4ebbdc44a47d6724fc2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToString")
    def resolve_to_string(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.str:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82d35b9921edfb6d0873ef8c6e45cab75f36f2b670992fd4ff5510d600f0c3d6)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveToString", [inputs]))


@jsii.implements(IStringListVariable)
class HardCodedStringList(
    HardCodedValueBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedStringList",
):
    '''A hard-coded string list variable.

    Used when not dependent on step inputs.
    '''

    def __init__(self, val: typing.Any) -> None:
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f53b9667e749c7df5b736aa78954775fa4e0369d4bb8271cb6e955d99455f6f2)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        jsii.create(self.__class__, self, [val])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, val: typing.Sequence[builtins.str]) -> "HardCodedStringList":
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8920108546802fcb062cd3d90c8b1c5e3a96cddbcc3e579c0c35c4a99f3893b9)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        return typing.cast("HardCodedStringList", jsii.sinvoke(cls, "of", [val]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f9953fca1464700a97df905e75abd9e1212b4515768dc4d4f8c6f31c4f48091)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToStringList")
    def resolve_to_string_list(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.List[builtins.str]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ab95d898a5c1aa9cc6e773c4322e6095bca6370df8a84655796bbffeea5f756)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "resolveToStringList", [inputs]))


@jsii.implements(IStringMapVariable)
class HardCodedStringMap(
    HardCodedValueBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedStringMap",
):
    '''A hard-coded string map variable.

    Used when not dependent on step inputs.
    '''

    def __init__(self, val: typing.Any) -> None:
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7c8e0877e483742a427cb002024665ad11f02a416cb349de21de3c20f72182a)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        jsii.create(self.__class__, self, [val])

    @jsii.member(jsii_name="of")
    @builtins.classmethod
    def of(cls, val: typing.Mapping[builtins.str, typing.Any]) -> "HardCodedStringMap":
        '''
        :param val: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cde433b6be72f9adf4d74db4e0d9883f0b2893317c3220530f844b943061f28e)
            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
        return typing.cast("HardCodedStringMap", jsii.sinvoke(cls, "of", [val]))

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a7e058922650560856aecae39be57839674628afbf2b45207a0f809745ff7a10)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @jsii.member(jsii_name="resolveToStringMap")
    def resolve_to_string_map(
        self,
        inputs: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''Given the execution inputs, return the resolved value of this variable.

        :param inputs: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2445031dc943c6c68d2783b128f4c8b933d3cb7c40db4907d97d7ff10e610891)
            check_type(argname="argument inputs", value=inputs, expected_type=type_hints["inputs"])
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "resolveToStringMap", [inputs]))


@jsii.implements(IInstallUninstallRepairVariable)
class InstallUninstallRepairVariable(
    StringVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.InstallUninstallRepairVariable",
):
    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c972de50a1de08d5a31ef8662661fc767ae3e60d9d81b08ec949ef168352d329)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__341e45c7dc8db0e587e6f86c62825b22bb2d567b3178e52b2e302db38aeaa5ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @builtins.property
    @jsii.member(jsii_name="validValues")
    def valid_values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "validValues"))


@jsii.implements(IInstallationTypeVariable)
class InstallationTypeVariable(
    StringVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.InstallationTypeVariable",
):
    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad9e09468c4409156031a40fd40bcf896619f54c7ca68e51e47ddce006e952fd)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f17321d5f6e513a58dad0a5e441c9cf2cead21ca7c8648932c95f13c433e26d4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @builtins.property
    @jsii.member(jsii_name="validValues")
    def valid_values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "validValues"))


@jsii.implements(IOnFailureVariable)
class OnFailureVariable(
    StringVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.OnFailureVariable",
):
    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02427177ca3d6190561c84cf47c2e7531466455554fde4071e12de365df126d4)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12c2faf937142e3595853700f6698ee5221da5b549420a316af4756cf175623b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @builtins.property
    @jsii.member(jsii_name="validValues")
    def valid_values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "validValues"))


@jsii.implements(IPackageNameVariable)
class PackageNameVariable(
    StringVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.PackageNameVariable",
):
    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7aecc2c0562f3e016e8670cece3ce32104aacb864027386482057a1e1383a0f)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8dbaa57485d60791311effb02e995dc7d359eeaaf9a5eef949eb45a2d6bc645f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @builtins.property
    @jsii.member(jsii_name="validValues")
    def valid_values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "validValues"))


@jsii.implements(IResourceTypeVariable)
class ResourceTypeVariable(
    StringVariable,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.ResourceTypeVariable",
):
    def __init__(self, reference: builtins.str) -> None:
        '''
        :param reference: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bac15cf0a5b21c54a2a868cef251f4c3af2581545f4e7379c07229a39f511667)
            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
        jsii.create(self.__class__, self, [reference])

    @jsii.member(jsii_name="assertType")
    def _assert_type(self, value: typing.Any) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fda08275e38eff10cec2f35c379a0c289c4723e6a41b9e1f99b00368971e81e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "assertType", [value]))

    @builtins.property
    @jsii.member(jsii_name="validValues")
    def valid_values(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "validValues"))


class WaitForResourceStep(
    AssertAwsResourceStep,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.WaitForResourceStep",
):
    '''AutomationStep impl for aws:waitForAwsResourceProperty https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-action-waitForAwsResourceProperty.html.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        sleep_interval_millis: typing.Optional[jsii.Number] = None,
        desired_values: typing.Sequence[builtins.str],
        selector: builtins.str,
        api_params: typing.Mapping[builtins.str, typing.Any],
        pascal_case_api: builtins.str,
        service: AwsService,
        java_script_api: typing.Optional[builtins.str] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param sleep_interval_millis: (Optional) How much time to sleep after not receiving desired response from AWS SDK. This is only used for the run simulation. This is not used by SSM and is therefore not declared in the SSM yaml/json. Default: 2000 millis
        :param desired_values: (Required) Value extracted from AWS response desired to be one of these desired values.
        :param selector: (Required) Json path selector to extract value from AWS response.
        :param api_params: (Required) API Params to submit with the request to the api. You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}
        :param pascal_case_api: (Required) The AWS api represented in PascalCase. This value is used as-is in the SSM yaml/json. This is used as the default for javaScriptApi (see that param).
        :param service: (Required) The AWS service to be invoked.
        :param java_script_api: (Optional) The api as represented the AWS JavaScript API. This is usually lowerCamelCase. This is used in the simulation run to execute the AWS API against the JavaScript SDK. Default: - will use the camelCaseApi param and substitute the first character for lowercase by default.
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b54dff4afcc630be826b78f85caaafeab25c1421bdd1fe62d62ca3ac3b88a827)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = WaitForResourceStepProps(
            sleep_interval_millis=sleep_interval_millis,
            desired_values=desired_values,
            selector=selector,
            api_params=api_params,
            pascal_case_api=pascal_case_api,
            service=service,
            java_script_api=java_script_api,
            explicit_next_step=explicit_next_step,
            is_end=is_end,
            max_attempts=max_attempts,
            on_cancel=on_cancel,
            on_failure=on_failure,
            timeout_seconds=timeout_seconds,
            user_outputs=user_outputs,
            description=description,
            input_observer=input_observer,
            name=name,
            output_observer=output_observer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @builtins.property
    @jsii.member(jsii_name="sleepIntervalMillis")
    def sleep_interval_millis(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "sleepIntervalMillis"))


@jsii.data_type(
    jsii_type="@cdklabs/cdk-ssm-documents.WaitForResourceStepProps",
    jsii_struct_bases=[AssertAwsResourceStepProps],
    name_mapping={
        "description": "description",
        "input_observer": "inputObserver",
        "name": "name",
        "output_observer": "outputObserver",
        "explicit_next_step": "explicitNextStep",
        "is_end": "isEnd",
        "max_attempts": "maxAttempts",
        "on_cancel": "onCancel",
        "on_failure": "onFailure",
        "timeout_seconds": "timeoutSeconds",
        "user_outputs": "userOutputs",
        "api_params": "apiParams",
        "pascal_case_api": "pascalCaseApi",
        "service": "service",
        "java_script_api": "javaScriptApi",
        "desired_values": "desiredValues",
        "selector": "selector",
        "sleep_interval_millis": "sleepIntervalMillis",
    },
)
class WaitForResourceStepProps(AssertAwsResourceStepProps):
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        input_observer: typing.Optional[IObserver] = None,
        name: typing.Optional[builtins.str] = None,
        output_observer: typing.Optional[IObserver] = None,
        explicit_next_step: typing.Optional[StepRef] = None,
        is_end: typing.Optional[builtins.bool] = None,
        max_attempts: typing.Optional[jsii.Number] = None,
        on_cancel: typing.Optional[OnCancel] = None,
        on_failure: typing.Optional[OnFailure] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
        user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
        api_params: typing.Mapping[builtins.str, typing.Any],
        pascal_case_api: builtins.str,
        service: AwsService,
        java_script_api: typing.Optional[builtins.str] = None,
        desired_values: typing.Sequence[builtins.str],
        selector: builtins.str,
        sleep_interval_millis: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param description: (Optional) description of the current step. Default: undefined
        :param input_observer: (Optional) Allows for observing the input to steps as they run. Default: NoopObserver
        :param name: (Optional) Name of the current step. The name will be prepended onto all of the outputs emitted from this step. This name will also be used to reference this step in logs. Defaults to the id of the CDK node.
        :param output_observer: (Optional) Allows for observing the output of steps as they run. Default: NoopObserver
        :param explicit_next_step: (Optional) explicit step to go to after this step completes. https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp Default: will implicitly choose the next step in the sequence that the steps are added to the document.
        :param is_end: Whether to stop document execution after this step. Default: false
        :param max_attempts: (Optional) max attempts to run this step if there are failures. Default: Step.DEFAULT_MAX_ATTEMPTS
        :param on_cancel: (Optional) Fallback action to take in the event that this step is cancelled. Default: undefined
        :param on_failure: (Optional) Fallback action to take in the event that this step fails. Default: undefined
        :param timeout_seconds: (Optional) timeout seconds to run this step. In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step. Default: Step.DEFAULT_TIMEOUT
        :param user_outputs: (Optional) Allows to define step outputs. Default: undefined
        :param api_params: (Required) API Params to submit with the request to the api. You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}
        :param pascal_case_api: (Required) The AWS api represented in PascalCase. This value is used as-is in the SSM yaml/json. This is used as the default for javaScriptApi (see that param).
        :param service: (Required) The AWS service to be invoked.
        :param java_script_api: (Optional) The api as represented the AWS JavaScript API. This is usually lowerCamelCase. This is used in the simulation run to execute the AWS API against the JavaScript SDK. Default: - will use the camelCaseApi param and substitute the first character for lowercase by default.
        :param desired_values: (Required) Value extracted from AWS response desired to be one of these desired values.
        :param selector: (Required) Json path selector to extract value from AWS response.
        :param sleep_interval_millis: (Optional) How much time to sleep after not receiving desired response from AWS SDK. This is only used for the run simulation. This is not used by SSM and is therefore not declared in the SSM yaml/json. Default: 2000 millis
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fdda9118eb32015294033e7da38d33cd3b9b4994d1a893c41dc6491dd671e4a5)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument input_observer", value=input_observer, expected_type=type_hints["input_observer"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument output_observer", value=output_observer, expected_type=type_hints["output_observer"])
            check_type(argname="argument explicit_next_step", value=explicit_next_step, expected_type=type_hints["explicit_next_step"])
            check_type(argname="argument is_end", value=is_end, expected_type=type_hints["is_end"])
            check_type(argname="argument max_attempts", value=max_attempts, expected_type=type_hints["max_attempts"])
            check_type(argname="argument on_cancel", value=on_cancel, expected_type=type_hints["on_cancel"])
            check_type(argname="argument on_failure", value=on_failure, expected_type=type_hints["on_failure"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
            check_type(argname="argument user_outputs", value=user_outputs, expected_type=type_hints["user_outputs"])
            check_type(argname="argument api_params", value=api_params, expected_type=type_hints["api_params"])
            check_type(argname="argument pascal_case_api", value=pascal_case_api, expected_type=type_hints["pascal_case_api"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument java_script_api", value=java_script_api, expected_type=type_hints["java_script_api"])
            check_type(argname="argument desired_values", value=desired_values, expected_type=type_hints["desired_values"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
            check_type(argname="argument sleep_interval_millis", value=sleep_interval_millis, expected_type=type_hints["sleep_interval_millis"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_params": api_params,
            "pascal_case_api": pascal_case_api,
            "service": service,
            "desired_values": desired_values,
            "selector": selector,
        }
        if description is not None:
            self._values["description"] = description
        if input_observer is not None:
            self._values["input_observer"] = input_observer
        if name is not None:
            self._values["name"] = name
        if output_observer is not None:
            self._values["output_observer"] = output_observer
        if explicit_next_step is not None:
            self._values["explicit_next_step"] = explicit_next_step
        if is_end is not None:
            self._values["is_end"] = is_end
        if max_attempts is not None:
            self._values["max_attempts"] = max_attempts
        if on_cancel is not None:
            self._values["on_cancel"] = on_cancel
        if on_failure is not None:
            self._values["on_failure"] = on_failure
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds
        if user_outputs is not None:
            self._values["user_outputs"] = user_outputs
        if java_script_api is not None:
            self._values["java_script_api"] = java_script_api
        if sleep_interval_millis is not None:
            self._values["sleep_interval_millis"] = sleep_interval_millis

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''(Optional) description of the current step.

        :default: undefined
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def input_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the input to steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("input_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''(Optional) Name of the current step.

        The name will be prepended onto all of the outputs emitted from this step.
        This name will also be used to reference this step in logs.
        Defaults to the id of the CDK node.
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def output_observer(self) -> typing.Optional[IObserver]:
        '''(Optional) Allows for observing the output of steps as they run.

        :default: NoopObserver
        '''
        result = self._values.get("output_observer")
        return typing.cast(typing.Optional[IObserver], result)

    @builtins.property
    def explicit_next_step(self) -> typing.Optional[StepRef]:
        '''(Optional) explicit step to go to after this step completes.

        https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html#nextProp

        :default: will implicitly choose the next step in the sequence that the steps are added to the document.
        '''
        result = self._values.get("explicit_next_step")
        return typing.cast(typing.Optional[StepRef], result)

    @builtins.property
    def is_end(self) -> typing.Optional[builtins.bool]:
        '''Whether to stop document execution after this step.

        :default: false
        '''
        result = self._values.get("is_end")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_attempts(self) -> typing.Optional[jsii.Number]:
        '''(Optional) max attempts to run this step if there are failures.

        :default: Step.DEFAULT_MAX_ATTEMPTS
        '''
        result = self._values.get("max_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def on_cancel(self) -> typing.Optional[OnCancel]:
        '''(Optional) Fallback action to take in the event that this step is cancelled.

        :default: undefined
        '''
        result = self._values.get("on_cancel")
        return typing.cast(typing.Optional[OnCancel], result)

    @builtins.property
    def on_failure(self) -> typing.Optional[OnFailure]:
        '''(Optional) Fallback action to take in the event that this step fails.

        :default: undefined
        '''
        result = self._values.get("on_failure")
        return typing.cast(typing.Optional[OnFailure], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''(Optional) timeout seconds to run this step.

        In a simulation run, this will only be encorced after-the-fact but execution will not be stopped mid-step.

        :default: Step.DEFAULT_TIMEOUT
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def user_outputs(self) -> typing.Optional[typing.List[Output]]:
        '''(Optional) Allows to define step outputs.

        :default: undefined
        '''
        result = self._values.get("user_outputs")
        return typing.cast(typing.Optional[typing.List[Output]], result)

    @builtins.property
    def api_params(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''(Required) API Params to submit with the request to the api.

        You may include variables which will be substitued for inputs during step execution as such {{ INPUT }}

        Example::

            { 'VolumeIds': ['{{ EbsDescribeInstance.VolumeId }}'] }
        '''
        result = self._values.get("api_params")
        assert result is not None, "Required property 'api_params' is missing"
        return typing.cast(typing.Mapping[builtins.str, typing.Any], result)

    @builtins.property
    def pascal_case_api(self) -> builtins.str:
        '''(Required) The AWS api represented in PascalCase.

        This value is used as-is in the SSM yaml/json.
        This is used as the default for javaScriptApi (see that param).

        Example::

            DescribeInstances
        '''
        result = self._values.get("pascal_case_api")
        assert result is not None, "Required property 'pascal_case_api' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> AwsService:
        '''(Required) The AWS service to be invoked.

        Example::

            AwsService.S3
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(AwsService, result)

    @builtins.property
    def java_script_api(self) -> typing.Optional[builtins.str]:
        '''(Optional) The api as represented the AWS JavaScript API.

        This is usually lowerCamelCase.
        This is used in the simulation run to execute the AWS API against the JavaScript SDK.

        :default: - will use the camelCaseApi param and substitute the first character for lowercase by default.

        Example::

            describeInstances
        '''
        result = self._values.get("java_script_api")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def desired_values(self) -> typing.List[builtins.str]:
        '''(Required) Value extracted from AWS response desired to be one of these desired values.'''
        result = self._values.get("desired_values")
        assert result is not None, "Required property 'desired_values' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def selector(self) -> builtins.str:
        '''(Required) Json path selector to extract value from AWS response.'''
        result = self._values.get("selector")
        assert result is not None, "Required property 'selector' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def sleep_interval_millis(self) -> typing.Optional[jsii.Number]:
        '''(Optional) How much time to sleep after not receiving desired response from AWS SDK.

        This is only used for the run simulation.
        This is not used by SSM and is therefore not declared in the SSM yaml/json.

        :default: 2000 millis
        '''
        result = self._values.get("sleep_interval_millis")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WaitForResourceStepProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IActionVariable)
class HardCodedAction(
    HardCodedString,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedAction",
):
    @jsii.python.classproperty
    @jsii.member(jsii_name="INSTALL")
    def INSTALL(cls) -> "HardCodedAction":
        return typing.cast("HardCodedAction", jsii.sget(cls, "INSTALL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="UNINSTALL")
    def UNINSTALL(cls) -> "HardCodedAction":
        return typing.cast("HardCodedAction", jsii.sget(cls, "UNINSTALL"))


@jsii.implements(IDesiredStateVariable)
class HardCodedDesiredState(
    HardCodedString,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedDesiredState",
):
    @jsii.python.classproperty
    @jsii.member(jsii_name="RUNNING")
    def RUNNING(cls) -> "HardCodedDesiredState":
        return typing.cast("HardCodedDesiredState", jsii.sget(cls, "RUNNING"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="STOPPED")
    def STOPPED(cls) -> "HardCodedDesiredState":
        return typing.cast("HardCodedDesiredState", jsii.sget(cls, "STOPPED"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="TERMINATED")
    def TERMINATED(cls) -> "HardCodedDesiredState":
        return typing.cast("HardCodedDesiredState", jsii.sget(cls, "TERMINATED"))


@jsii.implements(IDocumentHashTypeVariable)
class HardCodedDocumentHashType(
    HardCodedString,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedDocumentHashType",
):
    @jsii.python.classproperty
    @jsii.member(jsii_name="SHA1")
    def SHA1(cls) -> "HardCodedDocumentHashType":
        return typing.cast("HardCodedDocumentHashType", jsii.sget(cls, "SHA1"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SHA256")
    def SHA256(cls) -> "HardCodedDocumentHashType":
        return typing.cast("HardCodedDocumentHashType", jsii.sget(cls, "SHA256"))


@jsii.implements(IInstallUninstallRepairVariable)
class HardCodedInstallUninstallRepair(
    HardCodedString,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedInstallUninstallRepair",
):
    @jsii.python.classproperty
    @jsii.member(jsii_name="INSTALL")
    def INSTALL(cls) -> "HardCodedInstallUninstallRepair":
        return typing.cast("HardCodedInstallUninstallRepair", jsii.sget(cls, "INSTALL"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="REPAIR")
    def REPAIR(cls) -> "HardCodedInstallUninstallRepair":
        return typing.cast("HardCodedInstallUninstallRepair", jsii.sget(cls, "REPAIR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="UNINSTALL")
    def UNINSTALL(cls) -> "HardCodedInstallUninstallRepair":
        return typing.cast("HardCodedInstallUninstallRepair", jsii.sget(cls, "UNINSTALL"))


@jsii.implements(IInstallationTypeVariable)
class HardCodedInstallationType(
    HardCodedString,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedInstallationType",
):
    @jsii.python.classproperty
    @jsii.member(jsii_name="IN_PLACE_UPDATE")
    def IN_PLACE_UPDATE(cls) -> "HardCodedInstallationType":
        return typing.cast("HardCodedInstallationType", jsii.sget(cls, "IN_PLACE_UPDATE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="UNINSTALL_AND_REINSTALL")
    def UNINSTALL_AND_REINSTALL(cls) -> "HardCodedInstallationType":
        return typing.cast("HardCodedInstallationType", jsii.sget(cls, "UNINSTALL_AND_REINSTALL"))


@jsii.implements(IOnFailureVariable)
class HardCodedOnFailure(
    HardCodedString,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedOnFailure",
):
    @jsii.python.classproperty
    @jsii.member(jsii_name="DELETE")
    def DELETE(cls) -> "HardCodedOnFailure":
        return typing.cast("HardCodedOnFailure", jsii.sget(cls, "DELETE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DO_NOTHING")
    def DO_NOTHING(cls) -> "HardCodedOnFailure":
        return typing.cast("HardCodedOnFailure", jsii.sget(cls, "DO_NOTHING"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ROLLBACK")
    def ROLLBACK(cls) -> "HardCodedOnFailure":
        return typing.cast("HardCodedOnFailure", jsii.sget(cls, "ROLLBACK"))


@jsii.implements(IPackageNameVariable)
class HardCodedPackageName(
    HardCodedString,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedPackageName",
):
    @jsii.python.classproperty
    @jsii.member(jsii_name="AMAZON_CLOUD_WATCH_AGENT")
    def AMAZON_CLOUD_WATCH_AGENT(cls) -> "HardCodedPackageName":
        return typing.cast("HardCodedPackageName", jsii.sget(cls, "AMAZON_CLOUD_WATCH_AGENT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AWS_ENA_NETWORK_DRIVER")
    def AWS_ENA_NETWORK_DRIVER(cls) -> "HardCodedPackageName":
        return typing.cast("HardCodedPackageName", jsii.sget(cls, "AWS_ENA_NETWORK_DRIVER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AWS_SUPPORT_EC2_RESCUE")
    def AWS_SUPPORT_EC2_RESCUE(cls) -> "HardCodedPackageName":
        return typing.cast("HardCodedPackageName", jsii.sget(cls, "AWS_SUPPORT_EC2_RESCUE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AWS_VSS_COMPONENTS")
    def AWS_VSS_COMPONENTS(cls) -> "HardCodedPackageName":
        return typing.cast("HardCodedPackageName", jsii.sget(cls, "AWS_VSS_COMPONENTS"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AWSNVME")
    def AWSNVME(cls) -> "HardCodedPackageName":
        return typing.cast("HardCodedPackageName", jsii.sget(cls, "AWSNVME"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="AWSPV_DRIVER")
    def AWSPV_DRIVER(cls) -> "HardCodedPackageName":
        return typing.cast("HardCodedPackageName", jsii.sget(cls, "AWSPV_DRIVER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="CODE_DEPLOY_AGENT")
    def CODE_DEPLOY_AGENT(cls) -> "HardCodedPackageName":
        return typing.cast("HardCodedPackageName", jsii.sget(cls, "CODE_DEPLOY_AGENT"))


@jsii.implements(IResourceTypeVariable)
class HardCodedResourceType(
    HardCodedString,
    metaclass=jsii.JSIIMeta,
    jsii_type="@cdklabs/cdk-ssm-documents.HardCodedResourceType",
):
    @jsii.python.classproperty
    @jsii.member(jsii_name="EC2")
    def EC2(cls) -> "HardCodedResourceType":
        return typing.cast("HardCodedResourceType", jsii.sget(cls, "EC2"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MAINTENANCE_WINDOW")
    def MAINTENANCE_WINDOW(cls) -> "HardCodedResourceType":
        return typing.cast("HardCodedResourceType", jsii.sget(cls, "MAINTENANCE_WINDOW"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MANAGED_INSTANCE")
    def MANAGED_INSTANCE(cls) -> "HardCodedResourceType":
        return typing.cast("HardCodedResourceType", jsii.sget(cls, "MANAGED_INSTANCE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PARAMETER")
    def PARAMETER(cls) -> "HardCodedResourceType":
        return typing.cast("HardCodedResourceType", jsii.sget(cls, "PARAMETER"))


__all__ = [
    "Abort",
    "ActionVariable",
    "ApiExecuteAutomationHook",
    "ApiExecuteAutomationProps",
    "ApiRunCommandHook",
    "ApiRunCommandProps",
    "ApplicationsStep",
    "ApplicationsStepProps",
    "ApproveImpl",
    "ApproveSimulation",
    "ApproveSimulationProps",
    "ApproveStep",
    "ApproveStepProps",
    "ArnDoc",
    "AssertAwsResourceSimulation",
    "AssertAwsResourceStep",
    "AssertAwsResourceStepProps",
    "AuthMethod",
    "AutomationDocument",
    "AutomationDocumentBuilder",
    "AutomationDocumentProps",
    "AutomationSimulation",
    "AutomationSimulationBase",
    "AutomationSimulationProps",
    "AutomationStep",
    "AutomationStepProps",
    "AutomationStepSimulation",
    "AwsApiSimulation",
    "AwsApiStep",
    "AwsApiStepProps",
    "AwsInvocationProps",
    "AwsInvocationSimulationProps",
    "AwsService",
    "BodyOrUrlProp",
    "BodyOrUrlType",
    "BooleanInputProps",
    "BooleanVariable",
    "BranchSimulation",
    "BranchStep",
    "BranchStepProps",
    "ChangeInstanceStateSimulation",
    "ChangeInstanceStateSimulationProps",
    "ChangeInstanceStateStep",
    "ChangeInstanceStateStepProps",
    "Choice",
    "ChoiceProps",
    "CommandDocument",
    "CommandDocumentBuilder",
    "CommandDocumentProps",
    "CommandSimulation",
    "CommandSimulationBase",
    "CommandSimulationProps",
    "CommandStep",
    "CommandStepProps",
    "CommandStepSimulation",
    "CompositeAutomationStep",
    "CompositeCommandStep",
    "ConfigureDockerStep",
    "ConfigureDockerStepProps",
    "ConfigurePackageStep",
    "ConfigurePackageStepProps",
    "Continue",
    "CopyImageSimulation",
    "CopyImageStep",
    "CopyImageStepProps",
    "CreateImageSimulation",
    "CreateImageStep",
    "CreateImageStepProps",
    "CreateStackSimulation",
    "CreateStackSimulationProps",
    "CreateStackStep",
    "CreateStackStepProps",
    "CreateTagsSimulation",
    "CreateTagsSimulationProps",
    "CreateTagsStep",
    "CreateTagsStepProps",
    "DataType",
    "DataTypeEnum",
    "DeleteImageSimulation",
    "DeleteImageSimulationProps",
    "DeleteImageStep",
    "DeleteImageStepProps",
    "DeleteStackSimulation",
    "DeleteStackStep",
    "DeleteStackStepProps",
    "DesiredStateVariable",
    "DictFormat",
    "DockerEnvironment",
    "DocumentFormat",
    "DocumentHashTypeVariable",
    "DocumentOutput",
    "DocumentResult",
    "DocumentSource",
    "DomainJoinStep",
    "DomainJoinStepProps",
    "DownloadContentStep",
    "DownloadContentStepProps",
    "EnvironmentProps",
    "ExecuteAutomationOutputs",
    "ExecuteAutomationProps",
    "ExecuteAutomationStep",
    "ExecuteAutomationStepProps",
    "ExecuteScriptSimulation",
    "ExecuteScriptStep",
    "ExecuteScriptStepProps",
    "ExecuteStateMachineSimulation",
    "ExecuteStateMachineStep",
    "ExecuteStateMachineStepProps",
    "FileScriptCode",
    "GenericVariable",
    "GitContent",
    "GitContentProps",
    "GitHubContent",
    "GitHubContentProps",
    "HardCodedAction",
    "HardCodedBoolean",
    "HardCodedDesiredState",
    "HardCodedDocumentHashType",
    "HardCodedInstallUninstallRepair",
    "HardCodedInstallationType",
    "HardCodedMapList",
    "HardCodedNumber",
    "HardCodedOnFailure",
    "HardCodedPackageName",
    "HardCodedResourceType",
    "HardCodedSecureVariable",
    "HardCodedString",
    "HardCodedStringList",
    "HardCodedStringMap",
    "HardCodedValueBase",
    "HelloWorld",
    "HttpContent",
    "HttpContentProps",
    "IActionVariable",
    "IApproveHook",
    "IAutomationComponent",
    "IAwsInvoker",
    "IBooleanVariable",
    "ICommandComponent",
    "IDesiredStateVariable",
    "IDocumentHashTypeVariable",
    "IDownloadableContent",
    "IEnvironment",
    "IExecuteAutomationHook",
    "IGenericVariable",
    "IInstallUninstallRepairVariable",
    "IInstallationTypeVariable",
    "IMapListVariable",
    "INumberVariable",
    "IObserver",
    "IOnFailureVariable",
    "IPackageNameVariable",
    "IParameterResolver",
    "IPauseHook",
    "IResourceTypeVariable",
    "IRunCommandHook",
    "IRunDocumentLocation",
    "ISleepHook",
    "IStringListVariable",
    "IStringMapVariable",
    "IStringVariable",
    "IWebhook",
    "IncidentResponse",
    "IncidentResponseAction",
    "IncidentResponseProps",
    "IncidentTemplate",
    "IncidentTemplateProps",
    "InlineScriptCode",
    "Input",
    "InputProps",
    "InstallUninstallRepairVariable",
    "InstallationTypeVariable",
    "IntegerInputProps",
    "Invocation",
    "InvokeLambdaFunctionSimulation",
    "InvokeLambdaFunctionStep",
    "InvokeLambdaFunctionStepProps",
    "InvokeWebhookProps",
    "InvokeWebhookResult",
    "InvokeWebhookSimulation",
    "InvokeWebhookSimulationProps",
    "InvokeWebhookStep",
    "InvokeWebhookStepProps",
    "LocalRunDocument",
    "LoggingEnvironment",
    "MapListInputProps",
    "MapListVariable",
    "MockApprove",
    "MockAwsInvoker",
    "MockEnvironment",
    "MockPause",
    "MockSleep",
    "NameDoc",
    "NoAuthMethod",
    "NonSecureVariable",
    "NoopObserver",
    "NumberVariable",
    "OnCancel",
    "OnFailure",
    "OnFailureVariable",
    "Operation",
    "OperationEvaluator",
    "Output",
    "PackageNameVariable",
    "PauseImpl",
    "PauseSimulation",
    "PauseSimulationProps",
    "PauseStep",
    "Platform",
    "Platforms",
    "Precondition",
    "PreconditionProps",
    "PsModuleSimulation",
    "PsModuleStep",
    "PsModuleStepProps",
    "PythonVersion",
    "RebootInstanceAndWait",
    "ReflectiveAwsInvoker",
    "RequiredAutomationSimulationProps",
    "RequiredCommandSimulationProps",
    "ResourceTypeVariable",
    "ResponseCode",
    "RunCommandOutputs",
    "RunCommandProps",
    "RunCommandSimulation",
    "RunCommandSimulationProps",
    "RunCommandStep",
    "RunCommandStepProps",
    "RunDockerActionStep",
    "RunDockerActionStepProps",
    "RunDocumentStep",
    "RunDocumentStepProps",
    "RunInstanceSimulation",
    "RunInstanceStep",
    "RunInstanceStepProps",
    "RunPowerShellScriptSimulation",
    "RunPowerShellScriptStep",
    "RunPowerShellScriptStepProps",
    "RunShellScriptSimulation",
    "RunShellScriptStep",
    "RunShellScriptStepProps",
    "S3Content",
    "S3ContentProps",
    "SSMDocumentContent",
    "ScriptCode",
    "ScriptLanguage",
    "SecureVariable",
    "Simulation",
    "SimulationProps",
    "SimulationResult",
    "SleepImpl",
    "SleepSimulation",
    "SleepSimulationProps",
    "SleepStep",
    "SleepStepProps",
    "SoftwareInventoryStep",
    "SoftwareInventoryStepProps",
    "SsmAutomationProps",
    "SsmDocument",
    "SsmDocumentContentProps",
    "SsmDocumentProps",
    "SsmRunDocument",
    "SsmSecureVariable",
    "Step",
    "StepFallback",
    "StepNameFallback",
    "StepProps",
    "StepRef",
    "StringDocument",
    "StringFormat",
    "StringInputProps",
    "StringListInputProps",
    "StringListVariable",
    "StringMapInputProps",
    "StringMapVariable",
    "StringStep",
    "StringVariable",
    "SynthUtils",
    "TimedDocument",
    "UpdateAgentStep",
    "UpdateAgentStepProps",
    "UpdateSSMAgentStep",
    "UpdateSSMAgentStepProps",
    "UpdateVariableProps",
    "UpdateVariableSimulation",
    "UpdateVariableStep",
    "UsernamePasswordAuthMethod",
    "WaitForResourceSimulation",
    "WaitForResourceSimulationProps",
    "WaitForResourceStep",
    "WaitForResourceStepProps",
    "WebhookImpl",
]

publication.publish()

def _typecheckingstub__08c02016993b2a117240a5a7dcb1b3700304d1339c2a5a8420b238642be31116(
    *,
    aws_invoker: IAwsInvoker,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af38a0ce6274be1a306023040c89b3c06084afa621dbe98eba5701332739f564(
    *,
    aws_invoker: IAwsInvoker,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eaceda1463f14e4337fab5997598856eaf05edd73ec5a489c733161db5408e43(
    *,
    approve_hook: IApproveHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a3591df80e77dbb8ef5aa57aea6dec940e019e52c5565dfe17720fddd13b45c(
    user_name: SecureVariable,
    password: SecureVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e1520d00b0d311b02bf0ab8526c7a5f475ab8489924998b7920be6be1a16695(
    user_name: SecureVariable,
    password: SecureVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35c46ba75b77e145ad70cc1ac20d0e7a95ac57a50251cb403bbbf783ae3d7ef2(
    step: AutomationStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e9e5dd611b035717db2dd8cc76801acfda0588b3e4bb3540a4dde83ea38c5a9(
    automation_document: AutomationDocument,
    *,
    approve_hook: typing.Optional[IApproveHook] = None,
    aws_invoker: typing.Optional[IAwsInvoker] = None,
    environment: typing.Optional[IEnvironment] = None,
    input_observer: typing.Optional[IObserver] = None,
    output_observer: typing.Optional[IObserver] = None,
    parameter_resolver: typing.Optional[IParameterResolver] = None,
    pause_hook: typing.Optional[IPauseHook] = None,
    run_command_hook: typing.Optional[IRunCommandHook] = None,
    simulation_platform: typing.Optional[Platform] = None,
    sleep_hook: typing.Optional[ISleepHook] = None,
    webhook: typing.Optional[IWebhook] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecf0a07e5abd7e015b8dede33a5831d80785e3aea8d5e27a50e45e303f59d51f(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5cc79b84b9c1335c3d739020a4923e18fd2763b2b8bc1417c07e1af3c65eb26c(
    step: AutomationStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec46109eb8632ec31ffe946bde1b1ff0fe13885e470a4640ff2d9c762f2b43d1(
    _inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3eb11e49220ee922a0113c6f96e39ffaf50b01adacce55faa806e428b412cdc2(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3b4d1ff1eeb559a44a1bad3921e706376c5c57dbd8a11e22add82bb29ef150e(
    *,
    approve_hook: typing.Optional[IApproveHook] = None,
    aws_invoker: typing.Optional[IAwsInvoker] = None,
    execute_automation_hook: typing.Optional[IExecuteAutomationHook] = None,
    input_observer: typing.Optional[IObserver] = None,
    output_observer: typing.Optional[IObserver] = None,
    parameter_resolver: typing.Optional[IParameterResolver] = None,
    pause_hook: typing.Optional[IPauseHook] = None,
    run_command_hook: typing.Optional[IRunCommandHook] = None,
    sleep_hook: typing.Optional[ISleepHook] = None,
    webhook: typing.Optional[IWebhook] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4360175161f1d9c2ebbfc76f2dee4e24cd4eb99b9870cb7d8ac98d069d885a3(
    step: AutomationStep,
    *,
    approve_hook: typing.Optional[IApproveHook] = None,
    aws_invoker: typing.Optional[IAwsInvoker] = None,
    execute_automation_hook: typing.Optional[IExecuteAutomationHook] = None,
    input_observer: typing.Optional[IObserver] = None,
    output_observer: typing.Optional[IObserver] = None,
    parameter_resolver: typing.Optional[IParameterResolver] = None,
    pause_hook: typing.Optional[IPauseHook] = None,
    run_command_hook: typing.Optional[IRunCommandHook] = None,
    sleep_hook: typing.Optional[ISleepHook] = None,
    webhook: typing.Optional[IWebhook] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3a2871067490f5b1404f08b97e29340d52a386005e9a9eac44faed17eb76a33(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c46aeb8cc3ab966aa4205338f39dab478acdbfc408de61c7a389fb3e10a209e(
    subsequent_steps: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76009844085f37a4b87980d0948a019c5e2c3a0a71fcbb5083fe75d1f9f7902b(
    step: AwsApiStep,
    *,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01a9fbab0e98cf6ec11d4ca1992708709512dfcf10e3d0b87e93f1b469906e5e(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0961d9e7ba7539e90ab20d28dd6f14e7553b08b42107cbbb7d3a3192a35b60d6(
    *,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__011beaadde5cbf101b3b2c4a2870f6dbad6e426fd33bc5fd7c34df2f0fd60ef5(
    namespace: builtins.str,
    java_script_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52eae3080469f19d19715e112b158b4013e61fc81bb9355cbfda0ef72575704a(
    *,
    prop_type: BodyOrUrlType,
    value: IStringVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34a196ac72865c8e18131056e285ff9cc58be275f7aa2bb2f64be4b75648e1dc(
    *,
    default_value: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89bed2b01e97b0c71e0453f0eeca326ec0f39037e9140428374eafe37f3a2e61(
    step: BranchStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dce4d391481fcca3abcb3d83ce8eaa599511c5ab644062958efc6b9342c49d09(
    _inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5b7d256bd86527e83318e1662b34ac11dd7bed6cd69d7836cafc7f183b66f77(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b616c6aac996eb9354487c87a9c71d3970eb946c9be7d401940fc1ca1cb303f(
    step: ChangeInstanceStateStep,
    *,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__658e512a463cefbe43a4ef743c985822db58368e649ce9b651c01010dcaec22e(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d02a554c8cf0f9d1a5029ad87a4bb3d96a49b7687c81c1d40a7155bbfe9e17e9(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c549fa9de0e40bacd62b01d538e0d5168d84aca7f1c2c4dc6304fcecca05ea2f(
    *,
    constant: typing.Any,
    jump_to_step_name: builtins.str,
    operation: Operation,
    variable: typing.Union[IStringVariable, INumberVariable, IBooleanVariable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a904ee5a98cd657e13249948cfe577d8d52d51e83a7bc912fc8a4e0c87228c8(
    step: CommandStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5664bb6893c17edc3f3cfdb53e3cf7be0f932f267ad0319c8f53d41677942e7c(
    command_document: CommandDocument,
    *,
    approve_hook: typing.Optional[IApproveHook] = None,
    aws_invoker: typing.Optional[IAwsInvoker] = None,
    environment: typing.Optional[IEnvironment] = None,
    input_observer: typing.Optional[IObserver] = None,
    output_observer: typing.Optional[IObserver] = None,
    parameter_resolver: typing.Optional[IParameterResolver] = None,
    pause_hook: typing.Optional[IPauseHook] = None,
    run_command_hook: typing.Optional[IRunCommandHook] = None,
    simulation_platform: typing.Optional[Platform] = None,
    sleep_hook: typing.Optional[ISleepHook] = None,
    webhook: typing.Optional[IWebhook] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1dd6e27dde321fd0a2e17516f7567c8accad2b9dbb23d0782a6f5c68f81727a8(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57993e4f6222ff515e8a2c0103b3fc205f9730dfa7a2e9e22f73bc463a83cd2b(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7970c32a6effaacd5f081fcf30742e78761a51ca97178ae2d401b11a779f726(
    *,
    simulation_platform: Platform,
    environment: typing.Optional[IEnvironment] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0e1af41db34838e50f961ac56116d8a8812d0ec050e1c402dd82961d5c1e24b(
    step: CommandStep,
    *,
    simulation_platform: Platform,
    environment: typing.Optional[IEnvironment] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df1f3803c998ada8bd4d75af336574604c59e72d48899dee26d0566f60d8fd23(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6419b2395fc46dcbcce7fd444c413e6f312515fe48c382418bf92459b6d8986(
    future_steps: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db0ce72e063e8020406e7ced6f68ba6119dc03d32ff64b6e935b88e55ef23778(
    step: CopyImageStep,
    *,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe5d159a965fa3c8c617b2779191034196aa02d12c20df78e75e34a6a0735721(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51f01f033e9da3982b7e984984500fec14f6b2d7fdfb3a6bb0fdd88b83148164(
    step: CreateImageStep,
    *,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b7f688902e8db84288332c7e95432375ca85a3d27566d0536e8fd4aa6a2f596(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__935d04fa6968a0f0e4c36e797ced6a22c0048ab1513680c0e4bcdf44f8e08e5e(
    step: CreateStackStep,
    *,
    aws_invoker: IAwsInvoker,
    parameter_resolver: IParameterResolver,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__579411a205724eedf4a47963863c7d7219789ff990c4002a389ee875132368ec(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f5ba6a684b638b28689132e40fb37628bde6ba59ade54f41ae20982f58ad64a(
    *,
    aws_invoker: IAwsInvoker,
    parameter_resolver: IParameterResolver,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19addadfbbfafd4c98e2535c68aad0ae0179e68fb1325f1c15dee6c7cd5c8fc0(
    step: CreateTagsStep,
    *,
    aws_invoker: IAwsInvoker,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f184547cd3dee0f0b0f5ad975c1ee467af9cf4f97331eaea9ecc56cdd7734e0b(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71f87212e52225fdb1204c062421a3fabcac174fa933397cbb0e35733427c913(
    *,
    aws_invoker: IAwsInvoker,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcdc44ad44f098ff5e1363529b469642a6904200aa7e07e32f3671eeac53f460(
    data_type_enum: DataTypeEnum,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9dcc1bad3d996eb40ef32b5e39b7668dc1da50420d37770ada5ebacdfeff3ed9(
    ssm_data_type: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c01782e64207b81c0afc65680d4e008fb5e2470716df80e3c38784091a7aff3(
    val: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e13a0a84207f42ec17f0f0d45449bbef1d7e01eb4028a25fe47bb77a621818f(
    step: DeleteImageStep,
    *,
    aws_invoker: typing.Optional[IAwsInvoker] = None,
    sleep_hook: typing.Optional[ISleepHook] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fafe9abace5f65ab03f3950190c2a7872a94df18aceec43dc927170c0874a55b(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f27458eb46e47b8b0b7f23f7893c9929951350f36f1cd60009ebcf9535ff74aa(
    *,
    aws_invoker: typing.Optional[IAwsInvoker] = None,
    sleep_hook: typing.Optional[ISleepHook] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__556711aed5a48c0ffe5cede99a35b83ed8843473fc31824aa7874677ac8a1041(
    step: DeleteStackStep,
    *,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5631e62e1386d58975ddfce72668883a4a1d2ba2f50ac397d404ba8d3b1a5ee9(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__626d454bd9cb559c4c62c6a0c06a3cc6d5ce2c149355e72a54ecf7f4ea7b38a0(
    *,
    name: builtins.str,
    output_type: DataTypeEnum,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__723b1c1575d3425fbda3a2c75197f206c3c0819c98e96fabc00fe4118b955b1b(
    arn: IStringVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eaa198d9dc39809d034dd3f9d90edfe9a48056901beddca4649be4c2648f6a66(
    name: IStringVariable,
    version: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b992e08b58a570f6fa880e3321a36daf2b972b8ee8dedc2668069d3d7290cfc0(
    *,
    environment: IEnvironment,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f689cf9b22a3f6a3d00000164e9492e78ae28cedae8482dce5929420201cad4(
    *,
    execution_id: builtins.str,
    status: builtins.str,
    output: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09ea8eaaa60d1be9af69af8b2d979194c3cd08714a381ba54f2d8c4e48f56e5f(
    *,
    document_name: builtins.str,
    document_version: typing.Optional[builtins.str] = None,
    max_concurrency: typing.Optional[builtins.str] = None,
    max_errors: typing.Optional[builtins.str] = None,
    runtime_parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    tags: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
    target_locations: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
    target_maps: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
    target_parameter_name: typing.Optional[builtins.str] = None,
    targets: typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b112d195ddf6f45d17d6bde4f2ee396f32699bd5406884a9e6326ce0df4107ce(
    step: ExecuteScriptStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c63b4a32c66b2f6e14c8e12a7d0ee0c4b7dede95e44c00e1d3b3869c23b15d40(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d080b39798a7db3e619a4e49f4b2c1d3d3ccaa91040638f2508bb66e582a5e78(
    step: ExecuteStateMachineStep,
    *,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe15717eaa8f66b5aa4ca4a7c6af52ace386dc122fc83e03c63124c668bce54d(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d651cd09c2787c55247c71b47250c62f142a04041f7ad36783e2dfad71f0d8e(
    *,
    repository: IStringVariable,
    branch: typing.Optional[builtins.str] = None,
    commit_id: typing.Optional[builtins.str] = None,
    password: typing.Optional[SecureVariable] = None,
    private_ssh_key: typing.Optional[SecureVariable] = None,
    skip_host_key_checking: typing.Optional[IBooleanVariable] = None,
    user_name: typing.Optional[SecureVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1346c493491376c42d9d088205e4b3fbef5ce3ebd68e9d3c4571a87b61a6776e(
    *,
    owner: IStringVariable,
    path: IStringVariable,
    repository: IStringVariable,
    token_info: SecureVariable,
    branch: typing.Optional[builtins.str] = None,
    commit_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3828217be81fdb1fab2c89e88e81e8e11044140d9d6773762589efb801bd236(
    app: _constructs_77d1e7e8.Construct,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1eed361121fb70e9242919eb1716231d1e5701c59894484b2bd71865ac94bb2c(
    *,
    url: IStringVariable,
    allow_insecure_download: typing.Optional[IBooleanVariable] = None,
    auth_method: typing.Optional[AuthMethod] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ad0b0575fb772422c104eb423e9142d1b9f3057642819ccb4aef0825e96fd99(
    approver: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a838b27b63e38ae411c9cc8ec0709a16e39150b06608c5d3fbd015f87943486c(
    doc: AutomationDocumentBuilder,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c05618c97bc0055fe58b613bd37402fd6deed9bf70c65fbd5c1f5efd9e8bdabf(
    doc: CommandDocumentBuilder,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__569c0d1fde3d02889a626a5a85d192dc7dbe99540d9c3b261f680e8ad0921bc4(
    command: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__502d23b90ffe32439213bf2b81b8538432717b84c226dfac87f19a8bf2bb1bdd(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c598153ecef28cff6fe6e37cff2560ce0f9239cfc6b774f143c8164e382eabf1(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb50e757d0f3a58bcf2edfae1fc0a0ab28debf69cba89d40c43d46893409f3a1(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbf2a51a1f4947d82a1862ff5512ce628b43a025629daa944afa2ebee4800416(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5256e130b9383e31ac28de02d47fb420d7a3b511e48f9cf8255a7997b4c57ee(
    input: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06e200bfa69c98bcf0d95c73db8d6588cf52de518d22b12d397c5e5ca5fe7353(
    time_millis: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16d874d6c7b678c0dba3b09d0631e662834544a4400319fcfb63574e213ca643(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41f53011d7d77f334ed91e209fc77505dee814917963112067ee5786842a7268(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e46adf9c9211384b5cea7f6e2bcdb1059bb2ec611c64830eac186ad9e52c8065(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e747470a0bce92539541fd6bc9d06686f8f11d65c073b6fccc232057db384ffd(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    actions: typing.Sequence[IncidentResponseAction],
    incident_template: IncidentTemplate,
    chat_channel: typing.Optional[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.ChatChannelProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]] = None,
    display_name: typing.Optional[builtins.str] = None,
    engagements: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4aa62a4b1bd98cbb569d0a44becb5947615958dd6657b9ad7aa04585e1eeabec(
    automation_document: AutomationDocument,
    role: _aws_cdk_aws_iam_ceddda9d.Role,
    *,
    parameters: typing.Mapping[builtins.str, IGenericVariable],
    target_account: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__baee91db5cf4ab65f4fbbc7685f1773d08e5290025e9536e877134c13ff42281(
    *,
    actions: typing.Sequence[IncidentResponseAction],
    incident_template: IncidentTemplate,
    chat_channel: typing.Optional[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.ChatChannelProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]] = None,
    display_name: typing.Optional[builtins.str] = None,
    engagements: typing.Optional[typing.Sequence[builtins.str]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d79beb8dc8bc6f8a13b2ac57bef84a3109b4c9d634b6ba3215b2a606a151583c(
    impact: jsii.Number,
    title: builtins.str,
    *,
    dedupe_string: typing.Optional[builtins.str] = None,
    incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    summary: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e47ccdc85a92d15b5171f648a62ae61977bb37d5df1554301971e99bb5d287de(
    title: builtins.str,
    *,
    dedupe_string: typing.Optional[builtins.str] = None,
    incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    summary: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8c8c849638f074ffb0d95efb38906510d466348224adc77f369170190f7baa9(
    title: builtins.str,
    *,
    dedupe_string: typing.Optional[builtins.str] = None,
    incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    summary: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d65db946f4bf0f8e2a0b7bee2213fe34b98b90fb2beffdb5d719dd7cd607d631(
    title: builtins.str,
    *,
    dedupe_string: typing.Optional[builtins.str] = None,
    incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    summary: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7750b29da7ed91eb5a1e7084b2c300dd368ee22c7d3881e16c12d4840148af5e(
    title: builtins.str,
    *,
    dedupe_string: typing.Optional[builtins.str] = None,
    incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    summary: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42ab88b04e48077799b9d6274881508e602db3e013865072fc22f2674708e4e6(
    title: builtins.str,
    *,
    dedupe_string: typing.Optional[builtins.str] = None,
    incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    summary: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c28b58d3612fdf482d94facd455de3bdcecda36ca7ca8492311d910ad527ebe(
    *,
    dedupe_string: typing.Optional[builtins.str] = None,
    incident_tags: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    notification_targets: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssmincidents_ceddda9d.CfnResponsePlan.NotificationTargetItemProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    summary: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04325df0f35fef47db79f35bedfa94f9863cf2eb2f4774af6aae7aece6b624e4(
    type: DataTypeEnum,
    input_name: builtins.str,
    *,
    input_type: DataTypeEnum,
    name: builtins.str,
    allowed_pattern: typing.Optional[builtins.str] = None,
    allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
    default_value: typing.Any = None,
    description: typing.Optional[builtins.str] = None,
    max_chars: typing.Optional[jsii.Number] = None,
    max_items: typing.Optional[jsii.Number] = None,
    min_chars: typing.Optional[jsii.Number] = None,
    min_items: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17c27dda7d76dcd4f9cfaa70cd6c25b5edd4aec5147d98f6de40a587eaed62ee(
    name: builtins.str,
    *,
    default_value: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a67c9197cfa89f20936e6b180fa01d1701cebb4b7ce4e967ce362c8a0d21b7a1(
    name: builtins.str,
    *,
    allowed_values: typing.Optional[typing.Sequence[jsii.Number]] = None,
    default_value: typing.Optional[jsii.Number] = None,
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__172d5f9613e1469a91e47b3012d25b1b0dcacb55a5ebae58424093faca00ffb4(
    name: builtins.str,
    *,
    allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
    default_value: typing.Any = None,
    description: typing.Optional[builtins.str] = None,
    max_items: typing.Optional[jsii.Number] = None,
    min_items: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3755c356b2124d7e9e9e51fff2220ef1c97e56d25d735d6b29b47feb9e0d491(
    name: builtins.str,
    *,
    allowed_pattern: typing.Optional[builtins.str] = None,
    allowed_values: typing.Optional[typing.Sequence[builtins.str]] = None,
    default_value: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    max_chars: typing.Optional[jsii.Number] = None,
    min_chars: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea22d2f4a329ed2941830e3cfc049e7b527140293138a3445132139e865bded5(
    name: builtins.str,
    *,
    allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
    default_value: typing.Any = None,
    description: typing.Optional[builtins.str] = None,
    max_items: typing.Optional[jsii.Number] = None,
    min_items: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f915e2d7e966614be50119b8179e6f7617e32f8c7d56ac7384cd8b760b0ae6e5(
    name: builtins.str,
    *,
    allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
    default_value: typing.Any = None,
    description: typing.Optional[builtins.str] = None,
    max_items: typing.Optional[jsii.Number] = None,
    min_items: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__911ea151a3bb7c8e028d0f41e95ca50233b7900e54cd6eff05526cb1659b95a3(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81e41b2bbab1149af36184269f147b903293ad635e3d9852d4cb21db0973985e(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecb5fb45f58c66d3f03dff609275e48dd400888b48fde1eaab230307ea7ef85c(
    *,
    input_type: DataTypeEnum,
    name: builtins.str,
    allowed_pattern: typing.Optional[builtins.str] = None,
    allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
    default_value: typing.Any = None,
    description: typing.Optional[builtins.str] = None,
    max_chars: typing.Optional[jsii.Number] = None,
    max_items: typing.Optional[jsii.Number] = None,
    min_chars: typing.Optional[jsii.Number] = None,
    min_items: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__973ed220eab16c66c7dad97ae328bf10d2183329d36210742ed24d969bf02bb4(
    *,
    allowed_values: typing.Optional[typing.Sequence[jsii.Number]] = None,
    default_value: typing.Optional[jsii.Number] = None,
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__323390a01c89753024c2222fa8f2091572bcdbab8fbfd24e6eaa0ef37c93f532(
    *,
    aws_api: builtins.str,
    aws_params: typing.Mapping[builtins.str, typing.Any],
    service: AwsService,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f47481d308f1a3b89f87fc0c406ba82f8cfb8cb6e22d75c24f6dc941487e8131(
    step: InvokeLambdaFunctionStep,
    *,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73d6a7ced114ae69d19b3bdb05db9c65c7aeeaac29c30a07f7f5619d6de8a441(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e53067ee3c89c67282684267722155b543072ce0afeae1e6c17640c5b0e5cfca(
    *,
    integration_name: builtins.str,
    body: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63e06ea67a57734415507fbd1dac7b43d5a71ae3356fc3a8e0d25ebca6d8e059(
    *,
    response: builtins.str,
    response_code: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41807eb55ad8f1320d3657c53e327850403a376d21061ba592bf0ec074a450d0(
    step: InvokeWebhookStep,
    *,
    webhook: IWebhook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d212a8d5c4e5315fa55a603db0ff35265941ca2c50b4a836d5d67dbb8bfdf359(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b5c75e10d138930b6c92371ee29cf6cee6302cf86c5f68c8f21e3d7a77259e8(
    *,
    webhook: IWebhook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6fa55f292dcf4f64c87ab654380d7999be9e03571d07233251900f085e2fd8d(
    document_path: IStringVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7f6a61531372bf0b927fd89d64e5a8fa69aaf44094ebbac52ed8b585fef2a57(
    command: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e66f60bab2520aba781d566e21e313c945431c98c8f8ba4060cb4e87eb3dcf5e(
    *,
    allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
    default_value: typing.Any = None,
    description: typing.Optional[builtins.str] = None,
    max_items: typing.Optional[jsii.Number] = None,
    min_items: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce5360dd2758a5905993c34c76ab2707a6f6d8f539c153093a0c746e8d659ceb(
    _approver: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a42044c4a013cf1701c1d7b9a429dc75c74f020bd9906a861523654ddaf889c(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7dcaeab296c9424f796f7a2e7776544cab4f40f5a851648fc820a13023ec15d(
    aws_result: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c3e71203c242da00f0341d5abf4351a7ae698a204b0db101a531c28c7ff2f3c(
    when: typing.Union[Invocation, typing.Dict[builtins.str, typing.Any]],
    then: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__838b47553c5d81f6ed97a4d0ed8889b1e7ad07ec2175e232340fd80d3df80453(
    command: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09e0bc2e6fc9e746f7c6fe93f39190f29bb9ef596391316c23f139f2716c268b(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5780f8e67c755fc9a8f89b34e2cfd59a1473b628a787fcbaf28c5cacdaa4cd0(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29411d88654475bebe297204a72ca37710ea099926e29d4945ceaa0eef4d44ff(
    time_millis: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac38c36e15680199e6a15bd77b38f36ab40a876e7009684428a09263089721ae(
    name: IStringVariable,
    version: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c5a7bc1b0376c7cfbadbd38e86c0549cfba1a73513f9337ce5292286e8de6ee(
    _value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f90348fe2876e5d329743a22aae7d729e736f5af082caa443097228eefee21cb(
    step: AutomationStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2b9ca4472331c9497f119c79d5e6d6e8029ac63afe349f1c9f3235d88e7ea43(
    step_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3498939b57e11b8d7024f63b453c77628f03cdab60c7bd7bf7317335e266040a(
    current_step: AutomationStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__90c36bf174dcf5dd70f82c702e08abc3147ef00e9e8c48252a965dbcf2566f82(
    operation: Operation,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a46688287e75e31dc952f4a33bdcf4e7bd4ed0768baa86a10933e2ae968d14f(
    operation_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a37777b237e631f29895c72fd547601179c2db530e6ded7c11ed39474706f09a(
    value1: typing.Any,
    value2: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0773784203075686ec2f2dd2513160c2d1f0bf6a149de0216f5f50e5ca1354f6(
    *,
    name: builtins.str,
    output_type: DataTypeEnum,
    selector: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfa24003a0a7634765a53d3de1809b9cc8fb3fbd069a951d63d214376974222b(
    step: PauseStep,
    *,
    pause_hook: IPauseHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e63778de98c1074ad0817ce000bd3d4f31ad4aaced1ba30c1115a92d92fd7701(
    _inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4c847737937c4231e03a271d3187bafa175952bd5d08cf0b2654812e38e2426(
    *,
    pause_hook: IPauseHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93983b5cc3e83f684b195199bb7bb8fcbf98017894e10f55098379035c7d36e0(
    platform_string: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd89b6563970985c80a59125df55bd77fdc1e4c83cefe5635d9400a952d903d4(
    platform: Platform,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02e0e37063e7fb3bd8e5969ebe20519909807d03a59c6b014cc7c37b47edd509(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36b78155d9c9d6c672dea571628ffc66a8d564ef6554decf0e89ed7554f13859(
    *,
    operation_type: Operation,
    variable1: IGenericVariable,
    variable2: IGenericVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34626c8f6bf90067210f71042273b75ff6cee6c5b3efc114e8c7a3383c00188a(
    step: PsModuleStep,
    *,
    environment: IEnvironment,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3be0ee23c34e1614d63c3e8157920a814a819d54492f6c9237183b26f18640e(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a8640978189931df91b471ab404af74be2984d2596168e8df6a8ace6d22a7c4(
    *,
    approve_hook: IApproveHook,
    aws_invoker: IAwsInvoker,
    execute_automation_hook: IExecuteAutomationHook,
    input_observer: IObserver,
    output_observer: IObserver,
    parameter_resolver: IParameterResolver,
    pause_hook: IPauseHook,
    run_command_hook: IRunCommandHook,
    sleep_hook: ISleepHook,
    webhook: IWebhook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e09146e44b313a7de2f23fc73663117dead5177b084ad4b9b017ed14960e61b(
    *,
    environment: IEnvironment,
    simulation_platform: Platform,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c6c598e8b8217cb314bfa396a8b231a832b30afbbac935879ef8b94a2d6fc50(
    *,
    command_id: builtins.str,
    status: builtins.str,
    output: typing.Optional[builtins.str] = None,
    response_code: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f24200fad9cefb9c3a495ede05b359e8b60657017fdfdaee3e733c98b119b1c(
    *,
    document_name: builtins.str,
    targets: typing.Sequence[builtins.str],
    cloud_watch_output_config: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    comment: typing.Optional[builtins.str] = None,
    document_hash: typing.Optional[builtins.str] = None,
    document_hash_type: typing.Optional[builtins.str] = None,
    max_concurrency: typing.Optional[jsii.Number] = None,
    max_errors: typing.Optional[jsii.Number] = None,
    notification_config: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    output_s3_bucket_name: typing.Optional[builtins.str] = None,
    output_s3_key_prefix: typing.Optional[builtins.str] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    service_role_arn: typing.Optional[builtins.str] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88afce5eb250444d9d9ff3910fde49f11e47e81e17996f50260e32bce1bfba07(
    step: RunCommandStep,
    *,
    run_command_hook: IRunCommandHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac151379d225837120cfb987182a1ab92c593d0ec16c674345a51e9b9f95f9fe(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__676945251db66ccd57de288b8397fea6f4c2bf1ba78ea674a47fbd2c545aa959(
    *,
    run_command_hook: IRunCommandHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__307b83d9860b5335fb34f0fc4cbdd980e27a29cdbc08dfd92f2a6adbcc3b404f(
    step: RunInstanceStep,
    *,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4ec5870a0be147b7294b99ea4c5a63bf1e421828eeb5ec8efc7753cddc02a69(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8b62843905cc949080ef464eb415e5f63323d695bd6ec80e8d047007c6839c2(
    step: RunPowerShellScriptStep,
    *,
    environment: IEnvironment,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4716f35a1b81a1870feb5c2f9726a9cc63526839140af14818c1388332e086ff(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1a32cfebb016378e3a82a8db21a9dc007482f25263cf8d81470b20425c89b94(
    step: RunShellScriptStep,
    *,
    environment: IEnvironment,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7489209e007758049b3778523bdee589acd00d8b3a8b3b90e7dbf7bd931fad6(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80e8e384e09bec652d78ad911c30fd3cd8a016229f95be6f587c1ccd94ca0b20(
    *,
    path: IStringVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95dda5e817a56a1cb29821460ee6ed658256da8a06ae7f9d340218678c070d53(
    full_path: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e095e40715e1564535f481aca90d04590e67850bd1a324eb4b0b80101251b67(
    code: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66a0f0035a625e3974069e210c6e744a92bfa2cff73502f8ffc23aa4530c9d2a(
    suffix: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8baa658a2568618064ffee9b4c5955a049266674e024a435cd3932d4a80c6f33(
    runtime: builtins.str,
    handler_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c081ddabe99a9dfdd2dc3c0ce2ffcbd10c46de8e82fb6783d9fd8aafad84455d(
    version: PythonVersion,
    handler_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b640cde94010758da5d149620b86266e162eea51a33bccbfc0ec1fc72bfceef9(
    code: ScriptCode,
    inputs: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57f22996dac5468ad50f65a404c1be0a2ccb9f11053ed0ef6c9c959a593a9de6(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab26926b5e1fbeeb1c5060acc57879e6ff361d9e09df2ca0000d9fdec39b50b4(
    secure_token: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3b7f0e01c35ee4ce3153c7b939d47423de71a3ba685dea7672789c0f7ce9e80(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__705ccfa75e3f01a73af05ace9b99d5ab042c2fdc5016fcbaa45927f39b94e860(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0057ba3e46b2c1b6b04d3fa682642b09a93f307403394adad18d2b16436a2436(
    document: AutomationDocument,
    *,
    approve_hook: typing.Optional[IApproveHook] = None,
    aws_invoker: typing.Optional[IAwsInvoker] = None,
    execute_automation_hook: typing.Optional[IExecuteAutomationHook] = None,
    input_observer: typing.Optional[IObserver] = None,
    output_observer: typing.Optional[IObserver] = None,
    parameter_resolver: typing.Optional[IParameterResolver] = None,
    pause_hook: typing.Optional[IPauseHook] = None,
    run_command_hook: typing.Optional[IRunCommandHook] = None,
    sleep_hook: typing.Optional[ISleepHook] = None,
    webhook: typing.Optional[IWebhook] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e73e5fd5e0bc4a40acc3ba0533b9bd22ac241c9ce95b4e8ff9942061a22dba20(
    document: CommandDocument,
    *,
    simulation_platform: Platform,
    environment: typing.Optional[IEnvironment] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21dc76e4551c05ec86159ee0de72ed16e421de5401ac77c2648a085ae4a1c53e(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50fbb7dfba5b336b55281684484180f15dc54d5c98aa19bf5a79e5b85d7a16a2(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c459d580c024550bd368419ad91dc4d6e469c9fdcc8f0dc59c3c85583edc4c3(
    *,
    approve_hook: typing.Optional[IApproveHook] = None,
    aws_invoker: typing.Optional[IAwsInvoker] = None,
    environment: typing.Optional[IEnvironment] = None,
    input_observer: typing.Optional[IObserver] = None,
    output_observer: typing.Optional[IObserver] = None,
    parameter_resolver: typing.Optional[IParameterResolver] = None,
    pause_hook: typing.Optional[IPauseHook] = None,
    run_command_hook: typing.Optional[IRunCommandHook] = None,
    simulation_platform: typing.Optional[Platform] = None,
    sleep_hook: typing.Optional[ISleepHook] = None,
    webhook: typing.Optional[IWebhook] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0c102951a3507961d6e7970dc1e1479e3ed8ddac46ddedab05bac0254ae648a(
    *,
    executed_steps: typing.Sequence[builtins.str],
    response_code: ResponseCode,
    outputs: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    stack_trace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e01e1f530d0d92e24832816c862e424f4fd37a16f84302b2ed04e4b096fc90b8(
    time_millis: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__223df04da6068cea9edb22daa0c13f487ec190f7318bea1f45fbd02b0443c568(
    step: SleepStep,
    *,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2998bc6e39655c561ebde8e0624fe48d8e69ca0128f2bfb3fe685f5b8526bfa5(
    _inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__642d1616655c906e054542e9bdfbea706653d7a4217be34965fce5a6dd9a0eb1(
    *,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd6936d429de9627e458e84e2940817eb0dfadbcd69f60698b88fe214eb33074(
    *,
    parameters: typing.Mapping[builtins.str, IGenericVariable],
    target_account: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55faabeee86a752a753a75f8210cffcadf87ed1a36685bb357e31a71f3760f52(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    assume_role: typing.Optional[IStringVariable] = None,
    description: typing.Optional[builtins.str] = None,
    doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
    doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
    document_format: typing.Optional[DocumentFormat] = None,
    document_name: typing.Optional[builtins.str] = None,
    header: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[builtins.str] = None,
    version_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa0a79e56c9e32f2cedad09975705da52b9cc8f8e30f635544d1dabd18f52738(
    *,
    document_source: DocumentSource,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__540429ca2b86f7d178406b3dc0aa91c8e421a233d6b4fb5a9eb61af08995eb36(
    *,
    assume_role: typing.Optional[IStringVariable] = None,
    description: typing.Optional[builtins.str] = None,
    doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
    doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
    document_format: typing.Optional[DocumentFormat] = None,
    document_name: typing.Optional[builtins.str] = None,
    header: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[builtins.str] = None,
    version_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2350a191f371fb089711a9b543e216792db74a4f294bf2275deb45c7e746979(
    document_name: IStringVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__350b2a7331c989f3b90326eb2a0f6d01e85502573a25c0722dfc9d42c6423174(
    secure_token: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b5ed4a1e3571ea96c70ed9fe7af3a422f1b5510fac0f5e34714d3d54e02342c(
    _inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__623c83a1748fc8526811375d2a3cd6f277db599fde7fcf886ecb56351ce23dc4(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d65213af8dedc01ba2d1fa8bc2fbf1fe219c3c2d293e348014f3f7d4564a99d5(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__479fe23be47f96ab416c7ae3db640997dc2bd4b8f9f8767be0ae7846c16f72a1(
    step_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c4ccb5cca9a0fae89e1d565e570f2bfd5784af28d6778f7a4d802e0b7602ec3(
    step_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__119283c0cb6af10a44f3d76dbb5e8c81758e0a397e799ae20d903ea837f850bf(
    step: AutomationStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__499e8d737216aa2e3ce772e20f71b31a7306ecdb1100e4ffd8326ab9ee7cecb5(
    all_steps_in_execution: typing.Sequence[AutomationStep],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__608ac5c214a9f40a1a8db40859dccd45e6b332042c0445dc5cc9377aaaedafeb(
    stack: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    document_file_path: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e791bb2e5fb72b9b8c5bb4b2df8433afcc36544fa4e6929c5a70775c15f3189b(
    stack: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    document_json: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ec9a2e49b1db561eb9765c6c2cc4f7da0b1a54f7a60bf2988d109c2526c5800(
    stack: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    document_yaml: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3b5f835194f1408feefd3eae90c01389e256dd19967e855b30d2f84d42dec22(
    format: builtins.str,
    variables: typing.Optional[typing.Sequence[IGenericVariable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80417c00e6968ee7242ba99b34f2aa9e33e5eacc036305b9cb84e4d818e387dc(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d054c7bd32ab1de4b03c81a8555fe552a04d6434e6a2dbd86c87f57900f69a18(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__efb571e0a13d562546616b357c579bfbf498f1305753c2a8b27e36aaa20f5f3e(
    *,
    allowed_pattern: typing.Optional[builtins.str] = None,
    allowed_values: typing.Optional[typing.Sequence[builtins.str]] = None,
    default_value: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    max_chars: typing.Optional[jsii.Number] = None,
    min_chars: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__10de2b64b8adea4fbcc0ed15beac86e16c86333ffb64461ab90e7ce474419321(
    *,
    allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
    default_value: typing.Any = None,
    description: typing.Optional[builtins.str] = None,
    max_items: typing.Optional[jsii.Number] = None,
    min_items: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c65a8ad77940a99976eb5d4bd4674ec6de0e377571dcdd7b546eda0d22b33ab3(
    *,
    allowed_values: typing.Optional[typing.Sequence[typing.Any]] = None,
    default_value: typing.Any = None,
    description: typing.Optional[builtins.str] = None,
    max_items: typing.Optional[jsii.Number] = None,
    min_items: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f158db782493e58133e3ece33de629cea9cbd043f4a9e4a90ce551a56cb21d83(
    stack: _aws_cdk_ceddda9d.Stack,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5dc5c6bb01e8e8f849db9e6989504d408cc6163e26309e0c1cfa1aeb14ed919a(
    step: UpdateVariableStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1050c9a8bedf68882bba979a587ef94f110da77f0fcfeebbb32be3852f9d1918(
    _inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e3b092fb25532e77bea8a1e1d45cb166256fb632f6e62311bf1e0f3581e136a(
    auth_method: builtins.str,
    user_name: SecureVariable,
    password: SecureVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d558cb7f377a935a3620d2a6388f163549a56e1425668f9fd6d44e07ff4cca2f(
    step: WaitForResourceStep,
    *,
    aws_invoker: IAwsInvoker,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c46a03c61daf2fa8851ae0804f6d60ae75361ef8e123fb7f520ec138cc5eee6c(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45c7781236915e1f455e27c84baabf1e8b1769307a38531bcc2407d544e884b1(
    *,
    aws_invoker: IAwsInvoker,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2ad6f11a7ff0a5695c8baab676ffdc34ac6ce2c7217de38d3e2097e1c0be1c9(
    aws_invoker: IAwsInvoker,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__17e0001210b642eccd4650a137389225f10889a096480b9b8337af2cf0bb6a9e(
    aws_invoker: IAwsInvoker,
    sleep_hook: ISleepHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ccc19f2076c9ed681b6f44118e1aae7bfeb23cc58cae727a58878d215383d600(
    approver: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61def220db667a6b02cf63197776e934be316a12a70027d3965a5b81aff560db(
    step: ApproveStep,
    *,
    approve_hook: IApproveHook,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c76072a3c8733f65e9cb260a6043f1092ceaeaf106390e5439ca0ee999be0eee(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd9a7c65c28695b830d2c6a018a40e9110af0a013cdeea3017f42f33487d1a24(
    arn: IStringVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b3c34686aa212fb340ce10adbf4828b114136d187bd6483502b73bbd254f3f8(
    step: AssertAwsResourceStep,
    *,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4a39dceadf79847081ba4db9f4718e48f2fda36cf13b91ec3f8c93dd61b6ee6(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6cb9b5a3ede1755146d415188d9d8eaa9a844c066e6c0eb1c8b4ca1dc781f4a2(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    doc_variables: typing.Optional[typing.Sequence[Input]] = None,
    assume_role: typing.Optional[IStringVariable] = None,
    description: typing.Optional[builtins.str] = None,
    doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
    doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
    document_format: typing.Optional[DocumentFormat] = None,
    document_name: typing.Optional[builtins.str] = None,
    header: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[builtins.str] = None,
    version_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee93f037f1dbb7b8807c3c4a9cd849d3a977bd210f755747a8380695423a400b(
    component: IAutomationComponent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46391b4c7e27df83d7bec77d20338301f2d0d0b6eb89143ce3049ba678676848(
    *,
    assume_role: typing.Optional[IStringVariable] = None,
    description: typing.Optional[builtins.str] = None,
    doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
    doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
    document_format: typing.Optional[DocumentFormat] = None,
    document_name: typing.Optional[builtins.str] = None,
    header: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[builtins.str] = None,
    version_name: typing.Optional[builtins.str] = None,
    doc_variables: typing.Optional[typing.Sequence[Input]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7992865847ac10ea71c720c2fc326ee0a6cafee2e57562ea13b167fc4d7f9685(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d639efe1227fc4fb94130fa7ec73aa07f4046d03c8c6a8abfcbd07a5ccf9803c(
    doc: AutomationDocumentBuilder,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c25be20b59ce5714aa8bb145b6ad6ed0325a709c02e045748a809c54e924da86(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f14ae60dc0fc969e7920bf4663b059d5edad49ff0423d1e35ab3b0094b787aff(
    value: typing.Optional[typing.List[AutomationStep]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54e821c195133416e2803d57302081e8ce7fc9454719c8f08d552ed027111f2e(
    value: typing.Optional[AutomationStep],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd5ae5e2ad458039f35c558280700e56831a3904f574b77a7ee64f6eab6dbd2e(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a85a8981fa1aadf64f69dcb32c6a32470424d51d10842ed1935b17032897fbaa(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    outputs: typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]],
    api_params: typing.Mapping[builtins.str, typing.Any],
    pascal_case_api: builtins.str,
    service: AwsService,
    java_script_api: typing.Optional[builtins.str] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b925c698875296ff2de682c5a20f4da7714a6bda6e5e46e1ae9c5021c998304(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    api_params: typing.Mapping[builtins.str, typing.Any],
    pascal_case_api: builtins.str,
    service: AwsService,
    java_script_api: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30592f3faa79304516d2422e0c68eacaaf835b91e7fc299e54aaf274c49665c5(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    choices: typing.Sequence[Choice],
    default_step_name: typing.Optional[builtins.str] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4e1a9a60f92e4305ce1ded21b258e57a4445102c1f64e061854ed26f7a3c233(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    choices: typing.Sequence[Choice],
    default_step_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b3007f7f72116e2c901ec5d8aa91c9c0a821ce711f8a35a3336a98a946c18c4(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    aws_invoker: IAwsInvoker,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad87032e9de062f3fe2f0b0fb7c54a88461d6e8a3b81871059d03c607682b531(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    desired_state: IDesiredStateVariable,
    instance_ids: IStringListVariable,
    additional_info: typing.Optional[IStringVariable] = None,
    check_state_only: typing.Optional[IBooleanVariable] = None,
    force: typing.Optional[IBooleanVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27f8f7a0ec98801b1a6e982daaaed58e732dcd75e694cafb2ec751d4d5cf06f4(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    desired_state: IDesiredStateVariable,
    instance_ids: IStringListVariable,
    additional_info: typing.Optional[IStringVariable] = None,
    check_state_only: typing.Optional[IBooleanVariable] = None,
    force: typing.Optional[IBooleanVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7b11d6e831c32a664c6bf82ac018aeb7cebd4549cb77841c58186c6ea8a730a(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    assume_role: typing.Optional[IStringVariable] = None,
    description: typing.Optional[builtins.str] = None,
    doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
    doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
    document_format: typing.Optional[DocumentFormat] = None,
    document_name: typing.Optional[builtins.str] = None,
    header: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[builtins.str] = None,
    version_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b2eb45f67ce9c873fc8ab6f172036c146cef2cf9a0243d36126cfed4578991e(
    component: ICommandComponent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f9235ffee63f7b4ee7b3d360942c6e683e349a4f2e4702da8886a65978cec8e(
    *,
    assume_role: typing.Optional[IStringVariable] = None,
    description: typing.Optional[builtins.str] = None,
    doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
    doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
    document_format: typing.Optional[DocumentFormat] = None,
    document_name: typing.Optional[builtins.str] = None,
    header: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[builtins.str] = None,
    version_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23a8a2cc71aa02166e1aa70e9556b2637410af278733c3c498122e6a3d3f47b4(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b114a3810c0d8a38abfa9510436e3b1a2611af4b75df371b6c43507c9c61a8c(
    doc: CommandDocumentBuilder,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfbd788e4adc67c6675b4da341b20a0323921aa2fe290ca934519e7ec965444a(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89ae80bbdd8175616876b46c91577850d2e6d0e540b94738974d399146222dd4(
    value: typing.Optional[typing.List[CommandStep]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a08a6fa8fad98b5461b43d5c0a9284960480b03ebec5bf86017a631e0fa462c7(
    value: typing.Optional[CommandStep],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0fad36300f8370653d919e8469301c36c61a6575dc07745260cc1819cbf434f(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c888f774487adb962b675782ec8e9968e62b25e66451c9a3939104746b84f98(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52206c901f0b19df1344121d460384f28bfd0569fb8c729103803b924d9f51cf(
    doc: AutomationDocumentBuilder,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22ccf13ab7a7e56952367399a9b44feea5832519610172abe1036e1e078c2e7a(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e329deb689b679c55bcafd49df4329152480c442e2d51836c571f3e296d195a(
    doc: CommandDocumentBuilder,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e73df770d7e83302d8c2cee40111719342403375f32807782449b7e7c60f7220(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    action: IActionVariable,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61c175d2bd563b3d76a69396e8002b2c736b68c33796ee1bcf4e9f034a80cfef(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    action: IActionVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa06bf91636e796eabf1604178523146f002b607ea03b36505ffda008602e29e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    package_action: IActionVariable,
    package_name: IPackageNameVariable,
    additional_arguments: typing.Optional[IStringMapVariable] = None,
    installation_type: typing.Optional[IInstallationTypeVariable] = None,
    version: typing.Optional[IStringVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__950d968d50e894ec93a3e6e22cd9c390c7d4a6057d6206c31a096e9d0b336cb0(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    package_action: IActionVariable,
    package_name: IPackageNameVariable,
    additional_arguments: typing.Optional[IStringMapVariable] = None,
    installation_type: typing.Optional[IInstallationTypeVariable] = None,
    version: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__542505bfe46ad08a63e60a06c7b1cc819951f96bfa85edd760a824569ac928a4(
    current_step: AutomationStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__727d7c37ddd5f32706b7034ca362350f2da0a049084b10379133053117bacdbb(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    image_name: IStringVariable,
    source_image_id: IStringVariable,
    source_region: IStringVariable,
    client_token: typing.Optional[IStringVariable] = None,
    encrypted: typing.Optional[IBooleanVariable] = None,
    image_description: typing.Optional[IStringVariable] = None,
    kms_key_id: typing.Optional[IStringVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__daed2d5b951de8a8f14e12921272a7b3bccc46876753cf68921d0b884b1acebe(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    image_name: IStringVariable,
    source_image_id: IStringVariable,
    source_region: IStringVariable,
    client_token: typing.Optional[IStringVariable] = None,
    encrypted: typing.Optional[IBooleanVariable] = None,
    image_description: typing.Optional[IStringVariable] = None,
    kms_key_id: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__614d8c3cb4e9c27a19d53a452d37d9841431902a11b9d5f2d1b9306b0b29053c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    image_name: IStringVariable,
    instance_id: IStringVariable,
    block_device_mappings: typing.Optional[IStringMapVariable] = None,
    image_description: typing.Optional[IStringVariable] = None,
    no_reboot: typing.Optional[IBooleanVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__257966723c4cacb3b5de02e730f4b6f45ef1124974014cf414c53ff40ea20840(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    image_name: IStringVariable,
    instance_id: IStringVariable,
    block_device_mappings: typing.Optional[IStringMapVariable] = None,
    image_description: typing.Optional[IStringVariable] = None,
    no_reboot: typing.Optional[IBooleanVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6dbbc7397597fc834f7db22620a8be37e4c590ce192423159bf101d96b4726b8(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    stack_name: IStringVariable,
    template: typing.Union[BodyOrUrlProp, typing.Dict[builtins.str, typing.Any]],
    capabilities: typing.Optional[IStringListVariable] = None,
    client_request_token: typing.Optional[IStringVariable] = None,
    notification_ar_ns: typing.Optional[IStringListVariable] = None,
    on_stack_failure: typing.Optional[IOnFailureVariable] = None,
    parameters: typing.Optional[IMapListVariable] = None,
    resource_types: typing.Optional[IStringListVariable] = None,
    role_arn: typing.Optional[IStringVariable] = None,
    stack_policy: typing.Optional[typing.Union[BodyOrUrlProp, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[IMapListVariable] = None,
    timeout_in_minutes: typing.Optional[INumberVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb3eac84ba274be348d8088d3de8bcf6df1324114fce807eeb1806e3dbec8f20(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    stack_name: IStringVariable,
    template: typing.Union[BodyOrUrlProp, typing.Dict[builtins.str, typing.Any]],
    capabilities: typing.Optional[IStringListVariable] = None,
    client_request_token: typing.Optional[IStringVariable] = None,
    notification_ar_ns: typing.Optional[IStringListVariable] = None,
    on_stack_failure: typing.Optional[IOnFailureVariable] = None,
    parameters: typing.Optional[IMapListVariable] = None,
    resource_types: typing.Optional[IStringListVariable] = None,
    role_arn: typing.Optional[IStringVariable] = None,
    stack_policy: typing.Optional[typing.Union[BodyOrUrlProp, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[IMapListVariable] = None,
    timeout_in_minutes: typing.Optional[INumberVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f20ee48975fccefe7ac2ac7d8a8a4924297a6792abdaa58503d4ee9437f7542(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    resource_ids: IStringListVariable,
    tags: IMapListVariable,
    resource_type: typing.Optional[IResourceTypeVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd8dd262701d5e216420dd9c2599aea6bef647a5838eca49d42ae0c7c7256aaf(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    resource_ids: IStringListVariable,
    tags: IMapListVariable,
    resource_type: typing.Optional[IResourceTypeVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7918a829893ca74ddc5018c171bfb73f0ff2f9daafc8a965ff5e738f83c50ae7(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    image_id: IStringVariable,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d27e88de9d75b06b2b9ee40c00c4b943627b3f5e598a137ab30b3ffc073373b7(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    image_id: IStringVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c454de90a263684d2e0248b180a4041752876ec2c13be1894f487426c0d520f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    stack_name_variable: IStringVariable,
    role_arn: typing.Optional[IStringVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b933ebf2931383d7c3dcdc65ad8efd333fa3e56b0b11b0238be1082729e055e0(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    stack_name_variable: IStringVariable,
    role_arn: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a21a7e8d197f3aed68ed11fa6fe97a6c7fed8db50baf18c4b588b5ddacad07c6(
    format: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69c0c0efd00a365ac9a3bdfc6b5230c00b6574ebf6081ae072d0aec92bd29788(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__686016468b67aea85c5958cb763ff99367475ef22b6a0525abae0b6df2f84abe(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c923d6f71533c5f77177a04acb7ec6c801abcd15c8134e72b5cba22b96e6744(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82e0f56a7ca1ab281e211728631a7f6c2d3473bb083c4ef4b693d1361d41a19c(
    container_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4b1471cf18302c6579d1bf8e49a61b60d8d9068bf7220b665417614f34d7f09(
    image: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d6590259dea715697c65615d0e1f22c5df49e5f7be843fbab2ce06da61adda6(
    command: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf776619863c7996b1daeec6b7642cce00bcd086f961342758160415d66b423b(
    *,
    executed_steps: typing.Sequence[builtins.str],
    response_code: ResponseCode,
    outputs: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    stack_trace: typing.Optional[builtins.str] = None,
    document_outputs: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf8a15a6f1a8c881a27b8c58586b34d818c1083e8bc9cad843d6f0fb97c9b9fb(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    directory_id: IStringVariable,
    directory_name: IStringVariable,
    dns_ip_addresses: IStringListVariable,
    directory_ou: typing.Optional[IStringVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__889cbdf96b162f8834876a74631a7187864a639e8667cb54886e33f737cbed67(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    directory_id: IStringVariable,
    directory_name: IStringVariable,
    dns_ip_addresses: IStringListVariable,
    directory_ou: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5aaf3d28eeab928673ebba5f4243a0fcad37126f7763d1ba633b38e52260ae65(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    downloadable_content: IDownloadableContent,
    destination_path: typing.Optional[IStringVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e964b124d913c4a2da4f1ebe04532981cb76e9d42719b9a959c0d61f7720f461(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    downloadable_content: IDownloadableContent,
    destination_path: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__769279ffc5e70495158bfb2d180c998a80950b96cd1a2e2a9e881e2a6d6363a8(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    document_name: IStringVariable,
    document_version: typing.Optional[IStringVariable] = None,
    max_concurrency: typing.Optional[IStringVariable] = None,
    max_errors: typing.Optional[IStringVariable] = None,
    runtime_parameters: typing.Optional[IStringMapVariable] = None,
    tags: typing.Optional[IMapListVariable] = None,
    target_locations: typing.Optional[IMapListVariable] = None,
    target_maps: typing.Optional[IMapListVariable] = None,
    target_parameter_name: typing.Optional[IStringVariable] = None,
    targets: typing.Optional[IMapListVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ddb66543f834e632b21143b76d7fbc589eefd88b9db39e4a14734632ff193a9f(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    document_name: IStringVariable,
    document_version: typing.Optional[IStringVariable] = None,
    max_concurrency: typing.Optional[IStringVariable] = None,
    max_errors: typing.Optional[IStringVariable] = None,
    runtime_parameters: typing.Optional[IStringMapVariable] = None,
    tags: typing.Optional[IMapListVariable] = None,
    target_locations: typing.Optional[IMapListVariable] = None,
    target_maps: typing.Optional[IMapListVariable] = None,
    target_parameter_name: typing.Optional[IStringVariable] = None,
    targets: typing.Optional[IMapListVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2826716496c296ca3069162df86bf193e6b74897b12f5e11a93ee52fa58505d2(
    stage: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    code: ScriptCode,
    input_payload: typing.Mapping[builtins.str, IGenericVariable],
    language: ScriptLanguage,
    outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0c4a09d9627727ecda0a0c2400fe5cac32d314e058fe0e41c4b563b58b66abc(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    code: ScriptCode,
    input_payload: typing.Mapping[builtins.str, IGenericVariable],
    language: ScriptLanguage,
    outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04e21ef6aa0f688be463495ce92b89574506008b962dc3865108483a302ff26b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    state_machine_arn: IStringVariable,
    execution_name: typing.Optional[IStringVariable] = None,
    input: typing.Optional[IStringVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8f637107edb9d13c1dbe1d8361731b75e9848a94f0b5dca69aa013960d4a1de(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    state_machine_arn: IStringVariable,
    execution_name: typing.Optional[IStringVariable] = None,
    input: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a096281fc475cc6926691794d748aa4a1d511e7425046a4d02839bd0cd4cb53(
    full_path: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd16a56052849ea3ca39c71e035ee1771b9a8eff9a670a6d8bb5eb23c44ff829(
    _suffix: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__439c3ef61ff4ef64c8db771ab95a5ae493f98d3771d7da8926dfeb011d5993d2(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__570ca4af0d5cd41c7829c16d9aaa691286beceedaf461065a2eee4e4f79db0c4(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d701450914e899cd04b5ba4f7ba7163aeef74c0678a893f41a6e4f6e4e536ab(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62776a7ec71ddf417f77ba60518b6c738f82bc55d2cf2697dde856d0858f6bd3(
    val: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f4e529da2d1c9ab3f7d99fa4b1d7d6bde60851763181caa65a460b37eac72b5(
    _inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b2499253656d74e32b98eccfefbaea32fa90141582bd2a3983e6d6b82ab2e54(
    val: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7422e708fe99a05a9f2a3ce26d3fbf30d52d7795a679e430d8e729ae65beea5e(
    _inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d38e118d6d0afd7c57c552bc2c48e3cc470a81e6162ab0737482246f90c6324c(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d3750ea78c9c599657c6c794c8c7199a0e68faca4ed784d957499edbf77535e(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6e0535f0e492b832de4b517e12aea6ca1daba79117817ae5d19f95b00f5c616(
    inline_code: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__641ad856100feac96e516e3f593bab142dcfe8cd078f2f3e45338d275d10feb7(
    suffix: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f988a082bb79889c6c8ab5d10131faef30d25b8c9471b2ca218842787be9e065(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    function_name: IStringVariable,
    client_context: typing.Optional[IStringVariable] = None,
    invocation_type: typing.Optional[IStringVariable] = None,
    log_type: typing.Optional[IStringVariable] = None,
    payload: typing.Optional[IStringMapVariable] = None,
    qualifier: typing.Optional[IStringVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__260d8a9bac3171aa48a2140b029bfaac8e6d506b494bfeb06cd9b971df358fea(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    function_name: IStringVariable,
    client_context: typing.Optional[IStringVariable] = None,
    invocation_type: typing.Optional[IStringVariable] = None,
    log_type: typing.Optional[IStringVariable] = None,
    payload: typing.Optional[IStringMapVariable] = None,
    qualifier: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d98b66121c98c49c21e9a829f3028cf525b5bef9a6411b6d120a9ad81c31b7c3(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    integration_name: IStringVariable,
    body: typing.Optional[IStringVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12f6a385027a66ded166fcbc0eda468bfea513bbacc2be059f649605120e592e(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    integration_name: IStringVariable,
    body: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4551ba08c76458e224d56e58450cc9141b6f63575c6314dbe83a5c15e1bd1a2d(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70ca355cfb1db717b7c1ecef889d642e917cd359941a56f5e64c5ad5949af19c(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecb8de4da8eab3110879e9a8bab9664936bb816da64e556956d6e6c7290093bd(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da6cb7752ad49a3e323a6aaa792ca41cd67e70bfc298a33792bf9f7ee82b3ca0(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1e30614d1a67f6c389f87f9682d78a6ef9f5363adbbbe93d26651afc49a9846(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a79b3e3d9b0088961c812f62e69fed25f03e48c9c7a771bb0393c3c18f8cafe2(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b0f1755fa1e6ae327b973036eb2089e58fbc844a906310a73b8d321491ee295(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27d2c8926ce8859189b386b7f4f28611190b1266b6c8d9eb9331c26c9cae61d7(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75f939d957d3590d1874284f8de414db2703118e140d4d1f7dae3c94890cbbd7(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1007fe234c4cad1b374433a2cb0a5b9459d317a688e4305394ce15928887aa63(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f26b3a34abe845c955ac47d0ecc284d4b9858b8cd9054f3314f34648e7c9226a(
    step: AutomationStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ea077d727b5346dfde397a16343ba8142fcceb382c55e162fc43b27f50f809b(
    step_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a70b6e0c99aac7400efda428da0dcd2506e270507823111a712a6b9af60bd54(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b6071ba1c4a032f783155589a3537c1f8dd75514fa844dcc16d69877ca2cfe4(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    source: IStringVariable,
    run_command: typing.Optional[typing.Sequence[IStringVariable]] = None,
    source_hash: typing.Optional[IStringVariable] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    working_directory: typing.Optional[IStringVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18e479aed07c35924b07ca205129ceccaeca655bb4211314db0066de99f302e8(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    source: IStringVariable,
    run_command: typing.Optional[typing.Sequence[IStringVariable]] = None,
    source_hash: typing.Optional[IStringVariable] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    working_directory: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2b3c67c89c3b5082e59c90f7266ef202e645f8c3b11283bc973ef3e760ac05e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    instance_id: IStringVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ac06fef9ba268c1c74c1ec0314914a6fb20311998398cf9caba444894cb1b8bb(
    doc: AutomationDocumentBuilder,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae82e9b3e9ffdd61fb04a49e1306de49cf4d8e5da1eda394a0f308c21ad6bda3(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    document_name: IStringVariable,
    targets: typing.Union[IStringListVariable, IMapListVariable],
    cloud_watch_output_config: typing.Optional[IStringMapVariable] = None,
    command_timeout_seconds: typing.Optional[INumberVariable] = None,
    comment: typing.Optional[IStringVariable] = None,
    document_hash: typing.Optional[IStringVariable] = None,
    document_hash_type: typing.Optional[IDocumentHashTypeVariable] = None,
    max_concurrency: typing.Optional[INumberVariable] = None,
    max_errors: typing.Optional[INumberVariable] = None,
    notification_config: typing.Optional[IStringMapVariable] = None,
    output_s3_bucket_name: typing.Optional[IStringVariable] = None,
    output_s3_key_prefix: typing.Optional[IStringVariable] = None,
    parameters: typing.Optional[IStringMapVariable] = None,
    service_role_arn: typing.Optional[IStringVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1062cc7195160b74c1853353a52fd8f6171639e926a461e3d7c79bb9ce4313f(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    document_name: IStringVariable,
    targets: typing.Union[IStringListVariable, IMapListVariable],
    cloud_watch_output_config: typing.Optional[IStringMapVariable] = None,
    command_timeout_seconds: typing.Optional[INumberVariable] = None,
    comment: typing.Optional[IStringVariable] = None,
    document_hash: typing.Optional[IStringVariable] = None,
    document_hash_type: typing.Optional[IDocumentHashTypeVariable] = None,
    max_concurrency: typing.Optional[INumberVariable] = None,
    max_errors: typing.Optional[INumberVariable] = None,
    notification_config: typing.Optional[IStringMapVariable] = None,
    output_s3_bucket_name: typing.Optional[IStringVariable] = None,
    output_s3_key_prefix: typing.Optional[IStringVariable] = None,
    parameters: typing.Optional[IStringMapVariable] = None,
    service_role_arn: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7025b4621cf14573910a7a4e62d0350bd9dd72740d7d443e1106486be4143cd(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    action: IStringVariable,
    cmd: typing.Optional[IStringVariable] = None,
    container: typing.Optional[IStringVariable] = None,
    cpu_shares: typing.Optional[IStringVariable] = None,
    env: typing.Optional[IStringVariable] = None,
    image: typing.Optional[IStringVariable] = None,
    memory: typing.Optional[IStringVariable] = None,
    publish: typing.Optional[IStringVariable] = None,
    user: typing.Optional[IStringVariable] = None,
    volume: typing.Optional[IStringListVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c69b288f04f11f0fbfce2b4cc9157d3b30ce1cfd5499ebd3c7d37a08567a40c(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    action: IStringVariable,
    cmd: typing.Optional[IStringVariable] = None,
    container: typing.Optional[IStringVariable] = None,
    cpu_shares: typing.Optional[IStringVariable] = None,
    env: typing.Optional[IStringVariable] = None,
    image: typing.Optional[IStringVariable] = None,
    memory: typing.Optional[IStringVariable] = None,
    publish: typing.Optional[IStringVariable] = None,
    user: typing.Optional[IStringVariable] = None,
    volume: typing.Optional[IStringListVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3e57789a5c52f59e7a761c95913ad47e4914de8542a2280f6c76df07719818a(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    step_document: IRunDocumentLocation,
    document_parameters: typing.Optional[IStringMapVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c4e8ceb3fb5bf644484b2c94b3f62aecacf84527c8f2802acd5f68f0afed92e2(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    step_document: IRunDocumentLocation,
    document_parameters: typing.Optional[IStringMapVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae33577b7327b4b382e4eaed6434e8424b65f6c029e35ca2a4cc0056a650e65f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    image_id: IStringVariable,
    additional_info: typing.Optional[IStringVariable] = None,
    block_device_mappings: typing.Optional[IMapListVariable] = None,
    client_token: typing.Optional[IStringVariable] = None,
    disable_api_termination: typing.Optional[IBooleanVariable] = None,
    ebs_optimized: typing.Optional[IBooleanVariable] = None,
    iam_instance_profile_arn: typing.Optional[IStringVariable] = None,
    iam_instance_profile_name: typing.Optional[IStringVariable] = None,
    instance_initiated_shutdown_behavior: typing.Optional[IStringVariable] = None,
    instance_type: typing.Optional[IStringVariable] = None,
    kernel_id: typing.Optional[IStringVariable] = None,
    key_name: typing.Optional[IStringVariable] = None,
    max_instance_count: typing.Optional[INumberVariable] = None,
    min_instance_count: typing.Optional[INumberVariable] = None,
    monitoring: typing.Optional[IBooleanVariable] = None,
    network_interfaces: typing.Optional[IMapListVariable] = None,
    placement: typing.Optional[IStringMapVariable] = None,
    private_ip_address: typing.Optional[IStringVariable] = None,
    ramdisk_id: typing.Optional[IStringVariable] = None,
    security_group_ids: typing.Optional[IStringListVariable] = None,
    security_groups: typing.Optional[IStringListVariable] = None,
    subnet_id: typing.Optional[IStringVariable] = None,
    tag_specifications: typing.Optional[IMapListVariable] = None,
    user_data: typing.Optional[IStringVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5aa8846cdece2eb98372bab0b08f32012f7707cd49ecd3c64d4b35cd18ec0b7f(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    image_id: IStringVariable,
    additional_info: typing.Optional[IStringVariable] = None,
    block_device_mappings: typing.Optional[IMapListVariable] = None,
    client_token: typing.Optional[IStringVariable] = None,
    disable_api_termination: typing.Optional[IBooleanVariable] = None,
    ebs_optimized: typing.Optional[IBooleanVariable] = None,
    iam_instance_profile_arn: typing.Optional[IStringVariable] = None,
    iam_instance_profile_name: typing.Optional[IStringVariable] = None,
    instance_initiated_shutdown_behavior: typing.Optional[IStringVariable] = None,
    instance_type: typing.Optional[IStringVariable] = None,
    kernel_id: typing.Optional[IStringVariable] = None,
    key_name: typing.Optional[IStringVariable] = None,
    max_instance_count: typing.Optional[INumberVariable] = None,
    min_instance_count: typing.Optional[INumberVariable] = None,
    monitoring: typing.Optional[IBooleanVariable] = None,
    network_interfaces: typing.Optional[IMapListVariable] = None,
    placement: typing.Optional[IStringMapVariable] = None,
    private_ip_address: typing.Optional[IStringVariable] = None,
    ramdisk_id: typing.Optional[IStringVariable] = None,
    security_group_ids: typing.Optional[IStringListVariable] = None,
    security_groups: typing.Optional[IStringListVariable] = None,
    subnet_id: typing.Optional[IStringVariable] = None,
    tag_specifications: typing.Optional[IMapListVariable] = None,
    user_data: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b87d5aa383e45a5024cb67520e20e42ec8e41e502b38b74d1e326aaf11271f11(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    run_command: typing.Sequence[IStringVariable],
    timeout_seconds: typing.Optional[jsii.Number] = None,
    working_directory: typing.Optional[IStringVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9bbd636826934f2c6cd8e2332fc039ce4e5bee8d6ae92febb4e2144212896479(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    run_command: typing.Sequence[IStringVariable],
    timeout_seconds: typing.Optional[jsii.Number] = None,
    working_directory: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81f8e051a3be67574c41343d7c1055cec31c28cb63ce9828dea32c9b65a8e95e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    run_command: typing.Sequence[IStringVariable],
    timeout_seconds: typing.Optional[jsii.Number] = None,
    working_directory: typing.Optional[IStringVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f3ed3881420c6377aaac6e46a33e9664baed75e588ba6a8bffd45c1bcb65ea8(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    run_command: typing.Sequence[IStringVariable],
    timeout_seconds: typing.Optional[jsii.Number] = None,
    working_directory: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__886bbe5fdcfcd5afb75de9614bb1dea4a330f6a4f6cd3192d76c31709849cee9(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    sleep_seconds: jsii.Number,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ffe9ee3514cf2409014c1b17509c9168a4dd0a3c3dd1edea5dbe4b356891b8f(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    sleep_seconds: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de56635f7635fb0e8266680528784ec2015a544b69557cb0c5b5f4fab17c4951(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    applications: typing.Optional[IStringVariable] = None,
    aws_components: typing.Optional[IStringVariable] = None,
    custom_inventory: typing.Optional[IStringVariable] = None,
    files: typing.Optional[IStringVariable] = None,
    instance_detailed_information: typing.Optional[IStringVariable] = None,
    network_config: typing.Optional[IStringVariable] = None,
    services: typing.Optional[IStringVariable] = None,
    windows_registry: typing.Optional[IStringVariable] = None,
    windows_roles: typing.Optional[IStringVariable] = None,
    windows_updates: typing.Optional[IStringVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e52ca2fb45d99d1f08554ec7c5084abe46d1b9e169241da50ddb8855cfd7f3a(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    applications: typing.Optional[IStringVariable] = None,
    aws_components: typing.Optional[IStringVariable] = None,
    custom_inventory: typing.Optional[IStringVariable] = None,
    files: typing.Optional[IStringVariable] = None,
    instance_detailed_information: typing.Optional[IStringVariable] = None,
    network_config: typing.Optional[IStringVariable] = None,
    services: typing.Optional[IStringVariable] = None,
    windows_registry: typing.Optional[IStringVariable] = None,
    windows_roles: typing.Optional[IStringVariable] = None,
    windows_updates: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9546d83a5b8960789ef896c0e4f82046a3c1acb109ce2b485a5ae2588eec31be(
    step: AutomationStep,
    validate_step_action: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f41e2bd80acf6e0d2f4d78c2d526578435203d0e8d6c61056cc504ff1f7d147(
    _current_step: AutomationStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8132a3162299d52ed3479ffe269b953acb516e7e09760ec6f9d41aaee9b0fe89(
    step: builtins.str,
    validate_step_action: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41aa8639e688d9fe19ea813059b960f0c6a6bcb293c2523c9d6d7bb75d8c8b35(
    current_step: AutomationStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f0eec48e869b2ef86c812f2f7c9dde81b535e1f8376fb83a58cedc2bc133625(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a78c47d6900f044455fb48a7655ebd81621a3803d2302b4af51a87a680afff9(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7ef1e2a792ef5837c8a78fb5750e9622c1dd9b840f6a8a2d1979469227c9979(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8673c7dcc243406d34660e77cf80662966f18bd016cb66010866ec5a530f5763(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01785f5b03c5482d57ea333bd7b70afebd7cc5246039989726f1902916f90b81(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62585f5db74bc9e70cf7256a77628eb77e67f81acd3c4eb172403521e1bbb0f2(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0d4c3bf53f70e5a50c6a1ac78a79362246e172d8e30944f80930d619c0b796e(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__15f3c09257b7ac07b5275b98194471e1582f57bae1153ec571d04fa4fe2cea3d(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e061d3f6995cdf022390b8d6c834c9e585f349e43cfa610c7df054f0bdd83ed2(
    scope: _constructs_77d1e7e8.Construct,
    json: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9303d9813b6bb041633cd9e1ed713fe06d73f85827a94f2d462a9f5c76dc03a(
    scope: _constructs_77d1e7e8.Construct,
    props: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__902684dde795720c72918cf0b4e4dab5d71fc74cab535600af2e8c8617b27df7(
    scope: _constructs_77d1e7e8.Construct,
    input_yaml: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7440108fb4a4efb9bd2e5195ac80b6b7bef5d30169bacc5d29fdaed3d4bfb330(
    doc: AutomationDocumentBuilder,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1670eea8bb7d6c7344e46fd6300930b26431a7d796947554518279ed0315197(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e18102998bbc140be5364332238b767be316a33313fff276645f1597b7dfd847(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bab88eabcbd7add1143916143b923d0170ef9c2bfe09b4d28850688e08af54f6(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f0169c6ec362ac785e1c438955a65b091963659260aa5c57a68f2223584f123(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd25558475f757c18912232cfca993dbce6035e99538751024c3f5b478383a80(
    stage: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    doc_variables: typing.Optional[typing.Sequence[Input]] = None,
    assume_role: typing.Optional[IStringVariable] = None,
    description: typing.Optional[builtins.str] = None,
    doc_inputs: typing.Optional[typing.Sequence[Input]] = None,
    doc_outputs: typing.Optional[typing.Sequence[typing.Union[DocumentOutput, typing.Dict[builtins.str, typing.Any]]]] = None,
    document_format: typing.Optional[DocumentFormat] = None,
    document_name: typing.Optional[builtins.str] = None,
    header: typing.Optional[builtins.str] = None,
    requires: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[typing.Union[_aws_cdk_aws_ssm_ceddda9d.CfnDocument.DocumentRequiresProperty, typing.Dict[builtins.str, typing.Any]], _aws_cdk_ceddda9d.IResolvable]]]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    target_type: typing.Optional[builtins.str] = None,
    update_method: typing.Optional[builtins.str] = None,
    version_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f419e1a3ba0d372a52656c2e408c019a63c633bad25b72b80280b2235c68b417(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    agent_name: typing.Optional[IStringVariable] = None,
    allow_downgrade: typing.Optional[IBooleanVariable] = None,
    source: typing.Optional[IStringVariable] = None,
    source_region: typing.Optional[builtins.str] = None,
    target_version: typing.Optional[IStringVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d70fb83e6b71d73558c25a3680729607d61339d3bd6af016a698af71c2d5dcae(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    agent_name: typing.Optional[IStringVariable] = None,
    allow_downgrade: typing.Optional[IBooleanVariable] = None,
    source: typing.Optional[IStringVariable] = None,
    source_region: typing.Optional[builtins.str] = None,
    target_version: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78e4a64a81f48992a117f4220b17c237fc90339c5c0eaf45f5edb98806daa46f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    allow_downgrade: IBooleanVariable,
    agent_name: typing.Optional[IStringVariable] = None,
    source: typing.Optional[IStringVariable] = None,
    source_region: typing.Optional[builtins.str] = None,
    target_version: typing.Optional[IStringVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1615cf15d1d401aa8235505bdec1126b6d0f0521523b5e0c8747737290a621c5(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    allow_downgrade: IBooleanVariable,
    agent_name: typing.Optional[IStringVariable] = None,
    source: typing.Optional[IStringVariable] = None,
    source_region: typing.Optional[builtins.str] = None,
    target_version: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a21939076f80e3e3a259e33d35df6765e10f00da2234b93297cb9c1fea63199d(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    variable_name: builtins.str,
    variable_value: IGenericVariable,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0048d0826f1abdaf7744fd0eddd55439a14ca327ffa2432acfb1cf8d579d43c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    variable_name: builtins.str,
    variable_value: IGenericVariable,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b5f0b1b010f0b3a0e2a3068785f968d071e794e2b9fa1bb278a27c630238ae6(
    _current_step: AutomationStep,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__510ff57af2b894f9a228ac383ce48b5d36c6d8e102c5924abdafd7cfbe64a276(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19bee8c11d86aa989695e635be116b201cdce97b9c19f615420ae2a8c22a36f0(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08a1574ecdae85548d3f165fd4c7a103252434da339d2f6c57f341b65f81cada(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    action: IInstallUninstallRepairVariable,
    source: IStringVariable,
    parameters: typing.Optional[IStringVariable] = None,
    source_hash: typing.Optional[IStringVariable] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__136bf2e2baea328a9796e94bface30ee8bc0c5f71d8ce7b58f25fd07b0c16937(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    exit_on_failure: typing.Optional[builtins.bool] = None,
    exit_on_success: typing.Optional[builtins.bool] = None,
    finally_step: typing.Optional[builtins.bool] = None,
    mark_success_and_exit_on_failure: typing.Optional[builtins.bool] = None,
    on_cancel: typing.Optional[Step] = None,
    precondition: typing.Optional[Precondition] = None,
    action: IInstallUninstallRepairVariable,
    source: IStringVariable,
    parameters: typing.Optional[IStringVariable] = None,
    source_hash: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56c6313727da6b0bec1ee8ac80eed4db0906df91d88d008be2666163eea455a4(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    approvers: IStringListVariable,
    message: typing.Optional[IStringVariable] = None,
    min_required_approvals: typing.Optional[INumberVariable] = None,
    notification_arn: typing.Optional[IStringVariable] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b669cf68225d1e3a91a8018db4eea78fe84d91535e247cae020ab550f190b2d(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    approvers: IStringListVariable,
    message: typing.Optional[IStringVariable] = None,
    min_required_approvals: typing.Optional[INumberVariable] = None,
    notification_arn: typing.Optional[IStringVariable] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e22bc24b203ef4809b9cd3d0c8e657857bbabb659bd99a0aaad5b30735525a1(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    desired_values: typing.Sequence[builtins.str],
    selector: builtins.str,
    api_params: typing.Mapping[builtins.str, typing.Any],
    pascal_case_api: builtins.str,
    service: AwsService,
    java_script_api: typing.Optional[builtins.str] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d5db218805d4f4a95a0282144aa84d9b30754fd94e52f48a09c2e196ceff894(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    api_params: typing.Mapping[builtins.str, typing.Any],
    pascal_case_api: builtins.str,
    service: AwsService,
    java_script_api: typing.Optional[builtins.str] = None,
    desired_values: typing.Sequence[builtins.str],
    selector: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b91281414afbedbf69038929e84c6b2a49b684b1945e545f26700d9e02a2d77f(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    api_params: typing.Mapping[builtins.str, typing.Any],
    pascal_case_api: builtins.str,
    service: AwsService,
    java_script_api: typing.Optional[builtins.str] = None,
    outputs: typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6c13815b1fa05199fe64475fd4851510e39530c1f1b7bc11bdada06a9989a35(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f27bb4d11185b740ac5d46a699ead1a039f888044207642375917b0f292c1e3(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef9d78fbd94c1db58a4273bfb57f1d5aadbb07ff1d95db77b7a4f46925a2fda8(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a295e96edb52227da27d11831a4ef807a3bb3e43d005fffac613d70df501539(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4267f843d172e6d3e8618337be16c0d98b9681dad51ea659bd03a11131d71323(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd85be8a97db3ee21cd9423aacc45a86913f096aab23e12a1db836ce32e6839b(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb0ae3dddba8a1c30a1858bfdcbf1cb9428a1ed404cecbd07017973ec7f8f28e(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce3d0cc0f5ab6192ed547615c9fdde98566fb4976944dfa2e8e59194f34263bc(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c16d8d5cb28aeb7a4c94c247ebf213f9650d38461538b56f412558bcfe46d7b8(
    val: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__271d795c03776c1b6e5db4ed4f7f3e8c6cde9de371139c2d1f53c9f705827269(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3144a64c4c4ea88d4a2ae3e503a03b4768bf2d2040c91d2832650211622065b2(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b0a71dd7fbf2b47c145c424c48c7f5b3efef6f00e02e0c0629bf7d3aaee873d(
    val: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3b54250baff25d9653fcbdf8f750c0aebd6a544dfc96cfb6d5397a6e5c7620e(
    val: typing.Sequence[typing.Mapping[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f80da4a8765eb1b1705bfb88a584bafd3616a12243f5368c54c57f9a5fb42580(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f60574f51857768ceb70ecefa34e85727bbeb17057b7ec51632026bd54d04470(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__234ac17e40662af208236ba6171c29a53219ca1f4d2b0f63c5d079582c3e9338(
    val: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0944a57d06e0d1e12107f3312191d384c8dfc72657fe1517cee1c38d4e77a663(
    val: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28bc1b5138b3b9dd8d990bc9fe1280201145d47f036f49bb3d066b56f5690378(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__414922d52e00bc4bd49eb6aab307ac0a891a2e9c87ddb3e164d5a0daea2efacd(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54499f8ba88672d8661a98fdacc683a12c6247fd15bb80279cffecdbbb7cc9b2(
    val: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__245c22562d52647b98c55b0029eca2cce14ec4e295a8342a7585d745605648b2(
    val: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a81c2c02ea74a5073cf1427d5bae3aab7fafbe443b6a4ebbdc44a47d6724fc2(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82d35b9921edfb6d0873ef8c6e45cab75f36f2b670992fd4ff5510d600f0c3d6(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f53b9667e749c7df5b736aa78954775fa4e0369d4bb8271cb6e955d99455f6f2(
    val: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8920108546802fcb062cd3d90c8b1c5e3a96cddbcc3e579c0c35c4a99f3893b9(
    val: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f9953fca1464700a97df905e75abd9e1212b4515768dc4d4f8c6f31c4f48091(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ab95d898a5c1aa9cc6e773c4322e6095bca6370df8a84655796bbffeea5f756(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7c8e0877e483742a427cb002024665ad11f02a416cb349de21de3c20f72182a(
    val: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cde433b6be72f9adf4d74db4e0d9883f0b2893317c3220530f844b943061f28e(
    val: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7e058922650560856aecae39be57839674628afbf2b45207a0f809745ff7a10(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2445031dc943c6c68d2783b128f4c8b933d3cb7c40db4907d97d7ff10e610891(
    inputs: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c972de50a1de08d5a31ef8662661fc767ae3e60d9d81b08ec949ef168352d329(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__341e45c7dc8db0e587e6f86c62825b22bb2d567b3178e52b2e302db38aeaa5ee(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad9e09468c4409156031a40fd40bcf896619f54c7ca68e51e47ddce006e952fd(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f17321d5f6e513a58dad0a5e441c9cf2cead21ca7c8648932c95f13c433e26d4(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02427177ca3d6190561c84cf47c2e7531466455554fde4071e12de365df126d4(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12c2faf937142e3595853700f6698ee5221da5b549420a316af4756cf175623b(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7aecc2c0562f3e016e8670cece3ce32104aacb864027386482057a1e1383a0f(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8dbaa57485d60791311effb02e995dc7d359eeaaf9a5eef949eb45a2d6bc645f(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bac15cf0a5b21c54a2a868cef251f4c3af2581545f4e7379c07229a39f511667(
    reference: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fda08275e38eff10cec2f35c379a0c289c4723e6a41b9e1f99b00368971e81e(
    value: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b54dff4afcc630be826b78f85caaafeab25c1421bdd1fe62d62ca3ac3b88a827(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    sleep_interval_millis: typing.Optional[jsii.Number] = None,
    desired_values: typing.Sequence[builtins.str],
    selector: builtins.str,
    api_params: typing.Mapping[builtins.str, typing.Any],
    pascal_case_api: builtins.str,
    service: AwsService,
    java_script_api: typing.Optional[builtins.str] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdda9118eb32015294033e7da38d33cd3b9b4994d1a893c41dc6491dd671e4a5(
    *,
    description: typing.Optional[builtins.str] = None,
    input_observer: typing.Optional[IObserver] = None,
    name: typing.Optional[builtins.str] = None,
    output_observer: typing.Optional[IObserver] = None,
    explicit_next_step: typing.Optional[StepRef] = None,
    is_end: typing.Optional[builtins.bool] = None,
    max_attempts: typing.Optional[jsii.Number] = None,
    on_cancel: typing.Optional[OnCancel] = None,
    on_failure: typing.Optional[OnFailure] = None,
    timeout_seconds: typing.Optional[jsii.Number] = None,
    user_outputs: typing.Optional[typing.Sequence[typing.Union[Output, typing.Dict[builtins.str, typing.Any]]]] = None,
    api_params: typing.Mapping[builtins.str, typing.Any],
    pascal_case_api: builtins.str,
    service: AwsService,
    java_script_api: typing.Optional[builtins.str] = None,
    desired_values: typing.Sequence[builtins.str],
    selector: builtins.str,
    sleep_interval_millis: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass
