# FileName: UiInterface.py
__author__ = "Jiyan Hu"
__email__ = "mailwork.hu@gmail.com"
__license__ = "GNU Affero General Public License v3.0 or later"
__copyright__ = f"Copyright (C) 2025 {__author__}"


from liberrpa.Logging import Log
from liberrpa.UI._Overlay import create_overlay
from liberrpa.UI._Image import find_image
import liberrpa.UI._UiElement as _UiElement
from liberrpa.UI._UiAutomation import get_children_control_recursive
from liberrpa.Common._TypedValue import (
    DictSpecHtml,
    DictUiaAttr,
    DictHtmlAttr,
    DictImageAttr,
    DictPositionAndSize,
    # SelectorWindowOriginal,
    SelectorWindow,
    # SelectorUiaOriginal,
    SelectorUia,
    # SelectorHtmlOriginal,
    SelectorHtml,
    SelectorImage,
)
from liberrpa.UI._TerminableThread import timeout_kill_thread
from liberrpa.Common._Exception import UiElementNotFoundError, UiTimeoutError, UiOperationError
from liberrpa.Common._Chrome import (
    get_parent_element_attr,
    get_children_element_attr,
    set_element_text as Chrome_set_element_text,
    set_check_state as Chrome_set_check_state,
    get_selection as Chrome_get_selection,
    set_selection as Chrome_set_selection,
)
from liberrpa.Basic import delay

from time import time
import uiautomation
from PIL import Image
import mss
from pathlib import Path
from typing import Literal
import re


def _decrease_timeout(timeout: int, timeStart: float) -> int:
    """Decrease timeout for searching target again later."""
    timeUsed = int((time() - timeStart) * 1000)
    # print("timeUsed=", timeUsed)
    timeout = timeout - timeUsed
    # print("timeout=", timeout)
    return timeout


def _highlight(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    color: str = "red",
    duration: int = 1000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    _, dictTarget = _UiElement.get_element_with_pre_delay(selector=selector, preExecutionDelay=preExecutionDelay)

    create_overlay(
        x=int(dictTarget["secondary-x"]),
        y=int(dictTarget["secondary-y"]),
        width=int(dictTarget["secondary-width"]),
        height=int(dictTarget["secondary-height"]),
        color=color,
        duration=duration,
    )

    delay(postExecutionDelay)


@Log.trace()
def highlight(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    color: Literal["red", "green", "blue", "yellow", "purple", "pink", "black"] = "red",
    duration: int = 1000,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    """
    Draw a rectangle around the element.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        color: The color of the highlight border. Available options are "red", "green", "blue", "yellow", "purple", "pink", "black".
        duration: The time in milliseconds for which the highlight should remain visible on the screen.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).
    """
    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_highlight)(
        selector,
        color,
        duration,
        preExecutionDelay,
        postExecutionDelay,
    )


def _screenshot(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    saveFilePath: str,
    offsetX: int = 0,
    offsetY: int = 0,
    width: int | None = None,
    height: int | None = None,
    override: bool = False,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> str:

    if override == False and Path(saveFilePath).exists():
        raise FileExistsError(
            f"The argument 'override' is False, and the file '{Path(saveFilePath).absolute()}' already exists."
        )

    _, dictTarget = _UiElement.get_element_with_pre_delay(selector=selector, preExecutionDelay=preExecutionDelay)

    # Define the bounding box of the area

    intXStart = int(dictTarget["secondary-x"]) + offsetX
    intYStart = int(dictTarget["secondary-y"]) + offsetY
    # If width or height is None, use the default size.
    if width == 0 or height == 0:
        raise ValueError("The arguments width or height cann't be 0.")

    if width is None:
        intXEnd = int(dictTarget["secondary-x"]) + int(dictTarget["secondary-width"]) + offsetX
    else:
        intXEnd = int(dictTarget["secondary-x"]) + width + offsetX

    if height is None:
        intYEnd = int(dictTarget["secondary-y"]) + int(dictTarget["secondary-height"]) + offsetY
    else:
        intYEnd = int(dictTarget["secondary-y"]) + height + offsetY

    # Capture the screen by mss due to the coordinates may be negative.
    with mss.mss() as sct:
        # Define the region for the screenshot
        monitor = {"top": intYStart, "left": intXStart, "width": intXEnd - intXStart, "height": intYEnd - intYStart}
        # Grab the data
        screenshotTemp = sct.grab(monitor)
        # Convert the raw pixel data to a PIL Image
        imgTemp = Image.frombytes("RGB", screenshotTemp.size, screenshotTemp.rgb)

    Path(saveFilePath).parent.mkdir(parents=True, exist_ok=True)
    imgTemp.save(saveFilePath)

    delay(postExecutionDelay)

    return str(Path(saveFilePath).absolute())


@Log.trace()
def screenshot(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    saveFilePath: str,
    offsetX: int = 0,
    offsetY: int = 0,
    width: int | None = None,
    height: int | None = None,
    override: bool = False,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> str:
    """
    Capture a screenshot of the element's area and save it.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        saveFilePath: The file path where the screenshot will be saved.
        offsetX: The horizontal offset in pixels from the top-left corner of the element to start capturing the screenshot.
        offsetY: The vertical offset in pixels from the top-left corner of the element to start capturing the screenshot.
        width: The width of the screenshot in pixels. If None, the width of the element will be used.
        height: The height of the screenshot in pixels. If None, the height of the element will be used.
        override: If True, will overwrite an existing file at saveFilePath.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        str: The absolute path of the saved screenshot.
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)
    return str(
        timeout_kill_thread(timeout=timeout)(_screenshot)(
            selector,
            saveFilePath,
            offsetX,
            offsetY,
            width,
            height,
            override,
            preExecutionDelay,
            postExecutionDelay,
        )
    )


def get_image_position(
    filePath: str,
    region: tuple[int, int, int, int] | None = None,
    confidence: float = 0.95,
    grayscale: bool = True,
    limit: int = 1,
    highlight: bool = False,
) -> list[DictPositionAndSize]:
    """
    Searches for an image on the screen and returns the coordinates of matched regions.

    Parameters:
        filePath: The path of the image file to locate.
        region: A tuple (x, y, width, height) defining the search area. If None, searches the entire screen.
        confidence: A float (0.0 to 1.0) indicating the required match accuracy.
        grayscale: If True, searches in grayscale mode for faster detection.
        limit: The maximum number of matches to return.
        highlight: Whether highlight the matched position.

    Returns:
        DictPositionAndSize: A list of dictionaries containing the x, y, width, and height of the matched images: {'x': <class 'int'>, 'y': <class 'int'>, 'width': <class 'int'>, 'height': <class 'int'>}
    """

    if limit < 1:
        raise ValueError("The argument 'limit' should be greater than 0.")

    listTemp: list[DictImageAttr] = find_image(
        fileName=filePath,
        region=region,
        confidence=confidence,
        grayscale=grayscale,
        limit=limit,
        moveFile=False,
        buildinPath=False,
    )

    """ if len(listTemp) == 0:
        raise UiElementNotFoundError(f"Not found matched image '{Path(filePath).absolute()}' in the region {region}") 
        find_image will raise an Exception if found no match.
        """

    listReturn: list[DictPositionAndSize] = []
    for item in listTemp:
        listReturn.append(
            {
                "x": int(item["secondary-x"]),
                "y": int(item["secondary-y"]),
                "width": int(item["secondary-width"]),
                "height": int(item["secondary-height"]),
            }
        )
        if highlight:
            create_overlay(
                x=int(item["secondary-x"]),
                y=int(item["secondary-y"]),
                width=int(item["secondary-width"]),
                height=int(item["secondary-height"]),
                color="red",
                duration=200,
                label="",
            )

    return listReturn


def _check_exists(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
) -> bool:

    try:
        _, _ = _UiElement.get_element(selector=selector)
    except UiElementNotFoundError as e:
        # print(e)
        return False
    except Exception as e:
        # print(e)
        return False
    else:
        return True


@Log.trace()
def check_exists(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> bool:
    """
    Check if an element exists, raise False if it didn't appear at timeout.
    
    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        True if the element exists within the specified timeout, False otherwise.
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)
    boolExists = False
    delay(preExecutionDelay)
    try:
        while True:
            timeStart = time()
            boolExists = bool(timeout_kill_thread(timeout=timeout)(_check_exists)(selector))

            if boolExists == True:
                return True
            else:
                timeout = _decrease_timeout(timeout=timeout, timeStart=timeStart)
                if timeout <= 0:
                    Log.debug("Timeout for find the image.")
                    return False
                else:
                    continue
    except UiTimeoutError as e:
        Log.debug("Timeout for find the image.")
        return False
    except Exception as e:
        raise e
    finally:
        delay(postExecutionDelay)


@Log.trace()
def wait_appear(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    """
    Wait an element to appear.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the element doesn't appear after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)
    timeoutTemp = timeout
    boolExists = False
    delay(preExecutionDelay)
    try:
        while True:
            timeStart = time()
            boolExists = bool(timeout_kill_thread(timeout=timeout)(_check_exists)(selector))

            if boolExists == True:
                delay(postExecutionDelay)
                return None
            else:
                timeout = _decrease_timeout(timeout=timeout, timeStart=timeStart)
                if timeout <= 0:
                    raise UiTimeoutError()
                else:
                    continue

    except UiTimeoutError as e:
        raise UiTimeoutError(f"Timeout exceeded for UI element to appear. timeout={timeoutTemp}, selector: {selector}")
    except Exception as e:
        raise e


@Log.trace()
def wait_disappear(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    """
    Wait an element to disappear.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the element doesn't disappear after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)
    timeoutTemp = timeout
    boolExists = False
    delay(preExecutionDelay)
    try:
        while True:
            timeStart = time()
            boolExists = bool(timeout_kill_thread(timeout=timeout)(_check_exists)(selector))

            if boolExists == True:
                timeout = _decrease_timeout(timeout=timeout, timeStart=timeStart)
                if timeout <= 0:
                    raise UiTimeoutError(f"Timeout exceeded for UI element to disappear.")
                else:
                    continue
            else:
                delay(postExecutionDelay)
                return None

    except UiTimeoutError as e:
        # Besides the function, timeout_kill_thread() may throw an UiTimeoutError.
        if re.fullmatch(
            pattern="^Function .*? timed out after \\d*? milliseconds.$|^Timeout exceeded for UI element to disappear.$",
            string=str(e),
        ):
            raise UiTimeoutError(f"Timeout exceeded for UI element to disappear. timeout={timeoutTemp}")
        else:
            delay(postExecutionDelay)
            return None
    except UiElementNotFoundError as e:
        delay(postExecutionDelay)
        return None
    except Exception as e:
        raise e


def _get_parent(
    selector: SelectorUia | SelectorHtml,
    upwardLevel: int = 1,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> SelectorWindow | SelectorUia | SelectorHtml:

    if selector.get("category") == "image":
        raise UiOperationError(f"Not support getting an image element's parent.")

    if selector.get("category") is None:
        raise UiOperationError(f"Not support getting an UIA window element's parent.")

    if isinstance(upwardLevel, int) == False or upwardLevel < 1:
        raise ValueError(f"The argument 'upwardLevel' should be an integer equal to or greater than 1.")

    if selector.get("category") == "html":
        _UiElement.activate_element_window(selector=selector)
        selectorParentHtml: SelectorHtml = {
            "window": selector["window"],
            "category": "html",
            "specification": get_parent_element_attr(
                htmlSelector=selector["specification"],  # type: ignore - it's SelectorHtml
                upwardLevel=upwardLevel,
                preExecutionDelay=preExecutionDelay,
                timeout=timeout,
            ),
        }

        delay(postExecutionDelay)
        return selectorParentHtml

    # uia
    uiTarget, _ = _UiElement.get_element_with_pre_delay(selector=selector, preExecutionDelay=preExecutionDelay)
    for i in range(1, upwardLevel + 1, 1):
        if isinstance(uiTarget, uiautomation.Control):
            # Only choose non-Desktop controls that have 'Name'.
            while True:
                uiTarget = uiTarget.GetParentControl()
                if uiTarget is None or (uiTarget.ControlTypeName == "PaneControl" and uiTarget.ClassName == "#32769"):
                    # If have no parent control or its parent is Desktop
                    raise UiElementNotFoundError(f"Not found its parent element at upwardLevel {i}.")
                elif uiTarget.Name is None or uiTarget.Name == "":
                    # It has no 'Name'.
                    continue
                else:
                    selectorParentUia: SelectorWindow | SelectorUia = _UiElement.get_control_selector(control=uiTarget)
                    Log.debug(f"Found parent at upwardLevel {i}." + str(selectorParentUia))
                    break
    delay(postExecutionDelay)

    return selectorParentUia


@Log.trace()
def get_parent(
    selector: SelectorUia | SelectorHtml,
    upwardLevel: int = 1,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> SelectorWindow | SelectorUia | SelectorHtml:
    """
    Get the selector of an element's parent. Only support SelectorUia and SelectorHtml.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        upwardLevel: The upward layer to find its parent element.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        SelectorWindow | SelectorUia | SelectorHtml: The parent element's selector.
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)
    return timeout_kill_thread(timeout=timeout)(_get_parent)(
        selector,
        upwardLevel,
        timeout,
        preExecutionDelay,
        postExecutionDelay,
    )


def _get_children(
    selector: SelectorWindow | SelectorUia | SelectorHtml,
    timeout: int = 30000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> list[SelectorUia] | list[SelectorHtml]:

    if selector.get("category") == "image":
        raise UiOperationError(f"Not support getting an image element's children.")

    if selector.get("category") == "html":
        _UiElement.activate_element_window(selector=selector)

        listSpecification: list[DictSpecHtml] = get_children_element_attr(
            htmlSelector=selector["specification"],  # type: ignore - it's SelectorHtml
            preExecutionDelay=preExecutionDelay,
            timeout=timeout,
        )

        controlTop = _UiElement.get_top_control(selectorWindowPart=selector["window"])
        selectorWindow: SelectorWindow = _UiElement.get_control_selector(control=controlTop)

        listSelectorsHtml: list[SelectorHtml] = []
        for item in listSpecification:
            listSelectorsHtml.append({"window": selectorWindow["window"], "category": "html", "specification": [item]})

        delay(postExecutionDelay)
        return listSelectorsHtml

    # uia
    uiTarget, _ = _UiElement.get_element_with_pre_delay(selector=selector, preExecutionDelay=preExecutionDelay)
    if isinstance(uiTarget, uiautomation.Control):
        # uia
        listControlChildren = get_children_control_recursive(control=uiTarget)
        listSelectorsUia: list[SelectorUia] = [
            _UiElement.get_control_selector(control=childControl) for childControl in listControlChildren
        ]  # type: ignore - it's list[SelectorUia]

    delay(postExecutionDelay)

    return listSelectorsUia


@Log.trace()
def get_children(
    selector: SelectorWindow | SelectorUia | SelectorHtml,
    timeout: int = 30000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> list[SelectorUia] | list[SelectorHtml]:
    """
    Get the direct chilren elements' selectors. Only support SelectorWindow, SelectorUia and SelectorHtml.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        list[SelectorUia] | list[SelectorHtml]: A list contains the selectors of the element's direct children.
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)
    return timeout_kill_thread(timeout=timeout)(_get_children)(
        selector,
        timeout,
        preExecutionDelay,
        postExecutionDelay,
    )


def _get_attr_dictionary(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> DictUiaAttr | DictHtmlAttr | DictImageAttr:
    _, dictTarget = _UiElement.get_element_with_pre_delay(selector=selector, preExecutionDelay=preExecutionDelay)

    delay(postExecutionDelay)
    return dictTarget


@Log.trace()
def get_attr_dictionary(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> DictUiaAttr | DictHtmlAttr | DictImageAttr:
    """
    Get a dictionary contains all attributes of the element.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        DictUiaAttr | DictHtmlAttr: The attributes dictionary of the element, note some attributes with the prefix of "secondary-".
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_get_attr_dictionary)(
        selector,
        preExecutionDelay,
        postExecutionDelay,
    )


def _get_control_text_recursive(control) -> list[str]:
    listText: list[str] = []

    # Get text from Name and HelpText which are common properties
    if control.Name:
        listText.append(control.Name)
    if control.HelpText:
        listText.append(control.HelpText)

    # Try to retrieve text using ValuePattern if available
    pattern = control.GetPattern(uiautomation.PatternId.ValuePattern)
    if pattern and pattern.Value:
        listText.append(pattern.Value)
    else:
        # If ValuePattern is not available or provides no text, check TextPattern
        pattern = control.GetPattern(uiautomation.PatternId.TextPattern)
        if pattern:
            strText = pattern.DocumentRange.GetText(-1)
            if strText:
                listText.append(strText)

    # Recursively process child controls
    for child in control.GetChildren():
        listText.extend(_get_control_text_recursive(control=child))

    return listText


def _get_text(
    selector: SelectorWindow | SelectorUia | SelectorHtml,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> tuple[list[str], str]:

    if selector.get("category") == "image":
        raise UiOperationError(f"Not support getting text by the function, consider using OCR.")

    uiTarget, dictTarget = _UiElement.get_element_with_pre_delay(selector=selector, preExecutionDelay=preExecutionDelay)

    listText: list[str] = []

    if isinstance(uiTarget, uiautomation.Control):
        listText = _get_control_text_recursive(control=uiTarget)
        delay(postExecutionDelay)
        return (listText, "\n".join(listText))
    else:
        # html
        delay(postExecutionDelay)
        if dictTarget.get("innerText", None):
            strTemp: str = dictTarget.get("innerText")  # type: ignore
        elif dictTarget.get("value"):
            strTemp: str = dictTarget["value"]  # type: ignore
        else:
            strTemp: str = ""
        return ([strTemp], strTemp)


@Log.trace()
def get_text(
    selector: SelectorWindow | SelectorUia | SelectorHtml,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> tuple[list[str], str]:
    """
    Get all text of the element. Only support SelectorWindow, SelectorUia and SelectorHtml.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        tuple[list[str], str]: A tuple contains the all children element's text(if it's an uia element) and all text.
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_get_text)(
        selector,
        preExecutionDelay,
        postExecutionDelay,
    )


def _set_text(
    selector: SelectorUia | SelectorHtml,
    text: str,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:

    if selector.get("category") == "image":
        raise UiOperationError(f"Not support setting text in an image element.")

    if selector.get("category") is None:
        raise UiOperationError(f"Not support setting text in an UIA window element.")

    if selector.get("category") == "html":
        _UiElement.activate_element_window(selector=selector)

        Chrome_set_element_text(
            htmlSelector=selector["specification"],  # type: ignore - it's SelectorHtml
            text=text,
            emptyOriginalText=True,
            validateWrittenText=False,
            preExecutionDelay=preExecutionDelay,
            timeout=timeout,
        )

        delay(postExecutionDelay)
        return None

    # uia
    uiTarget, _ = _UiElement.get_element_with_pre_delay(selector=selector, preExecutionDelay=preExecutionDelay)

    if isinstance(uiTarget, uiautomation.Control):
        pattern = uiTarget.GetPattern(uiautomation.PatternId.ValuePattern)
        if pattern:
            if uiTarget.IsEnabled:
                pattern.SetValue(text)  # type: ignore
                delay(postExecutionDelay)
                return None

    # Other elements don't support setting text and not be checked before.

    raise UiOperationError(
        f"The element doesn't support setting text or LiberRPA doesn't have permission. selector: {selector}"
    )


@Log.trace()
def set_text(
    selector: SelectorUia | SelectorHtml,
    text: str,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    """
    Set an element's text by its API instead of inputting by keyboard. Only support SelectorUia and SelectorHtml.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        text: The text to be set.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_set_text)(
        selector,
        text,
        timeout,
        preExecutionDelay,
        postExecutionDelay,
    )


def _get_check_state(
    selector: SelectorUia | SelectorHtml,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> Literal["checked", "unchecked", "indeterminate"]:

    if selector.get("category") != "html" and selector.get("category") != "uia":
        raise UiOperationError(f"Can only get check state for html and uia non window elements which support check.")

    uiTarget, dictTarget = _UiElement.get_element_with_pre_delay(selector=selector, preExecutionDelay=preExecutionDelay)

    strReturn: str = ""

    if isinstance(uiTarget, uiautomation.Control):
        pattern = uiTarget.GetPattern(uiautomation.PatternId.TogglePattern)
        if pattern:

            intState: int = pattern.ToggleState  # type: ignore
            if intState == 0:
                strReturn = "unchecked"
            elif intState == 1:
                strReturn = "checked"
            else:
                # intState == 2
                strReturn = "indeterminate"

            delay(postExecutionDelay)
            return strReturn

        raise UiOperationError(
            f"The element doesn't support getting check state or LiberRPA doesn't have permission. selector: {selector}"
        )
    else:
        # html
        if dictTarget.get("checked") == "false":
            strReturn = "unchecked"
        elif dictTarget.get("checked") == "true":
            strReturn = "checked"
        elif dictTarget.get("checked") == "indeterminate":
            strReturn = "indeterminate"
        else:
            raise UiOperationError(f"The element doesn't have the 'checked' attribute. selector: {selector}")

        delay(postExecutionDelay)
        return strReturn


@Log.trace()
def get_check_state(
    selector: SelectorUia | SelectorHtml,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> Literal["checked", "unchecked", "indeterminate"]:
    """
    Get the check state of a checkbox or radio element. Only support SelectorUia and SelectorHtml.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        text: The text to be set.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        str: one of "checked", "unchecked", "indeterminate"
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_get_check_state)(
        selector,
        preExecutionDelay,
        postExecutionDelay,
    )


def _set_check_state(
    selector: SelectorUia | SelectorHtml,
    checkAction: Literal["checked", "unchecked", "toggle"] = "checked",
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:

    if selector.get("category") == "html":
        _UiElement.activate_element_window(selector=selector)

        # NOTE: Project highlightUI setting will not work for it. (Because the part not only get attributes.)

        Chrome_set_check_state(
            htmlSelector=selector["specification"],  # type: ignore - it's SelectorHtml
            checkAction=checkAction,
            preExecutionDelay=preExecutionDelay,
            timeout=timeout,
        )
        delay(postExecutionDelay)
        return None

    # uia
    uiTarget, _ = _UiElement.get_element_with_pre_delay(selector=selector, preExecutionDelay=preExecutionDelay)

    if isinstance(uiTarget, uiautomation.Control):
        pattern = uiTarget.GetPattern(uiautomation.PatternId.TogglePattern)
        if pattern:
            intState: int = pattern.ToggleState  # type: ignore
            match checkAction:
                case "checked":
                    if intState == 1:
                        pass
                    elif intState == 0:
                        pattern.Toggle()  # type: ignore
                    else:
                        # intState == 2
                        raise ValueError("The element's check state is 'indeterminate', can't be set.")
                case "unchecked":
                    if intState == 0:
                        pass
                    elif intState == 1:
                        pattern.Toggle()  # type: ignore
                    else:
                        # intState == 2
                        raise ValueError("The element's check state is 'indeterminate', can't be set.")
                case "toggle":
                    pattern.Toggle()  # type: ignore
                case _:
                    raise ValueError(
                        f"The argument checkAction({checkAction}) should be one of {['checked', 'unchecked', 'toggle']}"
                    )

            delay(postExecutionDelay)
            return None

    # image or uia element does't support setting check.
    raise UiOperationError(
        f"The element doesn't support setting check state or LiberRPA doesn't have permission. selector: {selector}"
    )


@Log.trace()
def set_check_state(
    selector: SelectorUia | SelectorHtml,
    checkAction: Literal["checked", "unchecked", "toggle"] = "checked",
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    """
    Set the check state of a checkbox or radio element. Only support SelectorUia and SelectorHtml.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        checkAction: Options are "checked", "unchecked", or "toggle". Note that if an HTML element's checked state is "indeterminate", action "toggle" will modity it to "checked" or "unchecked", depend on its previous check state, same like the mouse single click.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_set_check_state)(
        selector,
        checkAction,
        timeout,
        preExecutionDelay,
        postExecutionDelay,
    )


def _get_selection(
    selector: SelectorHtml,
    selectionType: Literal["text", "value", "index"] = "text",
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> str | int:

    if selectionType not in ["text", "value", "index"]:
        raise ValueError(f"The argument selectionType should be 'text', 'value' or 'index'.")

    if selector.get("category") != "html":
        raise UiOperationError(f"Can only get selected value for html <select> element.")

    # NOTE: Project highlightUI setting will not work for it. (Because the part not only get attributes.)

    selectionTemp = Chrome_get_selection(
        htmlSelector=selector["specification"],
        selectionType=selectionType,
        preExecutionDelay=preExecutionDelay,
        timeout=timeout,
    )

    delay(postExecutionDelay)
    return selectionTemp


@Log.trace()
def get_selection(
    selector: SelectorHtml,
    selectionType: Literal["text", "value", "index"] = "text",
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> str | int:
    """
    Get the check state of a checkbox or radio element. Only support SelectorHtml.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        selectionType: Options are "text", "value" or "index"
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        str | int: Return a string if selectionType is "text" or "value", or an integer if selectionType is "index"
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_get_selection)(
        selector,
        selectionType,
        timeout,
        preExecutionDelay,
        postExecutionDelay,
    )


def _set_selection(
    selector: SelectorHtml,
    text: str | None = None,
    value: str | None = None,
    index: int | None = None,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:

    listTemp = [param for param in [[text, value, index]] if param is not None]
    if len(listTemp) != 1:
        raise ValueError("Exactly one of 'text', 'value', or 'index' must be non-null to set the selection.")

    if selector.get("category") != "html":
        raise UiOperationError(f"Can only set selected value for html <select> element.")

    # NOTE: Project highlightUI setting will not work for it. (Because the part not only get attributes.)

    Chrome_set_selection(
        htmlSelector=selector["specification"],
        text=text,
        value=value,
        index=index,
        preExecutionDelay=preExecutionDelay,
        timeout=timeout,
    )

    delay(postExecutionDelay)


@Log.trace()
def set_selection(
    selector: SelectorHtml,
    text: str | None = None,
    value: str | None = None,
    index: int | None = None,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    """
    Get the check state of a checkbox or radio element. Only support SelectorHtml.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        text: set the selection by an option's text, it's mutually exclusive with value and index.
        value: set the selection by an option's value, it's mutually exclusive with text and index.
        index: set the selection by an option's index(start from 0), it's mutually exclusive with text and value.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_set_selection)(
        selector,
        text,
        value,
        index,
        timeout,
        preExecutionDelay,
        postExecutionDelay,
    )


if __name__ == "__main__":
    # from liberrpa._Selector import *
    from time import time

    timeStart = time()

    print(
        get_image_position(
            filePath=R".\Screenshot\_20250129_185915.png",
            region=None,
            confidence=0.97,
            grayscale=True,
            limit=1,
            highlight=True,
        )
    )

    print(
        check_exists(
            selector={
                "window": {
                    "ProcessName": "chrome.exe",
                    "FrameworkId": "Win32",
                    "ControlTypeName": "PaneControl",
                    "Name": "处理报销单 - Google Chrome",
                    "ClassName": "Chrome_WidgetWin_1",
                },
                "category": "image",
                "specification": [{"FileName": "_20250129_185915.png", "Grayscale": "true", "Confidence": "0.97"}],
            },
            timeout=3000,
            preExecutionDelay=0,
            postExecutionDelay=0,
        )
    )

    # highlight(selector=uiaWin2)

    # print(get_selection(selector=selector,selectionType="text"))
    # set_selection(selector=selector, index=3)

    # print(get_check_state(selector=uiaGoogleBookmark1))

    # set_check_state(selector=uiaGoogleBookmark1, checkAction="toggle")

    # print(get_element_check_state(selector=selector))
    """ try:
        highlight(
            selector=uiaGoogleBookmark1,
            # selector=uiaWin2,
            # selector=htmlRpaChallenge2,
            # selector=image2,
            timeout=10000,
            preExecutionDelay=3000,
            postExecutionDelay=200,
            color="yellow",
            duration=1000,
        )
    except Exception as e:
        Log.error(e) """

    """ print(
        screenshot(
            selector=uiaGoogleBookmark1, saveFilePath="./temp.png", offsetX=0, offsetY=0, width=None, height=None, override=True
        )
    ) """
    # print(check_exists(selector=image1, timeout=5000))
    # wait_appear(selector=uiaGoogleBookmark2, timeout=3000)
    # wait_disappear(selector=image1, timeout=3000)
    # wait_disappear(selector=uiaGoogleBookmark2, timeout=3200)

    """ temp = get_parent(selector=image1, timeout=10000, preExecutionDelay=300, postExecutionDelay=200)
    print(temp) """

    # print(get_attr_dictionary(selector=image1))

    """ listText, strText = get_text(selector=image1)
    print(listText)
    print(strText) """
    # print(get_children(selector=image1))

    # set_text(selector=uiaWin1, text="123")
    # print(get_check_state(selector=uiaWin1))
    # set_check_state(selector=image1)
    # print(get_selection(selector=uiaGoogleBookmark1))
    # set_selection(selector=uiaGoogleBookmark1,text="1")

    """ 
    temp = get_parent(
        selector=image1, upwardLevel=2, timeout=10000, preExecutionDelay=300, postExecutionDelay=200
    )
    print(temp)
    highlight(selector=temp)
    # highlight(selector=selector)
    # print(get_parent(selector=selector, upwardLevel=1, timeout=10000, preExecutionDelay=300, postExecutionDelay=200))

    listTemp = get_children(selector=temp, timeout=30000, preExecutionDelay=300, postExecutionDelay=200)
    import json

    print(json.dumps(listTemp, ensure_ascii=False)) """

    """ uiTarget, dictTarget = _UiElement.get_element(selector=selector)
    listTemp = _get_children_control_recursive(control=uiTarget)
    for element in listTemp:
        print(element)
        create_overlay(element.BoundingRectangle.left, element.BoundingRectangle.top, element.BoundingRectangle.width(), element.BoundingRectangle.height(), color="red", duration=300) """
    # set_element_text(selector=selector, text="ssss测试")

    # print(get_element_text(selector=selector))
    # print(get_element_attributes_dictionary(selector=selector))
    #

    print("time used:", time() - timeStart)
