# FileName: Window.py
__author__ = "Jiyan Hu"
__email__ = "mailwork.hu@gmail.com"
__license__ = "GNU Affero General Public License v3.0 or later"
__copyright__ = f"Copyright (C) 2025 {__author__}"


from liberrpa.Logging import Log
import liberrpa.UI._UiElement as _UiElement
from liberrpa.Common._TypedValue import (
    DictPositionAndSize,
    # SelectorWindowOriginal,
    SelectorWindow,
    # SelectorUiaOriginal,
    SelectorUia,
    # SelectorHtmlOriginal,
    SelectorHtml,
    SelectorImage,
)
from liberrpa.UI._TerminableThread import timeout_kill_thread
from liberrpa.Common._Exception import UiElementNotFoundError, UiOperationError
from liberrpa.UiInterface import check_exists
from liberrpa.Basic import delay

import uiautomation
import win32gui
import psutil
from typing import Literal


def _extract_window_element(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
) -> SelectorWindow:
    selectorWindow: SelectorWindow = {"window": selector["window"]}
    return selectorWindow


def _close_window(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    selectorWindow = _extract_window_element(selector=selector)
    uiTarget, _ = _UiElement.get_element_with_pre_delay(selector=selectorWindow, preExecutionDelay=preExecutionDelay)

    if isinstance(uiTarget, uiautomation.WindowControl) or isinstance(uiTarget, uiautomation.PaneControl):
        pattern = uiTarget.GetPattern(uiautomation.PatternId.WindowPattern)
        if pattern:
            pattern.Close()  # type: ignore

            delay(postExecutionDelay)
            return None

    raise UiOperationError(
        f"The element doesn't support closing or LiberRPA doesn't have permission. selector: {selector}"
    )


@Log.trace()
def close_window(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    """
    Close the element's window.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).
    """
    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_close_window)(
        selector,
        preExecutionDelay,
        postExecutionDelay,
    )


@Log.trace()
def check_window_exists(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> bool:
    """
    Check whether the element's window is existing.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        True if the element's window exists within the specified timeout, False otherwise.
    """

    selectorWindow = _extract_window_element(selector=selector)

    return check_exists(
        selector=selectorWindow,
        timeout=timeout,
        preExecutionDelay=preExecutionDelay,
        postExecutionDelay=postExecutionDelay,
    )


@Log.trace()
def get_active_window() -> SelectorWindow:
    """
    Get the selector of the currently active window.

    Returns:
        SelectorWindow: The selector of the currently active window.
    """
    hwnd = win32gui.GetForegroundWindow()
    if hwnd:
        control: uiautomation.Control = uiautomation.ControlFromHandle(hwnd)  # type: ignore - It should not be None
        return _UiElement.get_control_selector(control=control)
    else:
        raise UiElementNotFoundError("Not found a currently active window.")


@Log.trace()
def activate_element_window(selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage) -> None:
    """
    Activate the element's window.
    
    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
    """
    _UiElement.activate_element_window(selector=selector)


def _set_window_state(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    state: Literal["normal", "maximize", "minimize"] = "maximize",
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    selectorWindow = _extract_window_element(selector=selector)
    uiTarget, _ = _UiElement.get_element_with_pre_delay(selector=selectorWindow, preExecutionDelay=preExecutionDelay)

    if isinstance(uiTarget, uiautomation.WindowControl) or isinstance(uiTarget, uiautomation.PaneControl):
        pattern = uiTarget.GetPattern(uiautomation.PatternId.WindowPattern)
        if pattern:
            match state:
                case "normal":
                    pattern.SetWindowVisualState(state=0)  # type: ignore
                case "maximize":
                    pattern.SetWindowVisualState(state=1)  # type: ignore
                case "minimize":
                    pattern.SetWindowVisualState(state=2)  # type: ignore
                case _:
                    raise ValueError(
                        f"The argument state({state}) should be one of {['normal', 'maximize', 'minimize']}"
                    )

            delay(postExecutionDelay)
            return None

    raise UiOperationError(
        f"The element doesn't support setting window state or LiberRPA doesn't have permission. selector: {selector}"
    )


@Log.trace()
def set_window_state(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    state: Literal["normal", "maximize", "minimize"] = "maximize",
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    """
    Set the element's window to normal, maximize or minimize.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        state: Desired window state, can be 'normal', 'maximize', or 'minimize'.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).
    """
    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_set_window_state)(
        selector,
        state,
        preExecutionDelay,
        postExecutionDelay,
    )


def _get_window_position_and_size(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> DictPositionAndSize:

    selectorWindow = _extract_window_element(selector=selector)
    _, dictTarget = _UiElement.get_element_with_pre_delay(selector=selectorWindow, preExecutionDelay=preExecutionDelay)

    dictReturn: DictPositionAndSize = {
        "x": int(dictTarget["secondary-x"]),
        "y": int(dictTarget["secondary-y"]),
        "width": int(dictTarget["secondary-width"]),
        "height": int(dictTarget["secondary-height"]),
    }

    delay(postExecutionDelay)
    return dictReturn


@Log.trace()
def get_window_position_and_size(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> DictPositionAndSize:
    """
    Get the position and size of the element's window.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        DictPositionAndSize: {'x': <class 'int'>, 'y': <class 'int'>, 'width': <class 'int'>, 'height': <class 'int'>}
    """
    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_get_window_position_and_size)(
        selector,
        preExecutionDelay,
        postExecutionDelay,
    )


def _set_window_position(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    x: int,
    y: int,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:

    selectorWindow = _extract_window_element(selector=selector)
    _, dictTarget = _UiElement.get_element_with_pre_delay(selector=selectorWindow, preExecutionDelay=preExecutionDelay)

    uiautomation.MoveWindow(
        handle=int(dictTarget["secondary-NativeWindowHandle"]),  # type: ignore - it's DictUiaWindowAttr
        x=x,
        y=y,
        width=int(dictTarget["secondary-width"]),
        height=int(dictTarget["secondary-height"]),
    )

    delay(postExecutionDelay)
    return None


@Log.trace()
def set_window_position(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    x: int,
    y: int,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    """
    Set the position of the element's window.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        x: The horizontal position (in pixels) where the window's upper left corner should be moved to.
        y: The vertical position (in pixels) where the window's upper left corner should be moved to.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).
    """
    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_set_window_position)(
        selector,
        x,
        y,
        preExecutionDelay,
        postExecutionDelay,
    )


def _set_window_size(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    width: int,
    height: int,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:

    selectorWindow = _extract_window_element(selector=selector)
    _, dictTarget = _UiElement.get_element_with_pre_delay(selector=selectorWindow, preExecutionDelay=preExecutionDelay)

    uiautomation.MoveWindow(
        handle=int(dictTarget["secondary-NativeWindowHandle"]),  # type: ignore : it's DictUiaWindowAttr
        x=int(dictTarget["secondary-x"]),
        y=int(dictTarget["secondary-y"]),
        width=width,
        height=height,
    )

    delay(postExecutionDelay)
    return None


@Log.trace()
def set_window_size(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    width: int,
    height: int,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> None:
    """
    Set the size of the element's window.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        width: The new width of the window in pixels.
        height: The new height of the window in pixels.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_set_window_size)(
        selector,
        width,
        height,
        preExecutionDelay,
        postExecutionDelay,
    )


def _get_window_pid(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> int:

    selectorWindow = _extract_window_element(selector=selector)
    _, dictTarget = _UiElement.get_element_with_pre_delay(selector=selectorWindow, preExecutionDelay=preExecutionDelay)

    delay(postExecutionDelay)
    return int(dictTarget["secondary-ProcessId"])  # type: ignore : it's DictUiaWindowAttr


@Log.trace()
def get_window_pid(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> int:
    """
    Get the pid of the element's window.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        int: The pid of the window element.
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_get_window_pid)(
        selector,
        preExecutionDelay,
        postExecutionDelay,
    )


def _get_window_file_path(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> str:

    selectorWindow = _extract_window_element(selector=selector)
    _, dictTarget = _UiElement.get_element_with_pre_delay(selector=selectorWindow, preExecutionDelay=preExecutionDelay)

    delay(postExecutionDelay)
    return psutil.Process(int(dictTarget["secondary-ProcessId"])).exe()  # type: ignore : it's DictUiaWindowAttr


@Log.trace()
def get_window_file_path(
    selector: SelectorWindow | SelectorUia | SelectorHtml | SelectorImage,
    timeout: int = 10000,
    preExecutionDelay: int = 300,
    postExecutionDelay: int = 200,
) -> str:
    """
    Get the file path of the element's window.

    Parameters:
        selector: The dictionary for locating an element, it is generated by UI Analyzer, you can modify it to make it more concise, more suitable for all situations.
        timeout: Maximum time allowed for the function to complete (in milliseconds). If timeout < 3000 (milliseconds), it will be set to 3000. If the function doesn't completed after "timeout", it will throw an UiTimeoutError.
        preExecutionDelay: Time to wait before performing the action (in milliseconds).
        postExecutionDelay: Time to wait after performing the action (in milliseconds).

    Returns:
        str: The file path string.
    """

    timeout = _UiElement.check_set_timeout(timeout=timeout)

    return timeout_kill_thread(timeout=timeout)(_get_window_file_path)(
        selector,
        preExecutionDelay,
        postExecutionDelay,
    )


if __name__ == "__main__":
    from time import time

    # from liberrpa._Selector import *

    timeStart = time()

    # close_window(selector=image1)
    # print(check_window_exists(selector=image1))
    # print(get_active_window())
    # set_window_state(selector=image1, state="minimize")
    # print(get_window_position_and_size(selector=image1))
    # set_window_position(selector=image1, x=100, y=100)
    # set_window_size(selector=image1, width=500, height=500)

    # print(get_window_pid(selector=uiaWin2))
    # print(get_window_file_path(selector=image1))

    """ uiTarget, dictTarget = _UiElement.get_element(selector=image1)
    print(uiTarget)
    print(dictTarget) """
    """ pattern = uiTarget.GetPattern(uiautomation.PatternId.WindowPattern)
    print(pattern.WindowVisualState) """

    print("time used:", time() - timeStart)
