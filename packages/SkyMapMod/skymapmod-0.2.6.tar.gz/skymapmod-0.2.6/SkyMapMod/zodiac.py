import numpy as np
import matplotlib.pyplot as plt
import random

#коэффициент пересчета из единиц S10 в количество фотонов от Солнца
#вычислен на основе спектра АЧТ от звезды класса A0, солнечного спектра и факта, что 1 ед. S10 соответствует 100 фотонов от звезды класса A0


#переопределяю тригонометрические функции, чтобы работать с градусами
def cos(x):
    """
    Вычисляет косинус угла, заданного в градусах.

    Параметры:
        x (float): Угол в градусах.

    Возвращает:
        float: Значение косинуса угла.

    Примечания:
        - Функция преобразует угол из градусов в радианы перед вычислением.
    """
    return np.cos(x * np.pi / 180)

def sin(x):
    """
    Вычисляет синус угла, заданного в градусах.

    Параметры:
        x (float): Угол в градусах.

    Возвращает:
        float: Значение синуса угла.

    Примечания:
        - Функция преобразует угол из градусов в радианы перед вычислением.
    """
    return np.sin(x * np.pi / 180)

def tan(x):
    """
    Вычисляет тангенс угла, заданного в градусах.

    Параметры:
        x (float): Угол в градусах.

    Возвращает:
        float: Значение тангенса угла.

    Примечания:
        - Функция преобразует угол из градусов в радианы перед вычислением.
        - Для углов, близких к 90° или 270°, результат может быть неопределённым (деление на ноль).
    """
    return np.tan(x * np.pi / 180)

def acos(x):
    """
    Вычисляет арккосинус числа и возвращает результат в градусах.

    Параметры:
        x (float): Число в диапазоне [-1, 1].

    Возвращает:
        float: Значение арккосинуса в градусах.

    Примечания:
        - Результат преобразуется из радиан в градусы.
        - Если x не находится в диапазоне [-1, 1], возникает ошибка (ValueError).
    """
    return np.arccos(x) * 180 / np.pi

def asin(x):
    """
    Вычисляет арксинус числа и возвращает результат в градусах.

    Параметры:
        x (float): Число в диапазоне [-1, 1].

    Возвращает:
        float: Значение арксинуса в градусах.

    Примечания:
        - Результат преобразуется из радиан в градусы.
        - Если x не находится в диапазоне [-1, 1], возникает ошибка (ValueError).
    """
    return np.arcsin(x) * 180 / np.pi

def atan(x):
    """
    Вычисляет арктангенс числа и возвращает результат в градусах.

    Параметры:
        x (float): Число.

    Возвращает:
        float: Значение арктангенса в градусах.

    Примечания:
        - Результат преобразуется из радиан в градусы.
    """
    return np.arctan(x) * 180 / np.pi

#переопределяю прочие функции для красоты записи
def exp(x):
    """
    Вычисляет экспоненту числа.

    Параметры:
        x (float): Число.

    Возвращает:
        float: Значение экспоненты числа.

    Примечания:
        - Используется стандартная функция np.exp(x).
    """
    return np.exp(x)

def sqrt(x):
    """
    Вычисляет квадратный корень числа.

    Параметры:
        x (float): Неотрицательное число.

    Возвращает:
        float: Значение квадратного корня числа.

    Примечания:
        - Если x < 0, возникает ошибка (ValueError).
        - Используется стандартная функция np.sqrt(x).
    """
    return np.sqrt(x)

#функция Хевисайда (в контексте статьи определяется именно так)
def u(x):
    """
    Вычисляет значение функции Хевисайда (Heaviside step function).

    Функция Хевисайда определяется как:
        - 0, если x ≤ 0,
        - 1, если x > 0.
    Она используется для моделирования условий, которые применяются только 
    в определённых областях небесной сферы, например, для разделения солнечного 
    и антисолнечного полушарий.

    Параметры:
        x (float): Входное значение, для которого вычисляется функция.

    Возвращает:
        int: Значение функции Хевисайда:
            - 0, если x ≤ 0,
            - 1, если x > 0.

    Примечания:
        - Функция используется в модели зодиакального света для определения областей 
          применения различных слагаемых в уравнении (1) из статьи Buffington et al. (2016).
        - Например:
            - u(90 - ε) ≠ 0 только в солнечном полушарии,
            - u(ε - 90) ≠ 0 только в антисолнечном полушарии.

    Пример:
        >>> u(-5)
        0
        >>> u(0)
        0
        >>> u(5)
        1
    """
    if x <= 0:
        return 0
    elif x > 0:
        return 1
    
def spheral_to_decart(r, lmbd, beta):
    """
    Преобразует сферические координаты в декартовы.

    Функция принимает сферические координаты точки (радиус, долгота, широта)
    и преобразует их в декартовы координаты (x, y, z). Углы задаются в градусах.  Обозначения и порядок следования углов выбраны для
    удобства использования функции в дальнейшем коде.

    Параметры:
        r (float): Радиус (расстояние от начала координат до точки).
        lmbd (float): Долгота (угол в градусах, измеренный от оси X в плоскости XY). Лежит в диапазоне от 0° до 360°.
        beta (float): Широта (угол в градусах, измеренный от плоскости XY). Лежит в диапазоне от -90° до 90°.

    Возвращает:
        tuple: Кортеж из трех значений (x, y, z), представляющих декартовы координаты точки:
            - x (float): Координата по оси X.
            - y (float): Координата по оси Y.
            - z (float): Координата по оси Z.

    Пример:
        >>> r = 1.0
        >>> lmbd = 45.0  # 45 градусов
        >>> beta = 30.0  # 30 градусов
        >>> spheral_to_decart(r, lmbd, beta)
        (0.6123724356957945, 0.6123724356957945, 0.5)

    Примечания:
        - Углы `lmbd` (долгота) и `beta` (широта) должны быть заданы в градусах.
        - Если вы используете углы в радианах, преобразуйте их в градусы с помощью формулы: degrees = radians * 180 / pi.
    """
    x = r * cos(lmbd) * cos(beta)
    y = r * sin(lmbd) * cos(beta)
    z = r * sin(beta)
    return (x, y, z)


def decart_to_spheral(x, y, z):
    """
    Преобразует декартовы координаты в сферические.

    Функция принимает декартовы координаты точки (x, y, z)
    и преобразует их в сферические координаты (радиус, долгота, широта).
    Углы возвращаются в градусах. Обозначения и порядок следования углов выбраны для удобства использования функции в дальнейшем коде.

    Параметры:
        x (float): Координата по оси X.
        y (float): Координата по оси Y.
        z (float): Координата по оси Z.

    Возвращает:
        tuple: Кортеж из трех значений (r, lmbd, beta), представляющих сферические координаты точки:
            - r (float): Радиус (расстояние от начала координат до точки).
            - lmbd (float): Долгота (угол в градусах, измеренный от оси X в плоскости XY). Лежит в диапазоне от 0° до 360°.
            - beta (float): Широта (угол в градусах, измеренный от плоскости XY). Лежит в диапазоне от -90° до 90°.

    Пример:
        >>> x = 0.6123724356957945
        >>> y = 0.6123724356957945
        >>> z = 0.5
        >>> decart_to_spheral(x, y, z)
        (1.0, 45.0, 30.0)

    Примечания:
        - Углы `lmbd` (долгота) и `beta` (широта) возвращаются в градусах.
        - Для преобразования углов обратно в радианы используйте формулу: radians = degrees * pi / 180.
        - Если `x` близко к нулю, используется малая добавка (1e-30) для избежания деления на ноль.
    """
    r = sqrt(x**2 + y**2 + z**2)
    lmbd = atan(y/(x + 1e-30))
    beta = asin(z/r)
    return(r, lmbd, beta)


def rotate_ecl(lmbd, beta, lmbd0, beta0):
    """
    Поворачивает эклиптические координаты на заданные углы.

    Функция принимает начальные эклиптические координаты (долгота и широта)
    и выполняет их поворот на указанные углы (lmbd0 и beta0).
    Все углы задаются и возвращаются в градусах.

    Параметры:
        lmbd (float): Начальная эклиптическая долгота (в градусах).
        beta (float): Начальная эклиптическая широта (в градусах).
        lmbd0 (float): Угол поворота по долготе (в градусах).
        beta0 (float): Угол поворота по широте (в градусах).

    Возвращает:
        tuple: Кортеж из двух значений (lmbd2, beta2), представляющих новые эклиптические координаты:
            - lmbd2 (float): Новая эклиптическая долгота (в градусах).
            - beta2 (float): Новая эклиптическая широта (в градусах).

    Пример:
        >>> lmbd = 45.0  # Начальная долгота
        >>> beta = 10.0  # Начальная широта
        >>> lmbd0 = 30.0  # Угол поворота по долготе
        >>> beta0 = 5.0   # Угол поворота по широте
        >>> rotate_ecl(lmbd, beta, lmbd0, beta0)
        (75.0, 15.0)

    Примечания:
        - Все углы задаются и возвращаются в градусах.
        - Для преобразования углов обратно в радианы используйте формулу: radians = degrees * pi / 180.
        - Функция использует промежуточное преобразование в декартовы координаты для выполнения поворота.
    """
    x, y, z = spheral_to_decart(1, lmbd+lmbd0, beta) #ВОТ ТУТ БЫЛО ИЗНАЧАЛЬНО lmbd-lmbd0
    x1 = x * cos(beta0) + z * sin(beta0) 
    z1 = - x * sin(beta0) + z * cos(beta0)
    y1 = y
    r, lmbd2, beta2 = decart_to_spheral(x1, y1, z1)
    return(lmbd2, beta2)

#Далее идут функции, которые входят в общую формулу для расчета зод. света
#Компонента S
def S(lmbd, beta, lmbd_sun, Omega):
    """
    Вычисляет компоненту S модели зодиакального света.

    Компонента S представляет собой слагаемое, которое моделирует годовое изменение 
    яркости зодиакального света, вызванное наклоном плоскости симметрии пылевого облака 
    относительно эклиптики. Этот эффект перемещается между северным и южным полушариями в течение года.

    Параметры:
        lmbd (float): Эклиптическая долгота точки наблюдения (в градусах).
        beta (float): Эклиптическая широта точки наблюдения (в градусах).
        lmbd_sun (float): Эклиптическая долгота Солнца (в градусах).
        Omega (float): Долгота восходящего узла плоскости симметрии пылевого облака 
                       (в градусах). В модели используется значение Omega = 78.25°.

    Возвращает:
        float: Значение компоненты S, выраженное в единицах яркости (SMEI ADUs).

    Примечания:
        - Используется функция u(x)
    """
    c = cos(lmbd - lmbd_sun) * cos(beta)
    eps = acos(c)
    first = 6 * abs(sin(lmbd_sun - Omega))
    second = ((1-u(eps-90)) * (sin(eps) + 1e-30)**(-2.3) + u(eps - 90) * sin(eps))
    #third = (1 - u(Omega - lmbd_sun) / 4 + 2 * (1-u(eps-90)) * c)
    third = (1 - (1-u(lmbd_sun - Omega))/4 + 2*(1-u(eps-90)) * c)
    #equap = ((u(Omega - lmbd_sun) - u(lmbd_sun - Omega)) * beta + 5) / 10
    equap = ((1 - u(lmbd_sun - Omega) - u(lmbd_sun - Omega)) * beta + 5) / 10
    fourth = max(0, min(equap, 1))
    S = first * second * third * fourth
    return S

#Компонента D -- "эмпирический вклад в форме гантели"
def D(lmbd, beta, lmbd_sun):
    """
    Вычисляет компоненту D модели зодиакального света.

    Компонента D представляет собой аналитическое слагаемое в форме "гантели", которое 
    улучшает соответствие модели данным в областях, близких к Солнцу, но удаленных от 
    эклиптики и полюсов. Это эмпирический вклад.

    Параметры:
        lmbd (float): Эклиптическая долгота точки наблюдения (в градусах).
        beta (float): Эклиптическая широта точки наблюдения (в градусах).
        lmbd_sun (float): Эклиптическая долгота Солнца (в градусах).

    Возвращает:
        float: Значение компоненты D, выраженное в единицах яркости (SMEI ADUs).

    Примечания:
        - Используется функция rotate_ecl для поворота координат относительно Солнца.
    """
    d = abs(lmbd - lmbd_sun) / 6.5 - abs(beta) + 15 + 5 * u(beta)
    eps = acos(cos(lmbd - lmbd_sun) * cos(beta))
    if beta > 0:
        lmbd1, beta1 = rotate_ecl(lmbd, beta, lmbd_sun, 21)
    elif beta <= 0:
        lmbd1, beta1 = rotate_ecl(lmbd, beta, lmbd_sun, -15)
    gamma1 = atan(sin(lmbd1)/( 1e-30 + tan(beta1)))
    eps1 = acos(cos(lmbd1) * cos(beta1))
    h = gamma1 * (1 - u(beta)) + (gamma1) * u(beta)  
    A = (1 + 0.5 * (1 - u(beta))) * (1-u(eps-90)) * ((1-u(eps-75)) + u(eps - 75) * exp(-(eps - 75)**2 / 120))
#     f = 60 * exp(- eps1 / 16) * (0.15 + 0.85 * exp(-6 * cos(0.6 * h)**4))
    f = 60 * exp(- eps1 / 16) * (0.85 + 0.15 * exp(-6 * cos(0.6 * h)**4))
    g = 25 * exp(- acos(cos(2 * lmbd1) * cos(0.7 * beta1)) / 10)
    D = A * ((f * np.exp(-d / 10) + g * np.exp(-d / 8)) * u(d) + (f + g) * (1 - u(d)))
    return D

#Компонента E -- остаточная, не учитывалась
def E(lmbd, beta):
    """
    Вычисляет компоненту E модели зодиакального света.

    Компонента E представляет собой остаточный член, который не учитывается в данной 
    реализации модели. Она могла бы быть использована для покрытия дополнительных 
    эмпирических остатков, если бы они были значимыми.

    Параметры:
        lmbd (float): Эклиптическая долгота точки наблюдения (в градусах).
        beta (float): Эклиптическая широта точки наблюдения (в градусах).

    Возвращает:
        float: Значение компоненты E, всегда равное 0.

    Примечания:
        - Компонента E не используется в текущей реализации модели.
    """
    return 0

#Компонента F -- остаточная, не учитывалась
def F(lmbd, beta, lmbd_sun):
    """
    Вычисляет компоненту F модели зодиакального света.

    Компонента F представляет собой остаточный член, который также не учитывается в данной 
    реализации модели. Она могла бы быть использована для покрытия недостатков модели, 
    связанных с инструментальными артефактами.

    Параметры:
        lmbd (float): Эклиптическая долгота точки наблюдения (в градусах).
        beta (float): Эклиптическая широта точки наблюдения (в градусах).
        lmbd_sun (float): Эклиптическая долгота Солнца (в градусах).

    Возвращает:
        float: Значение компоненты F, всегда равное 0.

    Примечания:
        - Компонента F не используется в текущей реализации модели.
    """
    return 0

#Компонента G -- антисолнечная точка
def G(lmbd, beta, lmbd_sun):
    """
    Вычисляет компоненту G модели зодиакального света.

    Компонента G моделирует усиление яркости в антисолнечной точке (Gegenschein). 
    Она учитывает угловое расстояние до антисолнечной точки и его влияние на яркость.

    Параметры:
        lmbd (float): Эклиптическая долгота точки наблюдения (в градусах).
        beta (float): Эклиптическая широта точки наблюдения (в градусах).
        lmbd_sun (float): Эклиптическая долгота Солнца (в градусах).

    Возвращает:
        float: Значение компоненты G, выраженное в единицах яркости (SMEI ADUs).

    Примечания:
        - Антисолнечная точка определяется как точка, противоположная Солнцу 
          (lmbd_tild = lmbd - lmbd_sun - 180°).
        - Компонента G убывает для угловых расстояний ε_tild ≥ 60°, чтобы свести 
          вклад усиления к нулю в солнечном полушарии.
    """
    lmbd_tild = lmbd - lmbd_sun - 180
    if lmbd_tild > 180:
        lmbd_tild = lmbd_tild - 360
    elif lmbd_tild < -180:
        lmbd_tild = lmbd_tild + 360        
    eps_tild = 180 - acos(cos(lmbd_tild + 180) * cos(beta))    
    G_b         = 7.5 * exp(-eps_tild / 4) + 39.5 * exp(-eps_tild / 25)
    G_lmbd_tild = 7.5 * exp(-eps_tild / 4) + 39.5 * exp(-eps_tild / 35)  
    first = 1 - 0.02 * beta * lmbd_tild**2 / (eps_tild**3 + 1e-300)
    second = (beta**2 * G_b + lmbd_tild**2 * G_lmbd_tild) / (eps_tild**2 + 1e-300)
    third = (1 - u(eps_tild - 60) * (1 - exp(-(eps_tild - 60)**2 / 300)))
    G = first * second * third
    return G

#Общая формула для зод. света
def zodiacal_light(lmbd, beta, lmbd_sun):
    """
    Вычисляет яркость зодиакального света в заданной точке небесной сферы.

    Функция реализует эмпирическую модель зодиакального света, основанную на данных 
    Solar Mass Ejection Imager (SMEI).

    Параметры:
        lmbd (float): Эклиптическая долгота точки наблюдения (в градусах).
        beta (float): Эклиптическая широта точки наблюдения (в градусах).
        lmbd_sun (float): Эклиптическая долгота Солнца (в градусах).

    Возвращает:
        float: Значение яркости зодиакального света в единицах S10.

    Примечания:
        - Все углы задаются в градусах.
        - Используется функция u(x)
        - Результат делится на 0.415 для перевода из единиц ADU (SMEI) в единицы S10.
        - Omega = 78.25° — долгота восходящего узла плоскости симметрии пылевого облака.

    Ссылки:
        - Buffington, A., Bisi, M.M., Clover, J.M., et al., 2016. Measurements and an empirical 
          model of the Zodiacal brightness as observed by the Solar Mass Ejection Imager (SMEI). 
          Icarus 272, 88–101. doi: 10.1016/j.icarus.2016.02.037
    """
    b = 1.5 * (sqrt(1 + (beta / 1.5)**2) - 1)
    c = cos(lmbd - lmbd_sun) * cos(beta)
    eps = acos(c)
    eps_tild = 180 - eps
    lmbd_tild = lmbd - lmbd_sun - 180
    abs_gm = abs(atan(sin(lmbd - lmbd_sun) / (tan(beta) + 1e-30)))
    Omega = 78.25
    first = 7 + 8 * (1 - cos(b)) + 6 * exp(- beta**2 / 512)
    second_1 = (1-u(eps-90)) * (65 + 120 * c - 185 * c**2 + 65 * c**3) * (sin(eps) + 1e-30)**(-2.3)
    second_2 = u(eps - 90) * (65 + 120 * c + 154 * c**2 + 88 * c**3)
    second_mult = 10 ** (- sin(b) / (0.009 * (eps + 40)))  
    third = (1-u(eps-90)) * (30 * ((sin(eps) + 1e-30)**(-2.3) - 1) * cos(b))
    fourth = (8800 * exp((1 - sqrt(1 + ((abs_gm - 90)/3)**2))/10) - 1200) * exp(-eps/10)
    zod = first  + (second_1 + second_2) * second_mult + third + fourth + S(lmbd, beta, lmbd_sun, Omega) + D(lmbd, beta, lmbd_sun) + E(lmbd, beta) + F(lmbd, beta, lmbd_sun) + G(lmbd, beta, lmbd_sun)
    return zod/0.415 #деление на 0.415 осуществляет переход из ед. ADU в ед. S10

##Пересчет S10 в количество фотонов от Солнца

#Импортирую нужные спектры
from .solar_spectrum import wavelenght_newguey2003, flux_newguey2003
from .band_V_data import wavelenght_band_V, trancparency_band_V


def black_body(lmbd, T):
    """
    Рассчитывает спектр излучения абсолютно черного тела (АЧТ) по закону Планка.

    Функция принимает массив длин волн (в нанометрах) и температуру (в кельвинах),
    и возвращает спектральную плотность излучения абсолютно черного тела.
    Расчет выполняется по формуле Планка.

    Параметры:
        lmbd (ndarray): Массив длин волн в нанометрах (нм).
        T (float): Температура абсолютно черного тела в кельвинах (K).

    Возвращает:
        ndarray: Массив значений спектральной плотности излучения в Вт/(м^2 * м).
                 Размерность выходного массива совпадает с размерностью входного массива длин волн.

    Пример:
        >>> wavelengths = np.array([400, 500, 600])  # Длины волн в нанометрах
        >>> temperature = 10000  # Температура в кельвинах
        >>> black_body(wavelengths, temperature)
        array([1.83e+13, 7.95e+13, 1.29e+14])

    Примечания:
        - Длина волны задается в нанометрах (нм), но внутри функции преобразуется в метры.
        - Температура задается в кельвинах (K).
        - Формула Планка:
            u(λ, T) = (2 * h * c^2) / λ^5 / (exp((h * c) / (λ * k * T)) - 1),
          где:
            - h = 6.63e-34 Дж·с — постоянная Планка,
            - c = 3e8 м/с — скорость света,
            - k = 1.38e-23 Дж/К — постоянная Больцмана,
            - λ — длина волны в метрах,
            - T — температура в кельвинах.
        - Выходной массив имеет размерность Вт/(м^2 * м), что соответствует спектральной плотности излучения.
    """
    h = 6.63e-34 #Дж * сек
    c = 3e8 # м / сек
    k = 1.38e-23 # Дж / К
    lmbd = lmbd * 1e-9 # м
    u = 2 * h * c**2 / (lmbd**5) / (np.exp(h * c / (lmbd) / k / T) - 1)
    return u 


def black_body_phot(lmbd, T):
    """
    Рассчитывает спектр излучения абсолютно черного тела (АЧТ) в фотонах.

    Функция принимает массив длин волн (в нанометрах) и температуру (в кельвинах),
    и возвращает спектральную плотность числа фотонов, излучаемых абсолютно черным телом.
    Расчет выполняется по модифицированной формуле Планка, учитывающей энергию фотонов.

    Параметры:
        lmbd (ndarray): Массив длин волн в нанометрах (нм).
        T (float): Температура абсолютно черного тела в кельвинах (K).

    Возвращает:
        ndarray: Массив значений спектральной плотности числа фотонов в фот/(м^2 * м * сек).
                 Размерность выходного массива совпадает с размерностью входного массива длин волн.

    Пример:
        >>> wavelengths = np.array([400, 500, 600])  # Длины волн в нанометрах
        >>> temperature = 10000  # Температура в кельвинах
        >>> black_body_phot(wavelengths, temperature)
        array([5.53e+22, 2.41e+23, 3.89e+23])

    Примечания:
        - Длина волны задается в нанометрах (нм), но внутри функции преобразуется в метры.
        - Температура задается в кельвинах (K).
        - Формула расчета:
            u(λ, T) = (2 * c) / λ^4 / (exp((h * c) / (λ * k * T)) - 1),
          где:
            - h = 6.63e-34 Дж·с — постоянная Планка,
            - c = 3e8 м/с — скорость света,
            - k = 1.38e-23 Дж/К — постоянная Больцмана,
            - λ — длина волны в метрах,
            - T — температура в кельвинах.
        - Выходной массив имеет размерность фот/(м^2 * м * сек), что соответствует спектральной плотности числа фотонов.
    """
    h = 6.63e-34 #Дж * сек
    c = 3e8 # м / сек
    k = 1.38e-23 # Дж / К
    lmbd = lmbd * 1e-9 # м
    u = 2 * c / (lmbd**4) / (np.exp(h * c / (lmbd) / k / T) - 1)
    return u #уже в фотонах/сек (поделено на hc/lambda)


def convolution(array_1, meaning_1, array_2, meaning_2):
    """
    Универсальная функция для свертки двух спектров.

    Эта функция принимает два набора данных: массивы длин волн и соответствующие им спектры для двух объектов,
    и выполняет операцию свертки на основе совпадающих длин волн.

    Параметры:
        array_1 (ndarray): Массив длин волн первого объекта.
        meaning_1 (ndarray): Спектр (значения) первого объекта, соответствующий array_1.
        array_2 (ndarray): Массив длин волн второго объекта.
        meaning_2 (ndarray): Спектр (значения) второго объекта, соответствующий array_2.

    Возвращает:
        tuple: Кортеж из двух NumPy массивов:
            - array (ndarray): массив, содержащий совпадающие длины волн из array_1 и array_2.
            - meaning (ndarray): массив, содержащий произведения значений спектров (meaning_1 * meaning_2)
              для соответствующих длин волн.

    Пример:
        >>> array_1 = np.array([400, 500, 600])
        >>> meaning_1 = np.array([1.0, 2.0, 3.0])
        >>> array_2 = np.array([500, 600, 700])
        >>> meaning_2 = np.array([4.0, 5.0, 6.0])
        >>> result = convolution(array_1, meaning_1, array_2, meaning_2)
        >>> print(result)
        (array([500, 600]), array([8.0, 15.0]))
    """
    array = []
    meaning = []
    for i in range(array_1.shape[0]):
        for j in range(array_2.shape[0]):
            if array_1[i] == array_2[j]:
                array.append(array_1[i])
                meaning.append(meaning_1[i] * meaning_2[j])
    return np.array(array), np.array(meaning)


def integral(wl, spec):
    """
    Вычисляет интеграл по спектру методом трапеций.

    Функция принимает массив длин волн (в нанометрах) и соответствующий массив значений спектра,
    и вычисляет интеграл методом трапеций. Это позволяет получить общую интенсивность излучения
    или количество фотонов, учитывая заданный спектр.

    Параметры:
        wl (ndarray): Массив длин волн в нанометрах (нм). Должен быть отсортирован по возрастанию.
        spec (ndarray): Массив значений спектра в фот/(м^2 * нм * сек).
                           Размерность массива должна совпадать с размерностью массива длин волн.

    Возвращает:
        float: Значение интеграла, представляющее площадь под кривой спектра.
               Размерность результата зависит от входных данных:
               - Если спектр задан в фот/(м^2 * нм * сек), результат будет в фот/(м^2 * сек).

    Пример:
        >>> wavelengths = np.array([400, 500, 600])  # Длины волн в нанометрах
        >>> spectrum = np.array([1e13, 2e13, 1.5e13])  # Спектр в фот/(м^2 * нм * сек)
        >>> integral(wavelengths, spectrum)
        1.75e16

    Примечания:
        - Метод трапеций используется для численного интегрирования. Он аппроксимирует площадь под кривой
          как сумму трапеций, образованных соседними точками.
        - Формула для одной трапеции:
            area = (spec[i] + spec[i+1]) / 2 * (wl[i+1] - wl[i]),
          где:
            - spec[i] и spec[i+1] — значения спектра в соседних точках,
            - wl[i] и wl[i+1] — длины волн в соседних точках.
        - Массивы `wl` и `spec` должны иметь одинаковую размерность.
        - Результат интегрирования имеет размерность, равную произведению размерностей входных данных:
          - [wl] = нм,
          - [spec] = фот/(м^2 * нм * сек),
          - [результат] = фот/(м^2 * сек).
    """
    shape = wl.shape[0]
    result = 0
    for i in range(shape - 1):
        result += (spec[i] + spec[i+1]) / 2 * (wl[i+1] - wl[i])
    return result

def zodiacal_spectrum(lmbd, beta, lmbd_sun, Sun_sp_wl = wavelenght_newguey2003, Sun_sp_fx = flux_newguey2003, V_wl = wavelenght_band_V, V_tr = trancparency_band_V):
    """
    Вычисляет спектр зодиакального света для заданных эклиптических координат.

    Функция принимает эклиптические координаты точки наблюдения, эклиптическую долготу Солнца,
    а также спектр Солнца и полосу пропускания V (по умолчанию используются стандартные данные).
    На основе этих данных функция вычисляет нормировочную константу для солнечного спектра,
    чтобы его можно было использовать как спектр зодиакального света. Расчет основан на единицах
    S10, их связи со звездой 10-й звездной величины и коэффициенте пересчета от звезды 10-й величины в полосе V
    к Солнцу в полосе V.

    Параметры:
        lmbd (float): Эклиптическая долгота точки наблюдения (в градусах).
        beta (float): Эклиптическая широта точки наблюдения (в градусах).
        lmbd_sun (float): Эклиптическая долгота Солнца (в градусах).
        Sun_sp_wl (ndarray, optional): Массив длин волн солнечного спектра (в нм). 
                                           По умолчанию используется `wavelenght_newguey2003`.
        Sun_sp_fx (ndarray, optional): Массив значений солнечного спектра (в фот / (м^2 сек нм)).
                                           По умолчанию используется `flux_newguey2003`.
        V_wl (ndarray, optional): Массив длин волн полосы пропускания V (в нм). 
                                      По умолчанию используется `wavelenght_band_V`.
        V_tr (ndarray, optional): Массив значений прозрачности полосы пропускания V.
                                      По умолчанию используется `trancparency_band_V`.

    Возвращает:
        tuple: Кортеж из двух массивов:
            - Sun_sp_wl (ndarray): Массив длин волн зодиакального спектра (в нм),
            - Sun_sp_fx (ndarray): Массив значений спектра зодиакального света (в фот / (м^2 сек нм)).

    Примечания:
        - Единица яркости S10 соответствует 100 фотонам/(см^2 сек) от звезды класса A0.
        - Коэффициент пересчета N_S10 из единиц S10 в количество фотонов от Солнца:
            - 1 ед. S10 = 100.6 фотонов/(см^2 сек),
        - Нормировка солнечного спектра производится путем свертки с полосой пропускания V
          и последующего интегрирования.
        - Используется функция `zodiacal_light` для расчета яркости зодиакального света в единицах S10.

    Ссылки:
        - Buffington, A., Bisi, M.M., Clover, J.M., et al., 2016. Measurements and an empirical model of the Zodiacal brightness as observed by the Solar Mass Ejection Imager (SMEI). Icarus 272, 88–101. doi: 10.1016/j.icarus.2016.02.037
    """
    #коэффициент пересчета из единиц S10 в количество фотонов от Солнца
    #вычислен на основе спектра АЧТ от звезды класса A0, солнечного спектра и факта, что 1 ед. S10 соответствует 100 фотонов от звезды класса A0
    #вот столько фотонов/(см^2 сек) от Солнца несет 1 ед S10:
    N_S10 = 100.6 
    N_S10 = N_S10 * 10**4 * 10**(-2)# к метрам и к бинам
    S10 = zodiacal_light(lmbd, beta, lmbd_sun) 
    integr = 4.458 * 10 ** (20) #интеграл по свертке солнечного с полосой V
    A = S10 * N_S10 / integr
    
    
    #############################################
    a, b = convolution(Sun_sp_wl, A * Sun_sp_fx, V_wl, V_tr)
    c = integr = integral(a, b)
#     print('Техническая проверка: S10*N_S10 =', S10 * N_S10)
#     print('А при нормировке и интегрированию получается:', c)
    #############################################
    Sun_sp_fx = Sun_sp_fx * A
    
    return Sun_sp_wl, Sun_sp_fx #нм, фот / (м^2 сек нм ср)
    
    
