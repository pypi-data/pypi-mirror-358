# coding: utf-8

"""
    Speechall API

    The Speechall REST API provides powerful and flexible speech-to-text capabilities. It allows you to transcribe audio files using various underlying STT providers and models, optionally apply custom text replacement rules, and access results in multiple formats. The API includes standard endpoints for transcription and endpoints compatible with the OpenAI API structure. 

    The version of the OpenAPI document: 0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from typing import List, Optional, Union
from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist, validator
from speechall.models.transcription_model_identifier import TranscriptionModelIdentifier
from speechall.models.transcription_provider import TranscriptionProvider

class SpeechToTextModel(BaseModel):
    """
    Describes an available speech-to-text model, its provider, capabilities, and characteristics.  # noqa: E501
    """
    id: TranscriptionModelIdentifier = Field(...)
    display_name: StrictStr = Field(default=..., description="A user-friendly name for the model.")
    provider: TranscriptionProvider = Field(...)
    description: Optional[StrictStr] = Field(default=None, description="A brief description of the model, its intended use case, or version notes.")
    cost_per_second_usd: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The cost per second of audio processed in USD.")
    is_available: StrictBool = Field(default=..., description="Indicates whether the model is currently available for use.")
    supported_languages: Optional[conlist(StrictStr)] = Field(default=None, description="A list of language codes (preferably BCP 47, e.g., \"en-US\", \"en-GB\", \"es-ES\") supported by this model. May include `auto` if automatic language detection is supported across multiple languages within a single audio file. ")
    punctuation: Optional[StrictBool] = Field(default=None, description="Indicates whether the model generally supports automatic punctuation insertion.")
    diarization: Optional[StrictBool] = Field(default=None, description="Indicates whether the model generally supports speaker diarization (identifying different speakers).")
    streamable: Optional[StrictBool] = Field(default=None, description="Indicates whether the model can be used for real-time streaming transcription via a WebSocket connection (if offered by Speechall).")
    real_time_factor: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="An approximate measure of processing speed for batch processing. Defined as (audio duration) / (processing time). A higher value means faster processing (e.g., RTF=2 means it processes 1 second of audio in 0.5 seconds). May not be available for all models or streaming scenarios. ")
    max_duration_seconds: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The maximum duration of a single audio file (in seconds) that the model can reliably process in one request. May vary by provider or plan.")
    max_file_size_bytes: Optional[StrictInt] = Field(default=None, description="The maximum size of a single audio file (in bytes) that can be uploaded for processing by this model. May vary by provider or plan.")
    version: Optional[StrictStr] = Field(default=None, description="The specific version identifier for the model.")
    release_date: Optional[date] = Field(default=None, description="The date when this specific version of the model was released or last updated.")
    model_type: Optional[StrictStr] = Field(default=None, description="The primary type or training domain of the model. Helps identify suitability for different audio types.")
    accuracy_tier: Optional[StrictStr] = Field(default=None, description="A general indication of the model's expected accuracy level relative to other models. Not a guaranteed metric.")
    supported_audio_encodings: Optional[conlist(StrictStr)] = Field(default=None, description="A list of audio encodings that this model supports or is optimized for (e.g., LINEAR16, FLAC, MP3, Opus).")
    supported_sample_rates: Optional[conlist(StrictInt)] = Field(default=None, description="A list of audio sample rates (in Hz) that this model supports or is optimized for.")
    speaker_labels: Optional[StrictBool] = Field(default=None, description="Indicates whether the model can provide speaker labels for the transcription.")
    word_timestamps: Optional[StrictBool] = Field(default=None, description="Indicates whether the model can provide timestamps for individual words.")
    confidence_scores: Optional[StrictBool] = Field(default=None, description="Indicates whether the model provides confidence scores for the transcription or individual words.")
    language_detection: Optional[StrictBool] = Field(default=None, description="Indicates whether the model supports automatic language detection for input audio.")
    custom_vocabulary_support: Optional[StrictBool] = Field(default=None, description="Indicates if the model can leverage a custom vocabulary or language model adaptation.")
    profanity_filtering: Optional[StrictBool] = Field(default=None, description="Indicates if the model supports filtering or masking of profanity.")
    noise_reduction: Optional[StrictBool] = Field(default=None, description="Indicates if the model supports noise reduction.")
    supports_srt: StrictBool = Field(default=..., description="Indicates whether the model supports SRT subtitle format output.")
    supports_vtt: StrictBool = Field(default=..., description="Indicates whether the model supports VTT subtitle format output.")
    voice_activity_detection: Optional[StrictBool] = Field(default=None, description="Indicates whether the model supports voice activity detection (VAD) to identify speech segments.")
    __properties = ["id", "display_name", "provider", "description", "cost_per_second_usd", "is_available", "supported_languages", "punctuation", "diarization", "streamable", "real_time_factor", "max_duration_seconds", "max_file_size_bytes", "version", "release_date", "model_type", "accuracy_tier", "supported_audio_encodings", "supported_sample_rates", "speaker_labels", "word_timestamps", "confidence_scores", "language_detection", "custom_vocabulary_support", "profanity_filtering", "noise_reduction", "supports_srt", "supports_vtt", "voice_activity_detection"]

    @validator('model_type')
    def model_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('general', 'phone_call', 'video', 'command_and_search', 'medical', 'legal', 'voicemail', 'meeting',):
            raise ValueError("must be one of enum values ('general', 'phone_call', 'video', 'command_and_search', 'medical', 'legal', 'voicemail', 'meeting')")
        return value

    @validator('accuracy_tier')
    def accuracy_tier_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('basic', 'standard', 'enhanced', 'premium',):
            raise ValueError("must be one of enum values ('basic', 'standard', 'enhanced', 'premium')")
        return value

    # Added this to fix the release_date field
    @validator('release_date', pre=True)
    def parse_release_date(cls, value):
        """Parse release_date from various string formats"""
        if value is None or isinstance(value, date):
            return value
        
        if isinstance(value, str):
            # Try common date formats
            date_formats = [
                '%Y-%m-%d',          # ISO format: 2023-12-25
                '%m/%d/%Y',          # US format: 12/25/2023
                '%d/%m/%Y',          # European format: 25/12/2023
                '%Y-%m-%dT%H:%M:%S', # ISO datetime format
                '%Y-%m-%dT%H:%M:%SZ',# ISO datetime with Z
                '%Y-%m-%d %H:%M:%S', # Space separated datetime
            ]
            
            for fmt in date_formats:
                try:
                    parsed_datetime = datetime.strptime(value, fmt)
                    return parsed_datetime.date()
                except ValueError:
                    continue
            
            # If no format works, try to return None to avoid errors
            return None
        
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> SpeechToTextModel:
        """Create an instance of SpeechToTextModel from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # set to None if description (nullable) is None
        # and __fields_set__ contains the field
        if self.description is None and "description" in self.__fields_set__:
            _dict['description'] = None

        # set to None if cost_per_second_usd (nullable) is None
        # and __fields_set__ contains the field
        if self.cost_per_second_usd is None and "cost_per_second_usd" in self.__fields_set__:
            _dict['cost_per_second_usd'] = None

        # set to None if supported_languages (nullable) is None
        # and __fields_set__ contains the field
        if self.supported_languages is None and "supported_languages" in self.__fields_set__:
            _dict['supported_languages'] = None

        # set to None if punctuation (nullable) is None
        # and __fields_set__ contains the field
        if self.punctuation is None and "punctuation" in self.__fields_set__:
            _dict['punctuation'] = None

        # set to None if diarization (nullable) is None
        # and __fields_set__ contains the field
        if self.diarization is None and "diarization" in self.__fields_set__:
            _dict['diarization'] = None

        # set to None if streamable (nullable) is None
        # and __fields_set__ contains the field
        if self.streamable is None and "streamable" in self.__fields_set__:
            _dict['streamable'] = None

        # set to None if real_time_factor (nullable) is None
        # and __fields_set__ contains the field
        if self.real_time_factor is None and "real_time_factor" in self.__fields_set__:
            _dict['real_time_factor'] = None

        # set to None if max_duration_seconds (nullable) is None
        # and __fields_set__ contains the field
        if self.max_duration_seconds is None and "max_duration_seconds" in self.__fields_set__:
            _dict['max_duration_seconds'] = None

        # set to None if max_file_size_bytes (nullable) is None
        # and __fields_set__ contains the field
        if self.max_file_size_bytes is None and "max_file_size_bytes" in self.__fields_set__:
            _dict['max_file_size_bytes'] = None

        # set to None if version (nullable) is None
        # and __fields_set__ contains the field
        if self.version is None and "version" in self.__fields_set__:
            _dict['version'] = None

        # set to None if release_date (nullable) is None
        # and __fields_set__ contains the field
        if self.release_date is None and "release_date" in self.__fields_set__:
            _dict['release_date'] = None

        # set to None if model_type (nullable) is None
        # and __fields_set__ contains the field
        if self.model_type is None and "model_type" in self.__fields_set__:
            _dict['model_type'] = None

        # set to None if accuracy_tier (nullable) is None
        # and __fields_set__ contains the field
        if self.accuracy_tier is None and "accuracy_tier" in self.__fields_set__:
            _dict['accuracy_tier'] = None

        # set to None if supported_audio_encodings (nullable) is None
        # and __fields_set__ contains the field
        if self.supported_audio_encodings is None and "supported_audio_encodings" in self.__fields_set__:
            _dict['supported_audio_encodings'] = None

        # set to None if supported_sample_rates (nullable) is None
        # and __fields_set__ contains the field
        if self.supported_sample_rates is None and "supported_sample_rates" in self.__fields_set__:
            _dict['supported_sample_rates'] = None

        # set to None if speaker_labels (nullable) is None
        # and __fields_set__ contains the field
        if self.speaker_labels is None and "speaker_labels" in self.__fields_set__:
            _dict['speaker_labels'] = None

        # set to None if word_timestamps (nullable) is None
        # and __fields_set__ contains the field
        if self.word_timestamps is None and "word_timestamps" in self.__fields_set__:
            _dict['word_timestamps'] = None

        # set to None if confidence_scores (nullable) is None
        # and __fields_set__ contains the field
        if self.confidence_scores is None and "confidence_scores" in self.__fields_set__:
            _dict['confidence_scores'] = None

        # set to None if language_detection (nullable) is None
        # and __fields_set__ contains the field
        if self.language_detection is None and "language_detection" in self.__fields_set__:
            _dict['language_detection'] = None

        # set to None if custom_vocabulary_support (nullable) is None
        # and __fields_set__ contains the field
        if self.custom_vocabulary_support is None and "custom_vocabulary_support" in self.__fields_set__:
            _dict['custom_vocabulary_support'] = None

        # set to None if profanity_filtering (nullable) is None
        # and __fields_set__ contains the field
        if self.profanity_filtering is None and "profanity_filtering" in self.__fields_set__:
            _dict['profanity_filtering'] = None

        # set to None if noise_reduction (nullable) is None
        # and __fields_set__ contains the field
        if self.noise_reduction is None and "noise_reduction" in self.__fields_set__:
            _dict['noise_reduction'] = None

        # set to None if voice_activity_detection (nullable) is None
        # and __fields_set__ contains the field
        if self.voice_activity_detection is None and "voice_activity_detection" in self.__fields_set__:
            _dict['voice_activity_detection'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> SpeechToTextModel:
        """Create an instance of SpeechToTextModel from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return SpeechToTextModel.parse_obj(obj)

        _obj = SpeechToTextModel.parse_obj({
            "id": obj.get("id"),
            "display_name": obj.get("display_name"),
            "provider": obj.get("provider"),
            "description": obj.get("description"),
            "cost_per_second_usd": obj.get("cost_per_second_usd"),
            "is_available": obj.get("is_available") if obj.get("is_available") is not None else True,
            "supported_languages": obj.get("supported_languages"),
            "punctuation": obj.get("punctuation"),
            "diarization": obj.get("diarization"),
            "streamable": obj.get("streamable"),
            "real_time_factor": obj.get("real_time_factor"),
            "max_duration_seconds": obj.get("max_duration_seconds"),
            "max_file_size_bytes": obj.get("max_file_size_bytes"),
            "version": obj.get("version"),
            "release_date": obj.get("release_date"),
            "model_type": obj.get("model_type"),
            "accuracy_tier": obj.get("accuracy_tier"),
            "supported_audio_encodings": obj.get("supported_audio_encodings"),
            "supported_sample_rates": obj.get("supported_sample_rates"),
            "speaker_labels": obj.get("speaker_labels"),
            "word_timestamps": obj.get("word_timestamps"),
            "confidence_scores": obj.get("confidence_scores"),
            "language_detection": obj.get("language_detection"),
            "custom_vocabulary_support": obj.get("custom_vocabulary_support"),
            "profanity_filtering": obj.get("profanity_filtering"),
            "noise_reduction": obj.get("noise_reduction"),
            "supports_srt": obj.get("supports_srt") if obj.get("supports_srt") is not None else False,
            "supports_vtt": obj.get("supports_vtt") if obj.get("supports_vtt") is not None else False,
            "voice_activity_detection": obj.get("voice_activity_detection")
        })
        return _obj


